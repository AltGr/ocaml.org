<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: OCaml Planet</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contributors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="OCaml Planet" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it Online</a></li>
    <li><a href="../taste.html">100 Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who Is Using It?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a>
        <a href="http://langref.org/ocaml">langref.org</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
    <li><a href="../papers.html">Papers</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../releases/latest.html">Releases</a></li>
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development Tools</a></li>
    <li><a href="../books.html#manual">User Manual</a></li>
    <li><a href="../cheat_sheets.html">Cheat Sheets</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API Search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">GitHub</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing Lists</a></li>
    <li><a href="../planet/">Blogs</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>OCaml Planet
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

    <h1>OCaml Planet</h1>

    <p>The OCaml Planet aggregates various blogs from the OCaml
    community.  It is kindly provided
    by <a href="http://www.ocamlcore.com/">OCamlCore</a>.  If you
    would like to be added, read
    the <a href="http://www.ocamlcore.org/planet/">Planet
    subscription HOWTO</a>.</p>

    <br/>
    <div style="float: right; margin-right: 0; margin-top: 0" class="span2 planet-subscriptions"><em>Subscriptions</em>
      <ul><li><a href="http://alexleighton.tumblr.com/tagged/ocaml/rss">Alex Leighton</a></li><li><a href="http://blog.mestan.fr/feed/?cat=16">Alp Mestan</a></li><li><a href="http://andreiformiga.com/blog/?cat=5&feed=rss2">Andrei Formiga</a></li><li><a href="http://math.andrej.com/feed/">Andrej Bauer</a></li><li><a href="http://anil.recoil.org/feeds/atom.xml">Anil Madhavapeddy</a></li><li><a href="http://unnali.com/tag/ocaml/feed/">Arlen Cuss</a></li><li><a href="http://ashishagarwal.org/tag/ocaml/feed/">Ashish Agarwal</a></li><li><a href="http://www.blogger.com/feeds/7617521785419311079/posts/default">Cameleon news</a></li><li><a href="http://caml.inria.fr/news.en.rss">Caml INRIA</a></li><li><a href="http://camlspotter.blogspot.com/feeds/posts/default?alt=rss">Caml Spotting</a></li><li><a href="http://alan.petitepomme.net/cwn/cwn.rss">Caml Weekly News</a></li><li><a href="http://procrastiblog.com/category/ocaml/feed/">Christopher Conway</a></li><li><a href="http://coherentpdf.com/blog/?tag=ocaml&feed=rss">Coherent Graphics</a></li><li><a href="http://coq.inria.fr/news/feed">Coq</a></li><li><a href="http://erratique.ch/feeds/news.atom">Daniel Bünzli</a></li><li><a href="http://blog.dbpatterson.com/rss">Daniel Patterson</a></li><li><a href="http://nleyten.com/atom.aspx">Dario Teixeira</a></li><li><a href="http://www.blogger.com/feeds/17133288/posts/default/-/ocaml">David Baelde</a></li><li><a href="http://bentobako.org/david/blog/index.php?feed/tag/ocaml/atom">David Mentré</a></li><li><a href="http://dutherenverseauborddelatable.wordpress.com/category/ocaml/feed/">David Teller</a></li><li><a href="http://www.examachine.net/blog/?feed=rss2&cat=4">Eray Özkural</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/CodeHacking/Ocaml/index.rss20">Erik de Castro Lopo</a></li><li><a href="http://blog.emillon.org/feeds/ocaml.xml">Etienne Millon</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/FP-Syd/index.rss20">FP-Sydney</a></li><li><a href="http://www.blogger.com/feeds/8964007124326996693/posts/default/-/ocaml">Fayssal Martani</a></li><li><a href="http://frama-c.com/rss.xml">Frama-C</a></li><li><a href="http://functionaljobs.com/jobs/search/?q=ocaml&format=rss">Functional Jobs</a></li><li><a href="http://gallium.inria.fr/~scherer/gagallium/index.rss">GaGallium</a></li><li><a href="http://gaiustech.wordpress.com/category/ocaml/feed/">Gaius Hammond</a></li><li><a href="http://blog.camlcity.org/blog/rss">Gerd Stolpmann</a></li><li><a href="http://www.wisdomandwonder.com/tag/OCaml/feed">Grant Rettke</a></li><li><a href="http://blog.incubaid.com/tag/ocaml/feed/">Incubaid Research</a></li><li><a href="http://ambassadortothecomputers.blogspot.com/feeds/posts/default?alt=rss">Jake Donham</a></li><li><a href="http://scattered-thoughts.net/rss?tag=ocaml">Jamie Brandon</a></li><li><a href="http://ocaml.janestcapital.com/?q=rss.xml">Jane Street</a></li><li><a href="http://www.lexifi.com/blogs/ocaml/feed">LexiFi</a></li><li><a href="http://savonet.sourceforge.net/liquidsoap.rss">Liquidsoap</a></li><li><a href="http://syntaxexclamation.wordpress.com/tag/ocaml/feed/">Matthias Puech</a></li><li><a href="http://www.blogger.com/feeds/5888658295182480819/posts/default">Matías Giovannini</a></li><li><a href="http://eigenclass.org/R2/feeds/rss2/all">Mauricio Fernandez</a></li><li><a href="http://www.elehack.net/michael/blog/tags/ocaml?format=rss">Michael Ekstrand</a></li><li><a href="http://www.rktmb.org:82/feed/category/work/ocaml/atom">Mihamina Rakotomandimby</a></li><li><a href="http://mcclurmc.wordpress.com/feed/">Mike McClurg</a></li><li><a href="http://nyc-ocaml.posterous.com/rss.xml">NYC OCaml</a></li><li><a href="http://ocamlhackers.ning.com/profiles/blog/feed?tag=ocaml&xn_auth=no">OCaml Hackers</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfnews.php">OCamlCore Forge News</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfprojects.php">OCamlCore Forge Projects</a></li><li><a href="http://www.ocamlcore.com/wp/?feed=rss2&amp;language=en&#038;language=en">OCamlCore.com</a></li><li><a href="http://www.ocamlpro.com/feed/atom.xml">OCamlPro</a></li><li><a href="http://odns.tuxfamily.org/feed/">ODNS project</a></li><li><a href="http://ox.tuxfamily.org/feed/">Ocaml XMPP project</a></li><li><a href="http://ocsigen.org/news.atom">Ocsigen project</a></li><li><a href="http://www.blogger.com/feeds/2073503406800427577/posts/default">Opa</a></li><li><a href="http://www.openmirage.org/blog/atom.xml">Open Mirage</a></li><li><a href="http://functional-orbitz.blogspot.com/feeds/posts/default/-/planetocaml?alt=rss">Orbitz</a></li><li><a href="http://www.donadeo.net/facets/programming-languages/objective-caml/feed/">Paolo Donadeo</a></li><li><a href="https://mancoosi.org/~abate/taxonomy/term/5/0/feed">Pietro Abate</a></li><li><a href="http://redlizards.com/blog/feed/?tag=ocaml">Red Lizard Software</a></li><li><a href="http://rwmj.wordpress.com/tag/ocaml/feed/">Richard Jones</a></li><li><a href="http://blog.rastageeks.org/spip.php?page=rss&id_mot=2">Romain Beauxis</a></li><li><a href="http://seb.mondet.org/blog/feed/ocaml.rss">Sebastien Mondet</a></li><li><a href="http://upsilon.cc/~zack/tags/ocaml/index.rss">Stefano Zacchiroli</a></li><li><a href="http://le-gall.net/sylvain+violaine/blog/index.php?feed/tag/ocaml/atom">Sylvain Le Gall</a></li><li><a href="http://caml.inria.fr/hump.rss">The Caml Humps</a></li><li><a href="http://www.blogger.com/feeds/6115529230232389198/posts/default">Till Varoquaux</a></li><li><a href="http://www.nicollet.net/toroidal/ocaml/feed/">Victor Nicollet</a></li><li><a href="http://y-node.com/blog/feeds/tag/ocaml/">y-node</a></li></ul>

      <a href="http://planet.ocaml.org/rss20.xml"><img src=".././img/rss20.png"/></a>
      <a href="http://planet.ocaml.org/opml.xml"><img src=".././img/opml.png"/></a>
    </div>
    <div class="planet"><a name="fe4a9758a84119967b2ef7808523bb20"></a><span class="rss-header"><span class="rss-title"><a href="http://erratique.ch/software"> Winter distribution</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Daniel Bünzli</span>, <span class="rss-date">05 Jan 2013</span></span><span class="rss-description">Release of Cmdliner 0.9.3, Uutf 0.9.2, Uunf 0.9.1 and Uucd 0.9.2. Consult the individual release notes for details.</span>
<a name="35bc65a5fb94a57f1ad507d1edd0f509"></a><span class="rss-header"><span class="rss-title"><a href="http://functional-orbitz.blogspot.com/2013/01/experiences-using-resultt-vs-exceptions.html"> Experiences using Result.t vs Exceptions in Ocaml</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author"><span id="ocaml_1">Orbitz &#9001;noreply<abbr title="(at) &rarr; @">(at)</abbr>blogger.com (orbitz)&#9002;</span><script type="text/javascript"><!--;
local = "noreply";
h = "blogger.com (orbitz)";
document.getElementById("ocaml_1").innerHTML = '<a href="mailto:' + local + '@' + h + "\" >Orbitz<\/a>";
//--></script></span>, <span class="rss-date">04 Jan 2013</span></span><span class="rss-description"><div id="post1"><p><i>Disclaimer: I have not compiled any of the example code in this post.  Mostly because they are snippets meant to illustrate a point rather than be complete on their own.  If they have any errors then apologies.</i></p> <p>Previously I gave an <a href="http://functional-orbitz.blogspot.se/2013/01/introduction-to-resultt-vs-exceptions.html">introduction to return values vs exceptions</a> in Ocaml.  But a lot of ideas in software engineering sound good, how does this particular one work out in real software? </p> <p>I have used this style in two projects.  The first is a project that was originally written using exceptions and I have converted most of it to using return values.  The second is one that was written from the start using return values.  They can be found <a href="http://code.google.com/p/para-mugsy/">here</a> and <a href="https://github.com/orbitz/opass">here</a>.  <i>I make no guarantees about the quality of the code, in fact I believe some of it to be junk.  These are just my subjective opinions in writing software with a particular attribute</i>. </p> <h1>The Good</h1><h3>Expected Result</h3><a onclick="switchContent('post1','post2')" class="btn" href="#35bc65a5fb94a57f1ad507d1edd0f509">Read more...</a></div><div id="post2" style="display: none"><p><i>Disclaimer: I have not compiled any of the example code in this post.  Mostly because they are snippets meant to illustrate a point rather than be complete on their own.  If they have any errors then apologies.</i></p> <p>Previously I gave an <a href="http://functional-orbitz.blogspot.se/2013/01/introduction-to-resultt-vs-exceptions.html">introduction to return values vs exceptions</a> in Ocaml.  But a lot of ideas in software engineering sound good, how does this particular one work out in real software? </p> <p>I have used this style in two projects.  The first is a project that was originally written using exceptions and I have converted most of it to using return values.  The second is one that was written from the start using return values.  They can be found <a href="http://code.google.com/p/para-mugsy/">here</a> and <a href="https://github.com/orbitz/opass">here</a>.  <i>I make no guarantees about the quality of the code, in fact I believe some of it to be junk.  These are just my subjective opinions in writing software with a particular attribute</i>. </p> <h1>The Good</h1><h3>Expected Result</h3><p>The whole system worked as expected.  I get compile-time errors for all failure cases I do not handle.  This has helped me catch some failure cases I had forgotten about previously, some of which would require an unlikely chain of events to hit, which would have made finding in a test harder, but obviously not impossible.  In particular, ParaMugsy is (although the current rewrite does not cover this yet) meant to run in a distributed environment, which increases the cost of errors.  Both in debugging and reproducing.  In the case of opass, writing the DB is important to get right. Missing handling a failure here can mean the users database of passwords can be lost, a tragic event. </p> <h3>Not Cumbersome</h3><p>In the Introduction I showed that for a simple program, return-values are no more cumbersome than exceptions.  In these larger projects the same holds. This shouldn't really be a surprise though, as the monadic operators actually simulate the exact flow of exception code.  But the 'not cumbersome' is half of a lie, which is explained more below. </p> <h3>Refactoring Easier</h3><p>Ocaml is a great language when it comes to refactoring.  Simply make the change you want and iterate on compiler errors.  This style has made it even easier for me.  I can add new failures to my functions and work through the compiler errors to make sure the change is handled in every location. </p> <h3>Works No Matter The Concurrent Framework</h3><p>The original implementation of ParaMugsy used Lwt.  In the rewrite I decided to use Core's Async library.  Both are monadic.  And both handle exceptions quite differently.  Porting functions over that did return-values was much easier because they didn't rely on the framework to handle and propagate failures.  Exceptions are tricky in a concurrent framework and concurrency is purely library based in Ocaml rather than being part of the language, which means libraries can choose incompatible ways to handle them.  Return-values give one less thing to worry about when porting code or trying to get code to work in multiple frameworks. </p> <h1>The Bad</h1><h3>Prototyping Easier With Exceptions</h3><p>The whole idea is to make it hard to miss an error case.  But that can be annoying when you just want to get something running.  Often times we write software in such a way that the success path is the first thing we write and we handle the errors after that.  I don't think there is necessarily a good reason for this other than it's much more satisfying to see the results of the hard work sooner rather than later.  In this case, my solution is to relax the ban on exceptions temporarily.  Any place that I will return an <code>Error</code> I instead write <code>failwith "not yet implemented"</code>.  That way there is an easily grepable string to ensure I have replaced all exceptions with <code>Error</code>'s when I am done.  This is an annoyance but thankfully with a fairly simple solution. </p> <h3>Cannot Express All Invariants In Type System</h3><p>Sometimes there are sections of code where I know something is true, but it is not expressible in the type system.  For example, perhaps I have a data structure that updates multiple pieces of information together.  I know when I access one piece of information it will be in the other place.  Or perhaps I have a pattern match that I need to handle due to exhaustiveness but I know that it cannot happen given some invariants I have established earlier.  In the case where I am looking up data that I know will exist, I will use a lookup function that can throw an exception if it is easiest.  In the case where I have a pattern match that I know will never happen, I use <code>assert</code>.  But note, these are cases where I have metaphysical certitude that such events will not happen.  Not cases where I'm just pretty sure they work. </p> <h3>Many Useful Libraries Throw Exceptions</h3><p>Obviously a lot of libraries throw exceptions.  Luckily the primary library I use is Jane St's Core Suite, where they share roughly the same aversion of exceptions.  Some functions still do throw exceptions though, most notably <code>In_channel.with_file</code> and <code>Out_channel.with_file</code>.  This can be solved by wrapping those functions in return-value ones.  The problem comes in: what happens when the function being wrapped is poorly documented or at some point can throw more exceptional cases than when it was originally wrapped.  One option is to always catch <code>_</code> and turn it into a fairly generic variant type.  Or maybe a function only has a few logical failure conditions so collapsing them to a few variant types makes sense.  I'm not aware of any really good solution here. </p> <h1>A Few Examples</h1><p>There are a few transformations that come up often when converting exception code to return-value code.  Here are some in detail. </p> <h3>Building Things</h3><p>It's common to want to do some work and then construct a value from it.  In exception-land that is as simple, just something like <code>Constructor (thing_that_may_throw_exception ())</code>.  This doesn't work with return-values.  Instead we have to do what we did in the Introduction post.  Here is an example: </p> <pre><code><b></b></code></pre><font color="#0000FF">let</font> f <font color="#990000">()</font> <font color="#990000">=</font><br/>  <b><font color="#0000FF">let</font></b> <b><font color="#000080">open</font></b> <b><font color="#000080">Result</font></b><font color="#990000">.</font><font color="#009900">Monad_infix</font> <b><font color="#0000FF">in</font></b><br/>  thing_that_may_fail <font color="#990000">()</font> <font color="#990000">&gt;&gt;=</font> <b><font color="#0000FF">fun</font></b> v <font color="#990000">-&gt;</font><br/>  <font color="#009900">Ok</font> <font color="#990000">(</font><font color="#009900">Constructor</font> v<font color="#990000">)</font><br/> <h3>Looping</h3><p>Some loops cannot be written in their most obvious style.  Consider an implementation of <code>map</code> that expects the function passed to it to use <code>Result.t</code> to signal failures.  The very naive implementation of <code>map</code> is: </p> <pre><code><b></b></code></pre><font color="#0000FF">let</font> map f <font color="#990000">=</font> <b><font color="#0000FF">function</font></b><br/>  <font color="#990000">|</font> <font color="#990000">[]</font>    <font color="#990000">-&gt;</font> <font color="#990000">[]</font><br/>  <font color="#990000">|</font> x<font color="#990000">::</font>xs <font color="#990000">-&gt;</font> <font color="#990000">(</font>f x<font color="#990000">)::(</font>map xs<font color="#990000">)</font><br/> <p>There are two ways to write this.  The first requires two passes over the elements.  The first pass applies the function and the second one checks which value each function returned or the first error that was hit. </p> <pre><code><b></b></code></pre><font color="#0000FF">let</font> map f l <font color="#990000">=</font><br/>  <b><font color="#000080">Result</font></b><font color="#990000">.</font>all <font color="#990000">(</font><b><font color="#000080">List</font></b><font color="#990000">.</font>map f l<font color="#990000">)</font><br/> <p><code>Result.all</code> has the type <code>('a, 'b) Core.Std.Result.t list -&gt; ('a list, 'b) Core.Std.Result.t</code></p> <p>The above is simple but could be inefficient. The entire map is preformed regardless of failure and then walked again.  If the function being applied is expensive this could be a problem.  The other solution is a pretty standard pattern in Ocaml of using an accumulator and reversing it on output.  The monadic operator could be replaced by a <code>match</code> in this example, I just prefer the operator. </p> <pre><code><b></b></code></pre><font color="#0000FF">let</font> map f l <font color="#990000">=</font><br/>  <b><font color="#0000FF">let</font></b> <b><font color="#0000FF">rec</font></b> map' f acc <font color="#990000">=</font> <b><font color="#0000FF">function</font></b><br/>    <font color="#990000">|</font> <font color="#990000">[]</font>    <font color="#990000">-&gt;</font> <font color="#009900">Ok</font> <font color="#990000">(</font><b><font color="#000080">List</font></b><font color="#990000">.</font>rev acc<font color="#990000">)</font><br/>    <font color="#990000">|</font> x<font color="#990000">::</font>xs <font color="#990000">-&gt;</font> <b><font color="#0000FF">begin</font></b><br/>      <b><font color="#0000FF">let</font></b> <b><font color="#000080">open</font></b> <b><font color="#000080">Result</font></b><font color="#990000">.</font><font color="#009900">Monad_infix</font> <b><font color="#0000FF">in</font></b><br/>      f x <font color="#990000">&gt;&gt;=</font> <b><font color="#0000FF">fun</font></b> v <font color="#990000">-&gt;</font><br/>      map' f <font color="#990000">(</font>v<font color="#990000">::</font>acc<font color="#990000">)</font> xs<br/>    <b><font color="#0000FF">end</font></b><br/>  <b><font color="#0000FF">in</font></b><br/>  map' f <font color="#990000">[]</font> l<br/> <p>I'm sure someone cleverer in Ocaml probably has a superior solution but this has worked well for me. </p> <h3>try/with</h3><p>A lot of exception code looks like the following. </p> <pre><code><b></b></code></pre><font color="#0000FF">let</font> <font color="#990000">()</font> <font color="#990000">=</font><br/>  <b><font color="#0000FF">try</font></b><br/>    thing1 <font color="#990000">();</font><br/>    thing2 <font color="#990000">();</font><br/>    thing3 <font color="#990000">()</font><br/>  <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#009900">Error1</font> <font color="#990000">-&gt;</font> handle_error1 <font color="#990000">()</font><br/>    <font color="#990000">|</font> <font color="#009900">Error2</font> <font color="#990000">-&gt;</font> handle_error2 <font color="#990000">()</font><br/>    <font color="#990000">|</font> <font color="#009900">Error3</font> <font color="#990000">-&gt;</font> handle_error3 <font color="#990000">()</font><br/> <p>The scheme I use would break this into two functions.  The one inside the try and the one handling its result.  This might sound heavy but the syntax to define a new function in Ocaml is very light.  In my experience this hasn't been a problem. </p> <pre><code><b></b></code></pre><font color="#0000FF">let</font> do_things <font color="#990000">()</font> <font color="#990000">=</font><br/>  <b><font color="#0000FF">let</font></b> <b><font color="#000080">open</font></b> <b><font color="#000080">Result</font></b><font color="#990000">.</font><font color="#009900">Monad_infix</font> <b><font color="#0000FF">in</font></b><br/>  thing1 <font color="#990000">()</font> <font color="#990000">&gt;&gt;=</font> <b><font color="#0000FF">fun</font></b> <font color="#990000">()</font> <font color="#990000">-&gt;</font><br/>  thing2 <font color="#990000">()</font> <font color="#990000">&gt;&gt;=</font> <b><font color="#0000FF">fun</font></b> <font color="#990000">()</font> <font color="#990000">-&gt;</font><br/>  thing3<br/><br/><b><font color="#0000FF">let</font></b> <font color="#990000">()</font> <font color="#990000">=</font><br/>  <b><font color="#0000FF">match</font></b> do_things <font color="#990000">()</font> <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#009900">Ok</font> _ <font color="#990000">-&gt;</font> <font color="#990000">()</font><br/>    <font color="#990000">|</font> <font color="#009900">Error</font> <font color="#009900">Error1</font> <font color="#990000">-&gt;</font> handle_error1 <font color="#990000">()</font><br/>    <font color="#990000">|</font> <font color="#009900">Error</font> <font color="#009900">Error2</font> <font color="#990000">-&gt;</font> handle_error2 <font color="#990000">()</font><br/>    <font color="#990000">|</font> <font color="#009900">Error</font> <font color="#009900">Error3</font> <font color="#990000">-&gt;</font> handle_error3 <font color="#990000">()</font><br/> <h1>Conclusion</h1><p>Using return-values instead of exceptions in my Ocaml projects has had nearly the exact output I anticipated.  I have compile-time guarantees for handling failure cases and the cost to my code has been minimal.  Any difficulties I've run into have had straight forward solutions.  In some cases it's simply a matter of thinking about the problems from a new perspective and the solution is clear.  I plan on continuing to develop code with these principles and creating larger projects.  I believe that this style scales well in larger projects and actually becomes less cumbersome as the project increases since the guarantees can help make it easier to reason about the project. </p><a onclick="switchContent('post2','post1')" class="btn" href="#35bc65a5fb94a57f1ad507d1edd0f509">Hide</a></div></span>
<a name="bc1b8a06674f25766c2ef19b23b7d866"></a><span class="rss-header"><span class="rss-title"><a href="http://functional-orbitz.blogspot.com/2013/01/introduction-to-resultt-vs-exceptions.html"> Introduction to Result.t vs Exceptions in Ocaml</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author"><span id="ocaml_2">Orbitz &#9001;noreply<abbr title="(at) &rarr; @">(at)</abbr>blogger.com (orbitz)&#9002;</span><script type="text/javascript"><!--;
local = "noreply";
h = "blogger.com (orbitz)";
document.getElementById("ocaml_2").innerHTML = '<a href="mailto:' + local + '@' + h + "\" >Orbitz<\/a>";
//--></script></span>, <span class="rss-date">03 Jan 2013</span></span><span class="rss-description"><div id="post3"><p><i>This post uses Jane St's Core suite.  Specifically the <code>Result</code> module.  It assumes some basic knowledge of Ocaml.  Please check out <a href="http://ocaml.org">Ocaml.org</a> for more Ocaml reading material.</i></p> <p>There are several articles and blog posts out there arguing for or against return values over exceptions.  I'll add to the discussion with my reasons for using return values in the place of exceptions in Ocaml. </p> <h3>What's the difference?</h3><a onclick="switchContent('post3','post4')" class="btn" href="#bc1b8a06674f25766c2ef19b23b7d866">Read more...</a></div><div id="post4" style="display: none"><p><i>This post uses Jane St's Core suite.  Specifically the <code>Result</code> module.  It assumes some basic knowledge of Ocaml.  Please check out <a href="http://ocaml.org">Ocaml.org</a> for more Ocaml reading material.</i></p> <p>There are several articles and blog posts out there arguing for or against return values over exceptions.  I'll add to the discussion with my reasons for using return values in the place of exceptions in Ocaml. </p> <h3>What's the difference?</h3><p>Why does the debate even exist?  Because each side has decent arguments for why their preference is superior when it comes to writing reliable software.  Pro-return-value developers, for example, argue that their code is easier identify if the code is wrong simply by reading it (if it isn't handling a return value of a function, it's wrong), while exception based code requires understanding all of the functions called to determine if and how they will fail.  Pro-exception developers argue that it is much harder to get their program into an undefined state because an exception has to be handled or else the program fails, where in return based code one can simply forget to check a function's return value and the program continues on in an undefined state.  </p> <p>I believe that Ocaml has several features that make return values the preferable way to handle errors.  Specifically variants, polymorphic variants, exhaustive pattern matching, and a powerful static type system make return values attractive. </p> <p>This debate is only worth your time if you are really passionate about writing software that has fairly strong guarantees about its quality in the face of errors.  For a majority of software, it doesn't matter which paradigm you choose.  Most errors will be stumbled upon during debugging and fairly soon after going into production or through writing unit and integration tests.  But, tests cannot catch everything.  And in distributed and concurrent code rare errors can now become common errors and it can be near impossible to reconstruct the conditions that caused it.  But in some cases it is possible to make whole classes of errors either impossible or catchable at compile-time with some discipline.  Ocaml is at least one language that makes this possible. </p> <h3>Checked exceptions</h3><p>A quick aside on checked exceptions, as in Java.  Checked exceptions provide some of the functionality I claim is valuable, the main problem with how checked exceptions are implemented in Java (the only language I have any experience in that uses them), is they have a very heavy syntax, to the point where using them can seem too burdensome. </p> <h3>The Claim</h3><p>The claim is that if one cares about ensuring they are handling all failure cases in their software, return-values are superior to exceptions because, with the help of a good type system, their handling can be validated at compile-time.  Ocaml provides a fairly light, non intrusive, syntax to make this feasible. </p> <h3>Good Returns</h3><p>The goal of a good return value based error handling system is to make sure that all errors are handled at compile-time.  This is because there is no way to enforce this at run-time, as an exception does.  This is a good reason to prefer exceptions in a dynamically typed language like Python or Ruby, your static analyzers are few and far between. </p> <p>In C this is generally accomplished by using a linting tool that will report an error if a function's return value is ignored in a call.  This is why you might see <code>printf</code> casted to <code>void</code> in some code, to make it clear the return value is meant to be ignored.  But a problem with this solution is that it only enforces that the developer handles the return value, not all possible errors.  For example, POSIX functions return a value saying the function failed and put the actual failure in <code>errno</code>.  How, then, to enforce that all of the possible failures are handled?  Without encoding all of that information in a linting tool, the options in C (and most languages) are pretty weak. Linting tools are also separate from the compiler and vary in quality.  Writing code that takes proper advantage of a linting tool, in C, is a skill all of its own as well. </p> <h3>Better Returns</h3><p>Ocaml supports exceptions but the compiler provides no guarantees that the exceptions are actually handled anywhere in the code.  So what happens if the documentation of a function is incomplete or a dependent function is changed to add a new exception being thrown?  The compiler won't help you. </p> <p>But Ocaml's rich type system, combined with some discipline, gives you more power than a C linter.  The primary strength is that Ocaml lets you encode information in your types.  For example, in POSIX many functions return an integer to indicate error.  But an <code>int</code> has no interesting meaning to the compiler other than it holds values between <code>INT_MIN</code> and <code>INT_MAX</code>.  In Ocaml, we can instead create a type to represent the errors a function can return and the compiler can enforce that all possible errors are handled in some way thanks to exhaustive pattern matching. </p> <h3>An Example</h3><p>What does all of this look like?  Below a contrived example. The goal is to provide a function, called <code>parse_person</code> that takes a string and turns it into a <code>person</code> record.  The requirements of the code is that if a valid person cannot be parsed out, the part of the string that failed is specified in the error message. </p> <p>Here is a version using exceptions, <a href="https://github.com/orbitz/blog_post_src/blob/master/intro_return_t/ex1.ml">ex1.ml</a>: </p>  <pre><code><b></b></code></pre><font color="#000080">open</font> <b><font color="#000080">Core</font></b><font color="#990000">.</font><font color="#009900">Std</font><br/><br/><b><font color="#0000FF">exception</font></b> <font color="#009900">Int_of_string</font> <b><font color="#0000FF">of</font></b> <font color="#009900">string</font><br/><br/><b><font color="#0000FF">exception</font></b> <font color="#009900">Bad_line</font> <b><font color="#0000FF">of</font></b> <font color="#009900">string</font><br/><b><font color="#0000FF">exception</font></b> <font color="#009900">Bad_name</font> <b><font color="#0000FF">of</font></b> <font color="#009900">string</font><br/><b><font color="#0000FF">exception</font></b> <font color="#009900">Bad_age</font> <b><font color="#0000FF">of</font></b> <font color="#009900">string</font><br/><b><font color="#0000FF">exception</font></b> <font color="#009900">Bad_zip</font> <b><font color="#0000FF">of</font></b> <font color="#009900">string</font><br/><br/><b><font color="#0000FF">type</font></b> person <font color="#990000">=</font> <font color="#FF0000">{</font> name <font color="#990000">:</font> <font color="#990000">(</font><font color="#009900">string</font> <font color="#990000">*</font> <font color="#009900">string</font><font color="#990000">)</font><br/>              <font color="#990000">;</font> age  <font color="#990000">:</font> <b><font color="#000080">Int</font></b><font color="#990000">.</font>t<br/>              <font color="#990000">;</font> zip  <font color="#990000">:</font> <font color="#009900">string</font><br/>              <font color="#FF0000">}</font><br/><br/><i><font color="#9A1900">(* A little helper function *)</font></i><br/><b><font color="#0000FF">let</font></b> int_of_string s <font color="#990000">=</font><br/>  <b><font color="#0000FF">try</font></b><br/>    <b><font color="#000080">Int</font></b><font color="#990000">.</font>of_string s<br/>  <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#009900">Failure</font> _ <font color="#990000">-&gt;</font><br/>      raise <font color="#990000">(</font><font color="#009900">Int_of_string</font> s<font color="#990000">)</font><br/><br/><b><font color="#0000FF">let</font></b> parse_name name <font color="#990000">=</font><br/>  <b><font color="#0000FF">match</font></b> <b><font color="#000080">String</font></b><font color="#990000">.</font>lsplit2 <font color="#990000">~</font>on<font color="#990000">:</font>' ' name <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#009900">Some</font> <font color="#990000">(</font>first_name<font color="#990000">,</font> last_name<font color="#990000">)</font> <font color="#990000">-&gt;</font><br/>      <font color="#990000">(</font>first_name<font color="#990000">,</font> last_name<font color="#990000">)</font><br/>    <font color="#990000">|</font> <font color="#009900">None</font> <font color="#990000">-&gt;</font><br/>      raise <font color="#990000">(</font><font color="#009900">Bad_name</font> name<font color="#990000">)</font><br/><br/><b><font color="#0000FF">let</font></b> parse_age age <font color="#990000">=</font><br/>  <b><font color="#0000FF">try</font></b><br/>    int_of_string age<br/>  <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#009900">Int_of_string</font> _ <font color="#990000">-&gt;</font><br/>      raise <font color="#990000">(</font><font color="#009900">Bad_age</font> age<font color="#990000">)</font><br/><br/><b><font color="#0000FF">let</font></b> parse_zip zip <font color="#990000">=</font><br/>  <b><font color="#0000FF">try</font></b><br/>    ignore <font color="#990000">(</font>int_of_string zip<font color="#990000">);</font><br/>    <b><font color="#0000FF">if</font></b> <b><font color="#000080">String</font></b><font color="#990000">.</font>length zip <font color="#990000">=</font> <font color="#993399">5</font> <b><font color="#0000FF">then</font></b><br/>      zip<br/>    <b><font color="#0000FF">else</font></b><br/>      raise <font color="#990000">(</font><font color="#009900">Bad_zip</font> zip<font color="#990000">)</font><br/>  <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#009900">Int_of_string</font> _ <font color="#990000">-&gt;</font><br/>      raise <font color="#990000">(</font><font color="#009900">Bad_zip</font> zip<font color="#990000">)</font><br/><br/><b><font color="#0000FF">let</font></b> parse_person s <font color="#990000">=</font><br/>  <b><font color="#0000FF">match</font></b> <b><font color="#000080">String</font></b><font color="#990000">.</font>split <font color="#990000">~</font>on<font color="#990000">:</font>'<font color="#990000">\</font>t' s <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#990000">[</font>name<font color="#990000">;</font> age<font color="#990000">;</font> zip<font color="#990000">]</font> <font color="#990000">-&gt;</font><br/>      <font color="#FF0000">{</font> name <font color="#990000">=</font> parse_name name<br/>      <font color="#990000">;</font> age  <font color="#990000">=</font> parse_age age<br/>      <font color="#990000">;</font> zip  <font color="#990000">=</font> parse_zip zip<br/>      <font color="#FF0000">}</font><br/>    <font color="#990000">|</font> _ <font color="#990000">-&gt;</font><br/>      raise <font color="#990000">(</font><font color="#009900">Bad_line</font> s<font color="#990000">)</font><br/><br/><b><font color="#0000FF">let</font></b> <font color="#990000">()</font> <font color="#990000">=</font><br/>  <i><font color="#9A1900">(* Pretend input came from user *)</font></i><br/>  <b><font color="#0000FF">let</font></b> input <font color="#990000">=</font> <font color="#FF0000">"Joe Mama\t25\t11425"</font> <b><font color="#0000FF">in</font></b><br/>  <b><font color="#0000FF">try</font></b><br/>    <b><font color="#0000FF">let</font></b> person <font color="#990000">=</font> parse_person input <b><font color="#0000FF">in</font></b><br/>    printf <font color="#FF0000">"Name: %s %s\nAge: %d\nZip: %s\n"</font><br/>      <font color="#990000">(</font>fst person<font color="#990000">.</font>name<font color="#990000">)</font><br/>      <font color="#990000">(</font>snd person<font color="#990000">.</font>name<font color="#990000">)</font><br/>      person<font color="#990000">.</font>age<br/>      person<font color="#990000">.</font>zip<br/>  <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#009900">Bad_line</font> l <font color="#990000">-&gt;</font><br/>      printf <font color="#FF0000">"Bad line: '%s'\n"</font> l<br/>    <font color="#990000">|</font> <font color="#009900">Bad_name</font> name <font color="#990000">-&gt;</font><br/>      printf <font color="#FF0000">"Bad name: '%s'\n"</font> name<br/>    <font color="#990000">|</font> <font color="#009900">Bad_age</font> age <font color="#990000">-&gt;</font><br/>      printf <font color="#FF0000">"Bad age: '%s'\n"</font> age<br/>    <font color="#990000">|</font> <font color="#009900">Bad_zip</font> zip <font color="#990000">-&gt;</font><br/>      printf <font color="#FF0000">"Bad zip: '%s'\n"</font> zip<br/> <p><a href="https://github.com/orbitz/blog_post_src/blob/master/intro_return_t/ex2.ml">ex2.ml</a> is a basic translation of the above but using variants.  The benefit is that the type system will ensure that all failure case are handled.  The problem is the code is painful to read and modify.  Every function that can fail has its own variant type to represent success and error.  Composing the functions is painful since every thing returns a different type.  We have to create a type that can represent all of the failures the other functions returned.  It would be nice if each function could return an error and we could use that value instead.  It would also be nice if everything read as a series of steps, rather than pattern matching on a tuple which makes it hard to read. </p> <p><a href="https://github.com/orbitz/blog_post_src/blob/master/intro_return_t/ex3.ml">ex3.ml</a> introduces Core's <code>Result.t</code> type.  The useful addition is that we only need to define a type for <code>parse_person</code>.  Every other function only has one error condition so we can just encode the error in the <code>Error</code> variant.  This is still hard to read, though.  The helper functions aren't so bad but the main function is still painful. </p> <p>While the previous solutions have solved the problem of ensuring that all errors are handled, they introduced the problem of being painful to develop with.  The main problem is that nothing composes.  The helpers have their own error types and for every call to them we have to check their return and then encompass their error in any function above it.  What would be nice is if the compiler could automatically union all of the error codes we want to return from itself and any function it called.  Enter polymorphic variants. </p> <p><a href="https://github.com/orbitz/blog_post_src/blob/master/intro_return_t/ex4.ml">ex4.ml</a> Shows the version with polymorphic variants.  The nice bit of refactoring we were able to do is in <code>parse_person</code>.  Rather than an ugly match, the calls to the helper functions can be sequenced: </p> <pre><code><b></b></code></pre><font color="#0000FF">let</font> parse_person s <font color="#990000">=</font><br/>  <b><font color="#0000FF">match</font></b> <b><font color="#000080">String</font></b><font color="#990000">.</font>split <font color="#990000">~</font>on<font color="#990000">:</font>'<font color="#990000">\</font>t' s <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#990000">[</font>name<font color="#990000">;</font> age<font color="#990000">;</font> zip<font color="#990000">]</font> <font color="#990000">-&gt;</font><br/>      <b><font color="#0000FF">let</font></b> <b><font color="#000080">open</font></b> <b><font color="#000080">Result</font></b><font color="#990000">.</font><font color="#009900">Monad_infix</font> <b><font color="#0000FF">in</font></b><br/>      parse_name name <font color="#990000">&gt;&gt;=</font> <b><font color="#0000FF">fun</font></b> name <font color="#990000">-&gt;</font><br/>      parse_age  age  <font color="#990000">&gt;&gt;=</font> <b><font color="#0000FF">fun</font></b> age  <font color="#990000">-&gt;</font><br/>      parse_zip  zip  <font color="#990000">&gt;&gt;=</font> <b><font color="#0000FF">fun</font></b> zip  <font color="#990000">-&gt;</font><br/>      <font color="#009900">Ok</font> <font color="#FF0000">{</font> name<font color="#990000">;</font> age<font color="#990000">;</font> zip <font color="#FF0000">}</font><br/>    <font color="#990000">|</font> _ <font color="#990000">-&gt;</font><br/>      <font color="#009900">Error</font> <font color="#990000">(</font>`<font color="#009900">Bad_line</font> s<font color="#990000">)</font><br/> <p>Don't worry about the monad syntax, it's really just to avoid the nesting to make the sequencing easier on the eyes.  Except for the <code>&gt;&gt;=</code>, this looks a lot like code using exceptions.  There is a nice linear flow and only the success path is shown.  But! The compiler will ensure that all failures are handled. </p> <p>The final version of the code is <a href="https://github.com/orbitz/blog_post_src/blob/master/intro_return_t/ex5.ml">ex5.ml</a>.  This takes ex4 and rewrites portions of it to be prettier.  As a disclaimer, I'm sure someone else would consider writing this differently even with the same restrictions I put on it, I might even write it different on a different day, but this version of the code demonstrates the points I am making. </p> <p>A few points of comparison between ex1 and ex5: </p> <p></p><ul><li>The body of <code>parse_person</code> is definitely simpler and easier to read in the exception code.  It is short and concise.</li><li>The rest of the helper functions are a bit of a toss-up between the exception and return-value code.  I think one could argue either direction.</li><li>The return-value code has fulfilled my requirements in terms of handling failures.  The compiler will complain if any failure <code>parse_person</code> could return is not handled.  If I add another error type the code will not compile.  It also fulfilled the requirements without bloating the code.  The return-value code and exception code are roughly the same number of lines.  Their flows are roughly equal.  But the return-value code is much safer.</li></ul><p></p> <h3>Two Points</h3><p>It's not all sunshine and lollipops.  There are two issues to consider: </p> <p></p><ul><li><b>Performance</b> - Exceptions in Ocaml are really, really, fast.  Like any performance issue, I suggest altering code only when needed based on measurements and encapsulating those changes as well as possible.  This also means if you want to provide a safe and an exception version of a function, you should probably implement the safe version in terms of the exception verson.</li><li><b>Discipline</b> - I referred to discipline a few times above.  This whole scheme is very easy to mess up with a single mistake: pattern matching on anything (<code>_</code>).  The power of exhaustive pattern matching means you need to match on every error individually.  This is effectively for the same reason catching the exception base class in other languages is such a bad idea, you lose a lot of information.</li></ul><p></p>  <h3>Conclusion</h3><p>The example given demonstrates an important point: code can become much safer at compile time without detriment to its length or readability.  The cost is low and the benefit is high.  This is a strong reason to prefer a return-value based solution over exceptions in Ocaml. </p><a onclick="switchContent('post4','post3')" class="btn" href="#bc1b8a06674f25766c2ef19b23b7d866">Hide</a></div></span>
<a name="de8a5b43b4b100ac2ecc59bc44a7b76e"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2013.01.01.html"> Caml Weekly News, 01 Jan 2013</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">01 Jan 2013</span></span><span class="rss-description">C interop: Return values in parameters / Other Caml News</span>
<a name="4253f74339fd819282cbe40f9ebd13b2"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/~scherer/gagallium/singleton-types-for-code-inference-2"> Singleton types for code inference, continued</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">30 Dec 2012</span></span><span class="rss-description"><div id="post5"><p>In this post you can find out what was cut from the <a href="http://gallium.inria.fr/~scherer/gagallium/site-url/&amp;gt;singleton-types-for-code-inference">previous post on
singleton
types</a>. These are
more technical considerations that may require some familiarity with
type theory. In particular, I'll discuss linear and dependent types in
the context of describing more and more singletons.</p>




<p>In <a href="http://gallium.inria.fr/~scherer/gagallium/site-url/&amp;gt;singleton-types-for-code-inference">the previous
post</a>,
I discussed a code inference construction <code>(Γ |- ? : σ)</code> that would be
replaced, after type-checking, by the unique term <code>t</code> of type <code>σ</code>
(modulo program equivalence) in the environment Γ, or fail if no term
or several distinct terms exist at type σ.</p>

<h2>More singletons</h2>

<a onclick="switchContent('post5','post6')" class="btn" href="#4253f74339fd819282cbe40f9ebd13b2">Read more...</a></div><div id="post6" style="display: none"><p>In this post you can find out what was cut from the <a href="http://gallium.inria.fr/~scherer/gagallium/site-url/&amp;gt;singleton-types-for-code-inference">previous post on
singleton
types</a>. These are
more technical considerations that may require some familiarity with
type theory. In particular, I'll discuss linear and dependent types in
the context of describing more and more singletons.</p>




<p>In <a href="http://gallium.inria.fr/~scherer/gagallium/site-url/&amp;gt;singleton-types-for-code-inference">the previous
post</a>,
I discussed a code inference construction <code>(Γ |- ? : σ)</code> that would be
replaced, after type-checking, by the unique term <code>t</code> of type <code>σ</code>
(modulo program equivalence) in the environment Γ, or fail if no term
or several distinct terms exist at type σ.</p>

<h2>More singletons</h2>

<p>I have argued that the terms we will look for should live in
a different term language than the host language in which we would
consider using code-inference, to restrict ourselves to well-behaved,
pure terms. Any term language is fine as long as it can be embedded
into the host language, and can reasonably be shown to the user: you
may want to keep the <code>?</code> in the source code, but also sometimes show
the inferred term to the user, to help program understanding, or
because finding the term was the point as in my example of "I forgot
the argument order".</p>

<p>Another point of variability in the type system: we can in fact pick
any type system we want: in the most explicit form where the user
would write <code>(Γ |- ? : σ)</code> in the source, the type <code>σ</code> could live in
the type system for code inference, and not be a type expressions in
the host language. We only need to be able to translate the inferred
<em>terms</em> back into the host term language (and then we can verify
that they are type-correct if we don't trust the term
inference engine).</p>

<p>The embedding of the host type system to the type system for code
inference could be partial: maybe we won't be able to handle some of
the types inferred by the host system when using the simple <code>?</code>
construction, and those cases would fail with an error. The more
interesting aspect is that we can also have <em>finer types</em> in the
type system for code inference. For example, we can have linear
types.</p>

<p>For example, <code>∀α. (α → α → α) → α → α</code> is not a singleton type: it is
inhabited by <code>fun f x -&gt; x</code>, but also <code>fun f x -&gt; f x x</code>, <code>fun f x -&gt;
f x (f x x)</code>, etc. However, <code>∀α. (α → α → α) → α ⊸ α</code>, where the last
arrow is the linear arrow <code>⊸</code> (<code>-o</code> in glorious ASCII) which means "use
my argument exactly once", is a singleton type.</p>

<p>This suggests some experiment with finer type systems. For example,
<code>(β→γ) → (α*β*α) → (α*γ*α)</code> is not a singleton type:
the first and third components of the input tuple, of the same
type α, could be swapped in the output. But there are some type
systems (some of which my coworker Julien is working on) that are
somehow stricter than linear type systems in that they request not
only each input to be consumed exactly once, but its structure to be
preserved (no swapping of pair elements, etc.). Consider for example
a language of subtyping coercions: if you have a coercion of type
<code>β ≤ γ</code> in context, then there is only one coercion of type
<code>(α * β * α) ≤ (α * γ * α)</code>, and if seen as a function it does not
swap the tuple components.</p>

<p>We can observe the difference between the usual arrow <code>→</code>, the
linear arrow <code>⊸</code> and a notion of structure-preserving arrow
sketched above, that I would write <code>⇒</code>, on the type of <code>List.map</code>:</p>

<ul>
<li><p><code>∀αβ. (α → β) → (List α → List β)</code> is inhabited by any function
that applies its function argument to the elements of its list
argument, but may drop or reorder some of them. For example,
always returning the empty list is ok.</p></li>
<li><p>the inhabitants <code>∀αβ. (α ⊸ β) → (List α ⊸ List β)</code> are not
allowed to drop elements from the input list anymore, but may
still reorder them. <code>[x1,x2] ↦ [f x2, f x1]</code> is ok</p></li>
<li><p>the inhabitants of <code>∀αβ. (α ⇒ β) → (List α ⇒ List β)</code> must
preserve the structure of the input list, neither reordering nor
dropping elements; it is a singleton type. I think of it as the
coercion <code>(α ≤ β) |- List α ≤ List β</code> turned into a term.</p></li>
</ul>

<p>(You may be unsure what the <code>→</code> arrow between the function argument
and rest means in the two latter example. I am as well.)</p>

<h2>Towards dependent types</h2>

<p>Of course, another obvious direction to refine the type system is to
introduce dependent types (and refinement types, etc.). Consider the
type of List.fold_right: <code>∀αβ. (α → β → β) → (List α → β → β)</code>: in
this case, using linear or structure-preserving arrows does not get
us a singleton type, because there is no structure in the return
type <code>β</code> to be preserved. However, a dependent type for <code>fold_right</code>
on lists (with arguments reordered for readability) is a singleton:</p>

<pre><code>∀α ∀(P : List α → ★).
  P nil →
  (∀(x : α) (xs : List α). P xs → P (cons x xs)) → 
  ∀(li : List α). P li
</code></pre>

<p>Of course, you may notice that writing this type is in no way easier
than writing the corresponding term:</p>

<pre><code>let rec fold init f = function
  | nil -&gt; init
  | cons x xs -&gt; f x xs (fold init xs)
</code></pre>

<p>If you move to sophisticated enough type systems, the idea that
"types help you infer code" becomes a bit of cheating as writing the
types themselves is just as much work as writing the terms. The idea of
using singleton types for code inference is not a magic wand that
will have you suddenly write order of magnitudes less <em>stuff</em>,
rather one principled way to move between term implementation and
type specification, type and code inference, and to study the
practical aspects under different points of view. The study of
singleton types in sufficiently sophisticated type systems may turn
out to be of theoretical rather than practical interest, but it's
enough for me, because it looks <em>fun</em>.</p>

<h3>Singleton types?</h3>

<p>The concept of singleton types already exists in the literature in
a quite different form: for any term <code>M</code>, we can consider the type
<code>(= M)</code> which classifies the set of programs... equal to <code>M</code>. This has
been found quite useful by the people working on module systems to
capture just the level of dependent types needed to express public
type declarations in a module signature (they're used one level up:
singleton <em>kinds</em> that publish equalities with a <em>type</em>; but the
term/type level is more convenient for explanations).</p>

<p>Of course, the type <code>(= M)</code> is clearly a singleton type, and if you
determine that a type σ has a unique inhabitant <code>t</code>, this should be
equivalent to saying that you've discovered an equality between <code>σ</code>
and the singleton type <code>(= t)</code>. For example, if <code>∀αβ.(α*β)→(β*α)</code> is
"a singleton type" then it is the same type as
<code>(= λ(x,y).(y,x))</code>. This means that you could do everything of
interest by adding this notion of singleton types <code>(= M)</code> in your
language, and proving type equalities between regular types and this
explicit form of singletons.</p>

<p>However that only works if the <em>host</em> language and the <em>search</em>
language are the same. If I use singleton types to infer code in OCaml
or Haskell, I'll want to infer stuff from <code>∀αβ.(α*β)→(β*α)</code> while this
type is not equal to <code>(= λ(x,y).(y,x))</code> in the host language. I'd
rather keep the two different notions of singleton types separate, to
emphasize that my focus here is on code inference, not equality
reasoning (which, again, may not hold in the host language).</p>

<h2>Singleton types as "proof search"</h2>

<p>There is a nice interplay with Curry-Howard (already explicitly
employed in the previous works of Wells and Yakobowski): if we see
terms as proofs, we are interested in properties that have a <em>unique</em>
proof. I am not aware of logicians having worked on this question
(probably ignorance on my side), but to be fair mathematicians tend to
be interested in <em>existence</em> of proofs (the question of
type inhabitation) more than unicity. A good thing however is that
a large part of the literature on proof search is concerned with
finding <em>canonical</em> proofs, to avoid "redundancy" between proof
terms. Proof nets, uniform proofs, focusing are all somehow concerned
about this aspect (because proving meta-theorems about your proof
system is easier when proof objects are strongly structured). And it
turns out that the work to have more "canonical" proofs consists
exactly in finding representations where less different proofs are
equivalent as programs. This is an excellent excuse to learn more
about the proof search literature, to see if we can find ideas inside
that are helpful to determine singleton types.</p>

<p>As a form of proof search, there is also a clear relation with
<em>tactics</em> (or maybe even more with this fascinating Emacs gadget
that Agda users have, that allows them to interactively refine proof
goals with "obvious" steps according to the shape of the goal). <code>?</code>
is a specific kind of tactics that is interested not only in finding
some proof term, but in the details of its dynamic semantics. Are
there other "tactics" that are also useful for programming rather
than proving?</p>

<h2>A closing remark and a quote</h2>

<p>Some readers will have recognized some example of types I gave here as
examples of reasoning on parametricity. The fact that <code>∀α.α→α</code> is only
inhabited by the identity function is, for example, often argued by
invoking the kind of results of "Theorems for free!". But a simple
algorithm to find singletons will simply prove that there is only one
correct βη-normal form of this type: first you have to use a Λαλ(x:α)
by η-expanding, and then you have nothing to use as a function body in
your context other than (x:α).</p>

<p>I'll remark that the link between parametricity and singleton types is
maybe weaker than it could seem, as a practical algorithm to determine
that types are singleton will rather work by trying to exhaust the
search space for terms, than reasoning on semantic relations derived
from the type -- but who knows. Let's say, at least, that I understand
term search better than I understand parametricity, a topic on which
I suspect we have still a lot to find out.</p>

<p>Let me conclude with
a nice 2011 quote from Conor McBride <a href="http://www.quora.com/Why-do-programming-languages-use-type-systems">on
Quora</a>
(no idea why he put it there). </p>

<blockquote>
  <p>Whilst I don't want to gainsay the importance of types as a source
of corrective raspberry-blowing, I would like to offer the prospect
that types might have an active role to play, structuring the
process of program inference. Overloading allows you to get rid of
boring lumps of code if it can be figured out from
types. Datatype-generic programming uses representations of the
structure of types to calculate specific instances of
algorithm-schemes. Dependent type systems often allow
run-time-relevant values to be inferred silently from type
information.</p>

<p>Crucially, also, types structure the search for programs in useful
ways, provided your editing environment offers you type information
and makes it easy to select type-appropriate choices. Sometimes it's
easier to search for good programs in the space of well typed
programs, rather than in the space of ascii turds.</p>

<p>This position constitutes a change of viewpoint in the purpose of
types. If programs worked just the same with the types rubbed out,
then types would represent a form of piety often inadequate with
respect to testing. It's when types contribute information to
algorithm selection, design statements which program definitions
need merely refine, that they constitute a significant win.</p>

<p>To be fair, even in last century's typed languages, types had
a beneficial organisational effect on programmers. This century,
it's just possible types will have a comparable effect on
programs. Types are concepts and now mechanisms supporting
program-discovery as well as error-discovery. I think that's more
than just gravy.</p>
</blockquote><a onclick="switchContent('post6','post5')" class="btn" href="#4253f74339fd819282cbe40f9ebd13b2">Hide</a></div></span>
<a name="c2fcb8b4aa00ad4abb174274b6a1d45f"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/~scherer/gagallium/singleton-types-for-code-inference"> Singleton types for code inference</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">29 Dec 2012</span></span><span class="rss-description"><div id="post7"><p>Could the compiler <em>guess</em> a part of the program I am
currently writing? It's impossible in general, but it may be possible,
and hopefully interesting, in special cases. For a start, I am
interested in a situation where there is <em>only one possibility</em>: at
the expected type, there is only one possible program -- modulo
(an approximation of) program equivalence.</p>

<p>In a fixed environment, a type is a <em>singleton type</em> if it has only
one inhabitant. How widespread are those? Would a language feature to
infer their inhabitants be useful? Can we have more interesting
singleton types by enriching the type system?</p>

<p>Don't expect a structured story with a happy ending: this is only
a writing-ideas-down session for something I have been thinking about
lately.</p>




<p>PS: See <a href="http://gallium.inria.fr/~scherer/gagallium/site-url/&amp;gt;singleton-types-for-code-inference-2">the next
post</a> for more
details on the idea.</p>

<h2>From erasable coercions to singleton types</h2>

<a onclick="switchContent('post7','post8')" class="btn" href="#c2fcb8b4aa00ad4abb174274b6a1d45f">Read more...</a></div><div id="post8" style="display: none"><p>Could the compiler <em>guess</em> a part of the program I am
currently writing? It's impossible in general, but it may be possible,
and hopefully interesting, in special cases. For a start, I am
interested in a situation where there is <em>only one possibility</em>: at
the expected type, there is only one possible program -- modulo
(an approximation of) program equivalence.</p>

<p>In a fixed environment, a type is a <em>singleton type</em> if it has only
one inhabitant. How widespread are those? Would a language feature to
infer their inhabitants be useful? Can we have more interesting
singleton types by enriching the type system?</p>

<p>Don't expect a structured story with a happy ending: this is only
a writing-ideas-down session for something I have been thinking about
lately.</p>




<p>PS: See <a href="http://gallium.inria.fr/~scherer/gagallium/site-url/&amp;gt;singleton-types-for-code-inference-2">the next
post</a> for more
details on the idea.</p>

<h2>From erasable coercions to singleton types</h2>

<p>I started to think about this kind of singleton types seriously when
discussing with one of our fellow students at Gallium, <a href="http://gallium.inria.fr/~jcretin/">Julien
Cretin</a>. Julien has been working on
coercions for long enough that, if you listen to him, basically
anything in a type system is a coercion in disguise. But for the most
part he has worked on <em>erasable coercions</em>, that are terms from a type
<code>A</code> to a type <code>B</code> that are just the identity function (once you erase
the type annotations that make them useful).</p>

<p>One example in System F is the coercion</p>

<pre><code>λ(f:A→∀α.B). Λα.λ(x:A). f x α
</code></pre>

<p>from <code>A→∀α.B</code> to <code>∀α.(A→B)</code>. Note that if you erase all the type
annotations (including type abstractions and applications), this
becomes just <code>λfλx. f x</code>, which is an η-expansion of the identity
function. Those identities are "erasable" in the sense that, after the
type-checking phase, you can just drop them from your program and you
will never notice: they do not affect the runtime semantics of the
program.</p>

<p>Erasable coercions are fairly interesting as a way to structure and
explain type systems. For example, they allow to understand various
variants of System F (System Fη, Fsub, and MLF) as instances of
a general version of System F enhanced with abstraction on coercions,
whose formal study is surprisingly challenging. You can learn about
this in <a href="http://gallium.inria.fr/~remy/coercions/Cretin-Remy:coercions@popl2012.pdf">Julien's 2012 paper with Didier
Rémy</a>
(<a href="http://hal.inria.fr/docs/00/60/85/66/PDF/full.pdf">long version</a>).</p>

<p>But what would be a notion of <em>non-erasable</em> coercion? My suggestion
was to consider terms that may not exactly be the identity, but that
are unique at their type. This is actually a fairly different concept:
some coercions (for example <code>int → int</code>) are not unique in their
types, and some unique inhabitants (for example in <code>∀αβ.(α*β)→(β*α)</code>)
have a runtime behavior that is fairly different from the identity.</p>

<h2>Singleton types in practice</h2>

<p>As a thought experiment, imagine adding the keyword <code>?</code> in the
syntactic class of expressions of your programming language. The
semantics of <code>?</code> is as follows: at typing time, it can take absolutely
any type and will never raise a type error. After the program has been
verified to be type-correct, we look at each occurrence of <code>?</code> and its
inferred type. If the type is a singleton (assume we know how to
check this), we replace <code>?</code> with the unique inhabitant, otherwise we
fail with an error.</p>

<p>That's an inference-centered point of view. In languages with less
robust type inference than ML languages, we could have a more robust
feature with a construction <code>(? : σ)</code> that is given a precise type,
which should later turn out to be a singleton. A simple <code>?</code> is then
explained as <code>(? : _)</code>, where <code>_</code> means "infer me" at the type level.</p>

<p>Consider for example those lines of OCaml or Haskell code found in
the wild (in fact in the OCaml type-checker and in GHC):</p>

<pre><code>(List.map (fun (name, smty, smodl) -&gt; (name, smty))

zipWith3M f xs ys zs =
  zipWithM (\x -&gt; \(y,z) -&gt; (f x y z)) xs (zip ys zs)
</code></pre>

<p>The functions passed to <code>List.map</code> and <code>zipWithM</code> here are the
typical kind of boilerplate that is boring to write. Provided that
"the types are distinct enough", they are also singleton types: <code>fun
(x,y,z) -&gt; (x,y)</code> is a singleton type as long as the types for <code>x</code>,
<code>y</code> and <code>z</code> are distinct (in this example I checked and they are),
likewise in the second example. Wouldn't it be nice to be able to write:</p>

<pre><code>(List.map ?)

zipWith3M f xs ys ys = zipWithM (? f) xs (zip ys zs)
</code></pre>

<p>The hope is that some of the case where you think "This is dumb,
I should not have to write it" may turn out to be, when looking at
them the right way, inferrable through singleton types.</p>

<h2>Singleton types precisely</h2>

<p>What does it mean for a type to be a singleton type? We have to make
a choice on four aspects:</p>

<ul>
<li><p>The type system we consider (the static semantics). Are we looking
for singleton types in ML, in System F, in a dependently typed
calculus? All those choices have merit, but for the purpose of the
demonstration I will mostly use examples in System F.</p></li>
<li><p>The language of the terms we infer (the dynamic semantics). If we
consider the full term language of OCaml (or Haskell) as the space
of our search, no interesting type is a singleton because of
non-terminating terms inhabiting any type. We want to restrict
ourselves to a pure (including total) lambda-calculus. For a start,
just the obvious explicitly typed thing with variables, lambdas and
applications will be fine.</p></li>
<li><p>Our notion of program equivalence: if we consider <code>t</code> and <code>(λx.x) t</code>
as two different programs, we will have trouble finding unique
inhabitants. On the other end, observational equivalence is often
undecidable for realistic languages, so we may have to pick
reasonable restrictions. I will just imagine I can perfectly decide
observational equivalence for now.</p></li>
<li><p>The typing context where inhabitants live: I am asking whether a type
<code>σ</code> has a unique inhabitant <code>t : σ</code>. To consider this properly
I need to pick a typing context <code>Γ</code> and ask about <code>Γ ⊢ ? : σ</code>. We
could imagine giving the user some freedom to specify the context in
which the search should take place. A good starting choice is to
consider the super-empty context: a context with no variables, but
also <em>no constants</em>: forget about <code>0, 1, 2, true, false</code>, etc., to
get even more singleton types (<code>bool → int → bool</code>,
for example). Other reasonable choices include the empty context
with constants, the current context of the program, or a restriction
of the current context with only the variables that have been marked
"implicit" of sorts.</p></li>
</ul>

<p>The restriction to an empty context is why I wrote <code>(? f)</code> in the
previous example:</p>

<pre><code>zipWithM3 f xs ys zs = zipWithM (? f) xs (zip ys zs)
</code></pre>

<p>If I just write <code>zipWithM ? xs ..</code>, this tries to infer code at the
type <code>(a → (b, c) → m d)</code>, which is not inhabited in an empty
context. On the contrary, the <code>?</code> in <code>(? f)</code> has type
<code>(a → b → c → m d) → (a → (b, c) → m d)</code>, which is a singleton
type. This shows that this construct can actually be used for
<em>partial</em> term inference, just add the hints as parameters to
<code>?</code>. (Another possibility would be to add syntax to specify
a context by hand, eg. <code>(f,g |- ? : σ)</code>.)</p>

<p>Similarly, it can also be used for plumbing: if you cannot remember
which of <code>x</code> or <code>y</code> comes first as a parameter to <code>f</code>, and they have
different types, <code>(? f x y)</code> can do the job. (If they don't have
different types there is a potential for non-statically-catchable
error and that's bad. OCaml's <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual006.html#toc35">labeled
arguments</a>
are very nice when used to fight this, but it's orthogonal to the
present considerations.)</p>

<h2>Related Work</h2>

<p>I know of surprisingly little work on the topic of "code inference"
(looking for this search string on Google Scholar for example brings
up very little hits), and would welcome pertinent pointers. There is
a paper at PLDI last year, <a href="http://research.microsoft.com/en-us/um/people/sumitg/pubs/pldi12.pdf">Type-Directed Completion of Partial
Expressions</a>
by Daniel Perelman, Sumit Gulwani, Thomas Ball and Dan Grossman, but
it is much more practically oriented: "let's look for completions
using typing hints and see how often we were right in ranking highly
a suggestion to the user". In the limit, you get something fuzzy and
interactive and machine-learning-based, where type-correctness is just
one ranking criterion among others, as you can find in <a href="http://research.microsoft.com/en-us/people/smcdirm/">Sean
McDirmid</a>'s work
on touch-based programming or calls to <a href="http://www.cs.rutgers.edu/~ccshan/rational/pcr.pdf">Programming as collaborative
reference</a>, but
that is not where I want to go now. The idea here more to study the
mathematical structure of singleton types, which is quite a different
subject.</p>

<p>Of course, "singleton types" is just a special case: it could also be
interesting for code inference to determine which types have only two
inhabitants; the compiler then wouldn't choose automatically
(that would break principality) but instead give the choice to the
user. Joe B. Wells has a paper with Boris Yakobowski (which is,
incidentally, a former <a href="http://gallium.inria.fr/~yakobows/">Gallium PhD
student</a>), <a href="http://www.macs.hw.ac.uk/~jbw/papers/#Wel+Yak:LOPSTR-2004-informal">Graph-based proof
counting and enumeration with applications for program fragment
synthesis</a>,
that does exactly this: count the number of inhabitants of types in an
intuitionistic type theory, and devise a term enumeration algorithm
out of it. It is the most pertinent previous work that I know of, and
was done with program synthesis in mind.</p>

<h2>Singleton types and programming experience</h2>

<p>I've mentioned that singleton types is only one specific case in the
wider setting of "please find me the inhabitants of this
type". I think however that focusing on singleton types is maybe not
as ad-hoc at is looks like: if a type has a finite number of
inhabitants, it can probably be decomposed as a sum of singleton
types. Maybe we could tell to the user of our <code>?</code> construction that
"you're not a singleton yet, you have to make a choice between this
type and this type", and let him add just enough information to
determine which situation she's interested in. That would be
potentially even more useful than enumerating the full terms and
letting the user choose one, as <code>?</code> may be more robust in the face of
code maintenance than system-spewed boilerplate.</p>

<p>More robust, or more fragile: being a singleton is not stable by
instantiation. The type <code>∀αβ. α*β → β*α</code> is a singleton, but
instantiating <code>α:=int, β:=int</code> breaks this property. (Note that it
is interesting in practice only if the type is inferred,
because it is just as long as the term.). People are
surprised/dismayed by this aspect when I give them examples of
singleton types, but I think it's fine: we are checking singletons
<em>after</em> type inference, where type abstractions and applications
have been fully determined. Yet I don't know how robust those <code>?</code>
would be in practice. I think the idea of doing all this <em>after</em>
type inference is a sane protection: I have this intuition that we
probably don't want a system that tries to infer <em>simultaneously</em>
the types of some part of our program, and the terms of another.</p>

<p>Note that it is possible to see the work on type classes as a specific
instance of the idea of singleton types. Using an operation of a type
class would add a <code>?</code> to synthesize the expected dictionary. Instance
declarations are function declarations (instance dependencies being
function arrows) that populate the context of search. The coherence
relations that reduce ambiguities in Haskell are a way to ensure
unicity of inhabitants. Finally, inference of class predicates
(the way <code>Eq a =&gt;</code> gets added to an inferred function type if you use
<code>(==)</code> inside the body of the function) is a way to ensure that there
is always an inhabitant.</p>

<p>This is not a realization of the highest importance, because it
actually tells us little new about type classes; singletons are
a rather general way to look at everything that involves some form of
"guessing code" that is a bit principled (and doesn't just produce
code at random); this recasting should work for other features that
can be expressed as code inference. It tells us, however, that some
particular forms in the design space for putting singleton types in
practice have already found themselves useful enough for
programmers. I think that justifies looking at the concept at a wide
angle.</p>

<h2>A temporary ending -- or delay</h2>

<p>This post is getting quite long, so I'll temporarily conclude
here. Stay tuned for another blog post with even more ramblings about
singleton types !</p>

<p>PS: <a href="http://gallium.inria.fr/~scherer/gagallium/site-url/&amp;gt;singleton-types-for-code-inference-2">The next
post</a> is now out.</p><a onclick="switchContent('post8','post7')" class="btn" href="#c2fcb8b4aa00ad4abb174274b6a1d45f">Hide</a></div></span>
<a name="442a8cf9808ce87d6f90546225bcb702"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/forum/forum.php?forum_id=867"> Macaque 0.6.1</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge News</span>, <span class="rss-date">26 Dec 2012</span></span><span class="rss-description"><pre class="rss-text">This is mostly a bugfix release: Jacques-Pascal Deplaix has spotted a bug in the way Macaque handles PostgreSQL rather baroque string escaping convention (you don't want to know the details), and after some head scratching we have a reasonable fix.

In addition, Petter Urkedal has contributed support for the 'bytea' and 'int32_array' datatypes; for now, there is no literal syntax to describe them in the syntax extension, so one should build values on the OCaml side, through Sql.Value.bytea and Sql.Value.int32_array.</pre></span>
<a name="e6c5dd3a656929c1664b08fc37901245"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2012.12.25.html"> Caml Weekly News, 25 Dec 2012</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">25 Dec 2012</span></span><span class="rss-description">new ocaml.org website / OCaml wiki / OCaml search into libraries for ocaml.org / Post-doc/Software Engineer at OCamlPro / Other Caml News</span>
<a name="e672efd955ba77a031ef9e8392474060"></a><span class="rss-header"><span class="rss-title"><a href="http://math.andrej.com/2012/12/25/free-variables-are-not-implicitly-universally-quantified/"> Free variables are not “implicitly universally quantified”!</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Andrej Bauer</span>, <span class="rss-date">25 Dec 2012</span></span><span class="rss-description"><div id="post9"><p>Mathematicians are often confused about the meaning of variables. I hear them say “a free variable is implicitly universally quantified”, by which they mean that it is ok to equate a formula $\phi$ with a free variable $x$ with its universal closure $\forall x \,.\, \phi$. I am addressing this post to those who share this opinion.</p>
<p><span id="more-1387"></span></p>
<p>I will give several reasons, which are all essentially the same, why “there is no difference between $\phi$ and $\forall x \,.\, \phi$” is a really bad opinion to have.</p>
<h3>Reason 1: you wouldn’t equate a function with its definite integral</h3>
<p>You would not claim that a real-valued function $f : \mathbb{R} \to \mathbb{R}$ is “the same thing” as its definite integral $\int_{\mathbb{R}} f(x) \, d x$, would you? One is a real function, the other is a real number. Likewise, $\phi$ is a truth &lt;emph&gt;function&lt;/emph&gt; and $\forall x \,.\, \phi(x)$ is a truth &lt;emph&gt;value&lt;/emph&gt;.</p>
<h3>Reason 2: functions are not their own values</h3>
<a onclick="switchContent('post9','post10')" class="btn" href="#e672efd955ba77a031ef9e8392474060">Read more...</a></div><div id="post10" style="display: none"><p>Mathematicians are often confused about the meaning of variables. I hear them say “a free variable is implicitly universally quantified”, by which they mean that it is ok to equate a formula $\phi$ with a free variable $x$ with its universal closure $\forall x \,.\, \phi$. I am addressing this post to those who share this opinion.</p>
<p><span id="more-1387"></span></p>
<p>I will give several reasons, which are all essentially the same, why “there is no difference between $\phi$ and $\forall x \,.\, \phi$” is a really bad opinion to have.</p>
<h3>Reason 1: you wouldn’t equate a function with its definite integral</h3>
<p>You would not claim that a real-valued function $f : \mathbb{R} \to \mathbb{R}$ is “the same thing” as its definite integral $\int_{\mathbb{R}} f(x) \, d x$, would you? One is a real function, the other is a real number. Likewise, $\phi$ is a truth &lt;emph&gt;function&lt;/emph&gt; and $\forall x \,.\, \phi(x)$ is a truth &lt;emph&gt;value&lt;/emph&gt;.</p>
<h3>Reason 2: functions are not their own values</h3>
<p>To be quite precise, the expression $\phi$ by itself is not a function, just like the expression $x + \sin x$ is not a function. To make it into a function we must first &lt;emph&gt;abstract&lt;/emph&gt; the variable $x$, which is usually written as $x \mapsto x + \sin x$, or $\lambda x \,.\, x + \sin x$, or <code>fun x -&gt; x +. sin x</code>. In logic we indicate the fact that $\phi$ is a function by putting it in a &lt;emph&gt;context&lt;/emph&gt;, so we write something like $x : \mathbb{R} \vdash \phi$.</p>
<p>Why is all this nit-picking necessary? Try answering these questions with “yes” and “no” consistently:</p>
<ol>
<li>Is $x + \sin x$ a function in variable $x$?</li>
<li>Is $x + \sin x$ a function in variables $x$ and $y$?</li>
<li>Is $y – y + x + \sin x$ a function in variables $x$ and $y$?</li>
<li>Is $x + \sin x = y – y + x + \sin x$?</li>
</ol>
<p>A similar sort of mistake happens in algebra where people think that polynomials are functions. They are not. They are elements of a certain freely generated ring.</p>
<h3>Reason 3: They are not logically equivalent</h3>
<p>It is absurd to claim that $\phi$ and $\forall x \in \mathbb{R} \,.\, \phi$ are logically equivalent statements. Suppose $\forall x \in \mathbb{R} \,.\, x &gt; 2$ were equivalent to $x &gt; 2$. Then I could replace one by the other in any formula I wish. So I choose the formula $\exists x \in \mathbb{R} \,.\, x &gt; 2$. It must be equivalent to $\exists x \in \mathbb{R} \,.\, \forall x \in \mathbb{R} \,.\, x &gt; 2$, but since $\forall x \in \mathbb{R} \,.\, x &gt; 2$ is false, we get $\exists x \in \mathbb{R} \,.\, \bot$, which is false. We proved that there is no number larger than 2.</p>
<h3>Reason 4: They are not inter-derivable</h3>
<p>If you can tell the difference between an implication and logical entailment, perhaps you might try to counter reason 3 by pointing out that $\phi$ and $\forall x \,.\, \phi$ are either both derivable, or both not derivable. That is to say, we can prove one if, and only if, we can prove the other. But again, this is not the case. We can prove $\forall x \in \emptyset \,.\, \bot$ but we cannot prove $\bot$.</p>
<h3>Reason 5: Bound variables can be renamed but free variables cannot</h3>
<p>The formula $x &gt; 2$ is obviously not the same thing as the formula $y &gt; 2$. But the formula $\forall x \in \mathbb{R} . x &gt; 2$ is actually the same as $\forall y \in \mathbb{R} . y &gt; 2$. If you find this confusing it is because you were never taught properly how to handle <a href="http://en.wikipedia.org/wiki/Free_variables_and_bound_variables">free and bound variables</a>.</p>
<h3>Reason 6: You cannot prove $\forall x \,.\, \phi$ without allowing $x$ to become free</h3>
<p>Perhaps we can just forbid free variables altogether and &lt;emph&gt;stipulate&lt;/emph&gt; that all variables must always be quantified. But how are you then going to prove $\forall x \in \mathbb{R} \,.\, \phi$? The usual way</p>
<blockquote><p>
“Consider any $x \in \mathbb{R}$. Then bla bla bla, therefore $\phi$.”
</p></blockquote>
<p>is now forbidden because the first sentence introduces $x$ as a free variable.</p>
<p>We can abolish variables altogether if we wish, by resorting to combinators, but it makes no sense to keep variables and make them all bound all the time.</p>
<h3>Epilogue: so in what sense are they the same?</h3>
<p>There is a theorem in model theory:</p>
<blockquote><p>
Let $\phi$ be a formula in context $x_1, \ldots, x_n$ and $M$ a structure in which we can interpret $\phi$. The following are equivalent:</p>
<ol>
<li>the universal closure $\forall x_1, \ldots, x_n \,.\, \phi$ is valid in $M$,</li>
<li>for every valuation $\nu : \lbrace x_1, \ldots, x_n \rbrace \to M$, $\phi[\nu]$ is valid in $M$.</li>
</ol>
</blockquote>
<p>This is sometimes abbreviated (quite inaccurately) as “a formula and its universal closure are semantically equivalent”. This theorem is causing a lot of harm because mathematicians interpret it as “free variables are implicitly universally bound”. But the theorem itself clearly distinguishes a formula from its universal closure. It has a limited range of applications in model theory. It is not a general reasoning principle that would allow you to dispose of thinking about free variables.</p>
<p>You are in good company. Philosophers have thought about free variables for millennia, although they phrase the problem in the language of <a href="http://en.wikipedia.org/wiki/Universal_(metaphysics)">universals</a> and <a href="http://en.wikipedia.org/wiki/Particular">particulars</a>. They wonder whether “dog” is the same thing as the set of all dogs, or perhaps there is an ideal dog which is “pure dogness”, but then do we need two ideal dogs to make ideal pups, etc. The answer is simple: a free variable is a projection from a cartesian product.</p><a onclick="switchContent('post10','post9')" class="btn" href="#e672efd955ba77a031ef9e8392474060">Hide</a></div></span>
<a name="2f9fc6a8ae811c870e3859f2689319a7"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/tptp/"> tptp</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">21 Dec 2012</span></span><span class="rss-description">Library for parsing FOF and CNF formulas from TPTP format. Depends on: zarith.</span>
<script type="text/javascript">function switchContent(id1,id2) {
     // Get the DOM reference
     var contentId1 = document.getElementById(id1);
     var contentId2 = document.getElementById(id2);
     // Toggle
     contentId1.style.display = "none";
     contentId2.style.display = "block";
     }</script></div>

  
    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
</body></html>
