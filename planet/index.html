<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: OCaml Planet</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contrinutors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="OCaml Planet" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it in your browser</a></li>
    <li><a href="../taste.html">A Hundred Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who is using it?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development tools</a></li>
    <li><a href="../documentation.html">Manuals and Cheat Sheets</a></li>
    <li><a href="../tutorials/#advanced">Advanced tutorials &amp; Papers</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">Github</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing lists</a></li>
    <li><a href="../planet/">OCaml Planet (blogs)</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml-lang.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>OCaml Planet
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

    <h1>OCaml Planet</h1>

    <p>The OCaml Planet aggregates various blogs from the OCaml
    community.  It is kindly provided
    by <a href="http://www.ocamlcore.com/">OCamlCore</a>.  If you
    would like to be added, read
    the <a href="http://www.ocamlcore.org/planet/">Planet
    subscription HOWTO</a>.</p>

    <br/>
    <div style="float: right; margin-right: 0; margin-top: 0" class="span2 planet-subscriptions"><em>Subscriptions</em>
      <ul><li><a href="http://alexleighton.tumblr.com/tagged/ocaml/rss">Alex Leighton</a></li><li><a href="http://blog.mestan.fr/feed/?cat=16">Alp Mestan</a></li><li><a href="http://andreiformiga.com/blog/?cat=5&feed=rss2">Andrei Formiga</a></li><li><a href="http://math.andrej.com/feed/">Andrej Bauer</a></li><li><a href="http://anil.recoil.org/feeds/atom.xml">Anil Madhavapeddy</a></li><li><a href="http://unnali.com/tag/ocaml/feed/">Arlen Cuss</a></li><li><a href="http://ashishagarwal.org/tag/ocaml/feed/">Ashish Agarwal</a></li><li><a href="http://www.blogger.com/feeds/7617521785419311079/posts/default">Cameleon news</a></li><li><a href="http://caml.inria.fr/news.en.rss">Caml INRIA</a></li><li><a href="http://camlspotter.blogspot.com/feeds/posts/default?alt=rss">Caml Spotting</a></li><li><a href="http://alan.petitepomme.net/cwn/cwn.rss">Caml Weekly News</a></li><li><a href="http://procrastiblog.com/category/ocaml/feed/">Christopher Conway</a></li><li><a href="http://coherentpdf.com/blog/?tag=ocaml&feed=rss">Coherent Graphics</a></li><li><a href="http://coq.inria.fr/news/feed">Coq</a></li><li><a href="http://erratique.ch/feeds/news.atom">Daniel Bünzli</a></li><li><a href="http://blog.dbpatterson.com/rss">Daniel Patterson</a></li><li><a href="http://nleyten.com/atom.aspx">Dario Teixeira</a></li><li><a href="http://www.blogger.com/feeds/17133288/posts/default/-/ocaml">David Baelde</a></li><li><a href="http://bentobako.org/david/blog/index.php?feed/tag/ocaml/atom">David Mentré</a></li><li><a href="http://dutherenverseauborddelatable.wordpress.com/category/ocaml/feed/">David Teller</a></li><li><a href="http://www.examachine.net/blog/?feed=rss2&cat=4">Eray Özkural</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/CodeHacking/Ocaml/index.rss20">Erik de Castro Lopo</a></li><li><a href="http://blog.emillon.org/feeds/ocaml.xml">Etienne Millon</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/FP-Syd/index.rss20">FP-Sydney</a></li><li><a href="http://www.blogger.com/feeds/8964007124326996693/posts/default/-/ocaml">Fayssal Martani</a></li><li><a href="http://frama-c.com/rss.xml">Frama-C</a></li><li><a href="http://functionaljobs.com/jobs/search/?q=ocaml&format=rss">Functional Jobs</a></li><li><a href="http://gallium.inria.fr/~scherer/gagallium/index.rss">GaGallium</a></li><li><a href="http://gaiustech.wordpress.com/category/ocaml/feed/">Gaius Hammond</a></li><li><a href="http://blog.camlcity.org/blog/rss">Gerd Stolpmann</a></li><li><a href="http://www.wisdomandwonder.com/tag/OCaml/feed">Grant Rettke</a></li><li><a href="http://blog.incubaid.com/tag/ocaml/feed/">Incubaid Research</a></li><li><a href="http://ambassadortothecomputers.blogspot.com/feeds/posts/default?alt=rss">Jake Donham</a></li><li><a href="http://scattered-thoughts.net/rss?tag=ocaml">Jamie Brandon</a></li><li><a href="http://ocaml.janestcapital.com/?q=rss.xml">Jane Street</a></li><li><a href="http://www.lexifi.com/blogs/ocaml/feed">LexiFi</a></li><li><a href="http://savonet.sourceforge.net/liquidsoap.rss">Liquidsoap</a></li><li><a href="http://syntaxexclamation.wordpress.com/tag/ocaml/feed/">Matthias Puech</a></li><li><a href="http://www.blogger.com/feeds/5888658295182480819/posts/default">Matías Giovannini</a></li><li><a href="http://eigenclass.org/R2/feeds/rss2/all">Mauricio Fernandez</a></li><li><a href="http://www.elehack.net/michael/blog/tags/ocaml?format=rss">Michael Ekstrand</a></li><li><a href="http://www.rktmb.org:82/feed/category/work/ocaml/atom">Mihamina Rakotomandimby</a></li><li><a href="http://nyc-ocaml.posterous.com/rss.xml">NYC OCaml</a></li><li><a href="http://ocamlhackers.ning.com/profiles/blog/feed?tag=ocaml&xn_auth=no">OCaml Hackers</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfnews.php">OCamlCore Forge News</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfprojects.php">OCamlCore Forge Projects</a></li><li><a href="http://www.ocamlcore.com/wp/?feed=rss2&amp;language=en&#038;language=en">OCamlCore.com</a></li><li><a href="http://www.ocamlpro.com/feed/atom.xml">OCamlPro</a></li><li><a href="http://odns.tuxfamily.org/feed/">ODNS project</a></li><li><a href="http://ox.tuxfamily.org/feed/">Ocaml XMPP project</a></li><li><a href="http://ocsigen.org/news.atom">Ocsigen project</a></li><li><a href="http://www.blogger.com/feeds/2073503406800427577/posts/default">Opa</a></li><li><a href="http://www.openmirage.org/blog/atom.xml">Open Mirage</a></li><li><a href="http://www.donadeo.net/facets/programming-languages/objective-caml/feed/">Paolo Donadeo</a></li><li><a href="https://mancoosi.org/~abate/taxonomy/term/5/0/feed">Pietro Abate</a></li><li><a href="http://redlizards.com/blog/feed/?tag=ocaml">Red Lizard Software</a></li><li><a href="http://rwmj.wordpress.com/tag/ocaml/feed/">Richard Jones</a></li><li><a href="http://blog.rastageeks.org/spip.php?page=rss&id_mot=2">Romain Beauxis</a></li><li><a href="http://seb.mondet.org/blog/feed/ocaml.rss">Sebastien Mondet</a></li><li><a href="http://upsilon.cc/~zack/tags/ocaml/index.rss">Stefano Zacchiroli</a></li><li><a href="http://le-gall.net/sylvain+violaine/blog/index.php?feed/tag/ocaml/atom">Sylvain Le Gall</a></li><li><a href="http://caml.inria.fr/hump.rss">The Caml Humps</a></li><li><a href="http://www.blogger.com/feeds/6115529230232389198/posts/default">Till Varoquaux</a></li><li><a href="http://www.nicollet.net/toroidal/ocaml/feed/">Victor Nicollet</a></li><li><a href="http://y-node.com/blog/feeds/tag/ocaml/">y-node</a></li></ul>

      <a href="http://planet.ocaml.org/rss20.xml"><img src=".././img/rss20.png"/></a>
      <a href="http://planet.ocaml.org/opml.xml"><img src=".././img/opml.png"/></a>
    </div>
    <div class="planet"><a name="9af1d5db458dcc344455b1e57d0f19a4"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=818"> Stog 0.4</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">22 Nov 2012</span></span><span class="rss-description">Stog is a kind of Jekyll in OCaml: It is a static web site generator, able to handle blog posts as well as regular pages.</span>
<a name="356e3f0da13f4e3ea3fdcf9d20edc44b"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=817"> Xtmpl 0.4</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">22 Nov 2012</span></span><span class="rss-description">Xtmpl is a small XML templating library for OCaml.</span>
<a name="d70d491cd82020f9a4aaa50c37091682"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2012.11.20.html"> Caml Weekly News, 20 Nov 2012</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">20 Nov 2012</span></span><span class="rss-description">Camlimages with ocamlbuild / OCaml messages in French / About ocamlbuild / GADT exhaustiveness check / DWARF output for native-code / Poll results of OASIS, package manager and misc.</span>
<a name="d37e23a5feb84014e6b814625589f150"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2012.11.13.html"> Caml Weekly News, 13 Nov 2012</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">13 Nov 2012</span></span><span class="rss-description">Google+ page / OASIS, package managers and misc. poll / parameterized classes, modules &amp; polymorphic variants / RTT: Run-time types for OCaml / Cyclic data structures: internal representation / Other Caml News</span>
<a name="e9ab0afb9dae2acbc8df14359d4e1b86"></a><span class="rss-header"><span class="rss-title"><a href="https://ocaml.janestreet.com/?q=node/112"> Maps, sets, and hashtables in core</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Jane Street</span>, <span class="rss-date">12 Nov 2012</span></span><span class="rss-description"><div id="post1"><p>The below post is mostly lifted from an email I sent to the <a href="https://groups.google.com/forum/#!forum/ocaml-core">Core mailing list</a>. It explains the type hackery we employ in order to get a really nice interface for maps, sets, hashtables and other such containers. It may look complex, but actually it works out remarkably simple to use, and ends up giving you a good number of static guarantees.</p>

<p>I'll use the example of hashtables, but the language readily
translates into sets / maps.</p>

<p>There are two types of hashtables in core. Ones that use polymorphic
comparison, and ones that use a specific comparision function that is
hopefully more efficient and has non-surprising semantics (we
basically think polymorphic comparison, despite its convenience, is
too surprising to be an overall good thing).</p>

<a onclick="switchContent('post1','post2')" class="btn" href="#e9ab0afb9dae2acbc8df14359d4e1b86">Read more...</a></div><div id="post2" style="display: none"><p>The below post is mostly lifted from an email I sent to the <a href="https://groups.google.com/forum/#!forum/ocaml-core">Core mailing list</a>. It explains the type hackery we employ in order to get a really nice interface for maps, sets, hashtables and other such containers. It may look complex, but actually it works out remarkably simple to use, and ends up giving you a good number of static guarantees.</p>

<p>I'll use the example of hashtables, but the language readily
translates into sets / maps.</p>

<p>There are two types of hashtables in core. Ones that use polymorphic
comparison, and ones that use a specific comparision function that is
hopefully more efficient and has non-surprising semantics (we
basically think polymorphic comparison, despite its convenience, is
too surprising to be an overall good thing).</p>

<p>The type of hashtables using polymorphic comparison is
<span class="geshifilter"><code class="geshifilter-text">('key, 'value) Hashtbl.Poly.t</code></span>. The type of hashtables using, <em>e.g.</em>,
int comparison for the keys is 'value Int.Table.t. Given the previous
paragraph, you should always try to use Foo.Table when you can.</p>

<p>When you create a hashtable (<em>e.g.</em> using <code>create</code>, <span class="geshifilter"><code class="geshifilter-text">of_alist</code></span>, or
<span class="geshifilter"><code class="geshifilter-text">t_of_sexp</code></span>), you must use the specific module name. <em>i.e.</em>
<span class="geshifilter"><code class="geshifilter-text">let table = Int.Table.create () in</code></span>. However, when you
already have a hashtable in your hands, and you want to use accessor
functions, you should just use Hashtbl.foo, regardless of what
comparison function it uses.</p>

<p>To translate into Maps and Sets:</p>

<p></p><div class="geshifilter"><pre style="font-family: monospace;" class="text geshifilter-text">'value Foo.Table.t  ('key,'value) Hashtbl.Poly.t  Hashtbl.foo
'value Foo.Map.t    ('key,'value) Map.Poly.t      Map.foo
Foo.Set.t           'element Set.Poly.t           Set.foo</pre></div><p></p>

<hr/>

<p>If you have your own type and want to make Table, Map and Set
submodules, it's really easy:</p>

<p></p><div class="geshifilter"><pre style="font-family: monospace;" class="ocaml geshifilter-ocaml"><span style="color: #06c; font-weight: bold;">module</span> T <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">struct</span>
  <span style="color: #06c; font-weight: bold;">type</span> t <span style="color: #a52a2a;">=</span> <span style="color: #a52a2a;">...</span> <span style="color: #06c; font-weight: bold;">with</span> <span style="color: #06c; font-weight: bold;">compare</span>, sexp
  <span style="color: #06c; font-weight: bold;">let</span> hash <span style="color: #a52a2a;">=</span> <span style="color: #5d478b; font-style: italic;">(* your hash function, maybe Hashtbl.hash *)</span>
<span style="color: #06c; font-weight: bold;">end</span>
<span style="color: #06c; font-weight: bold;">include</span> Comparable<span style="color: #a52a2a;">.</span><span style="color: #060;">Make</span><span style="color: #6c6;">(</span>T<span style="color: #6c6;">)</span>
<span style="color: #06c; font-weight: bold;">include</span> Hashable<span style="color: #a52a2a;">.</span><span style="color: #060;">Make</span><span style="color: #6c6;">(</span>T<span style="color: #6c6;">)</span></pre></div><p></p>

<p>Saying "with compare" generates you an efficient comparison function
specialised to your type. (Note that all component types need to have
comparison functions defined too, whether through "with compare" or
through primitives.) The Comparable.Make functor adds in modules to
make you satisfy the Comparable.S signature (basically the Set and Map
modules, and a few more). The Hashable.Make functor adds in modules to
make you satisfy Hashable.S (basically Hashtbl, as well as some others
like Hash_set). If you don't want the Hashable stuff, there is no need
to define a hash function. (Although Hashtbl.hash is normally not a
bad choice.)</p>

<hr/>

<p>Here's how this all works under the hood:</p>

<p>The type of maps is "really" <span class="geshifilter"><code class="geshifilter-text">('key, 'value, 'comparator) Map.t</code></span>. Maps
contain in their values the function that is used for comparing keys,
<em>i.e.</em> a function of type <span class="geshifilter"><code class="geshifilter-text">'key -&gt; 'key -&gt; int</code></span>. But what is this
"comparator" thing?</p>

<p>We can first motivate things by saying: it's a pain to have to type
Int.Map.find for int-maps, String.Map.find for string-maps, etc. etc.
It'd be nice to have a single type and use Map.find for everything.
But this presents a problem because of functions like Map.merge, which
takes two maps and combines them. You need to know that the comparison
functions are identical, but how can you do this?</p>

<p>So we have this extra comparator phantom type. Nothing in the actual
representation has a type involving 'comparator: it's just for static
checking. If you want to have a new comparison function, you must mint
a new comparator type. (Including the Comparable signature does this
for you.)</p>

<p>I originally wrote this last section with hashtables in mind, but due to a wrinkle, hashtables work a little differently. Maps and sets are fully comparator-ified, but we're yet to completely cut over hashtables. As a result, the following code types but gives a runtime error:</p>

<p></p><div class="geshifilter"><pre style="font-family: monospace;" class="ocaml geshifilter-ocaml"><span style="color: #06c; font-weight: bold;">Hashtbl</span><span style="color: #a52a2a;">.</span><span style="color: #060;">merge</span> <span style="color: #6c6;">(</span>Int<span style="color: #a52a2a;">.</span><span style="color: #060;">Table</span><span style="color: #a52a2a;">.</span><span style="color: #060;">create</span> <span style="color: #6c6;">(</span><span style="color: #6c6;">)</span><span style="color: #6c6;">)</span> <span style="color: #6c6;">(</span><span style="color: #06c; font-weight: bold;">Hashtbl</span><span style="color: #a52a2a;">.</span><span style="color: #060;">Poly</span><span style="color: #a52a2a;">.</span><span style="color: #060;">create</span> <span style="color: #6c6;">(</span><span style="color: #6c6;">)</span><span style="color: #6c6;">)</span></pre></div><p></p>

<p>(The situation is not fully terrible: the above example only works if one side is Hashtbl.Poly.) We're working on fixing this inconsistency -- expect to see it in a version of core soon.</p><a onclick="switchContent('post2','post1')" class="btn" href="#e9ab0afb9dae2acbc8df14359d4e1b86">Hide</a></div></span>
<a name="431d644e0dbbcb19dfd5282281069a9f"></a><span class="rss-header"><span class="rss-title"><a href="http://math.andrej.com/2012/11/11/how-to-implement-dependent-type-theory-ii/"> How to implement dependent type theory II</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Andrej Bauer</span>, <span class="rss-date">11 Nov 2012</span></span><span class="rss-description"><div id="post3"><p>I am on a roll. In the second post on how to implement dependent type theory we are going to:</p>
<ol>
<li>Spiff up the syntax by allowing more flexible syntax for bindings in functions and products.</li>
<li>Keep track of source code locations so that we can report <em>where</em> the error has occurred.</li>
<li>Perform <a href="http://en.wikipedia.org/wiki/Normalisation_by_evaluation">normalization by evaluation</a>.</li>
</ol>
<p><span id="more-1320"></span></p>
<p>The relevant Github repository is <a href="https://github.com/andrejbauer/tt/tree/blog-part-II">andrejbauer/tt/</a> (branch blog-part-II). By the way, there are probably bugs in the implementation, I am not spending a huge amount of time on testing (mental note: put “implement testing” on the to do list). If you discover one, please tell me, or preferrably make a pull request with a fix. This also applies to old branches.</p>
<h3>Source code positions</h3>
<p>Source code positions seem like an annoyance because they pollute our nice datatypes. Nevertheless, an even bigger annoyance is an error message without an indication of its position.</p>
<a onclick="switchContent('post3','post4')" class="btn" href="#431d644e0dbbcb19dfd5282281069a9f">Read more...</a></div><div id="post4" style="display: none"><p>I am on a roll. In the second post on how to implement dependent type theory we are going to:</p>
<ol>
<li>Spiff up the syntax by allowing more flexible syntax for bindings in functions and products.</li>
<li>Keep track of source code locations so that we can report <em>where</em> the error has occurred.</li>
<li>Perform <a href="http://en.wikipedia.org/wiki/Normalisation_by_evaluation">normalization by evaluation</a>.</li>
</ol>
<p><span id="more-1320"></span></p>
<p>The relevant Github repository is <a href="https://github.com/andrejbauer/tt/tree/blog-part-II">andrejbauer/tt/</a> (branch blog-part-II). By the way, there are probably bugs in the implementation, I am not spending a huge amount of time on testing (mental note: put “implement testing” on the to do list). If you discover one, please tell me, or preferrably make a pull request with a fix. This also applies to old branches.</p>
<h3>Source code positions</h3>
<p>Source code positions seem like an annoyance because they pollute our nice datatypes. Nevertheless, an even bigger annoyance is an error message without an indication of its position.</p>
<p>The OCaml lexer keeps track of positions, and menhir has support for them, so we just need to incorporate them into our program. Every expression should be tagged with the source code position it came from. Sometimes we generate expressions with no associated position, so we define:</p>
<pre class="brush: plain; title: ; notranslate">type position =
  | Position of Lexing.position * Lexing.position
  | Nowhere
</pre>
<p>The type <code>Lexing.position</code> is the one from OCaml lexer. Each expression is associated with two such positions, its beginning and end. To tag expressions with positions we define two types: <code>expr</code> is an expression with a position and <code>expr'</code> without (I stole the idea from <a href="http://matija.pretnar.info/">Matija Pretnar</a>‘s <a href="http://math.andrej.com/eff/">eff</a> code):</p>
<pre class="brush: plain; title: ; notranslate">(** Abstract syntax of expressions. *)
type expr = expr' * position
and expr' =
  | Var of variable
  | Universe of int
  | Pi of abstraction
  | Lambda of abstraction
  | App of expr * expr

(** An abstraction [(x,t,e)] indicates that [x] of type [t] is bound in [e]. *)
and abstraction = variable * expr * expr
</pre>
<p>Note that <code>expr'</code> refers back to <code>expr</code> so that subexpressions come equipped with their positions. We generally follow the rule that an apostrophe is attached to a type or a function which is position-less. Except that apostrohpies are not valid in the names of grammatical rules in the parser, so in <a href="https://github.com/andrejbauer/tt/blob/blog-part-II/parser.mly">parser.mly</a> we write <code>plain_expr</code> instead of <code>expr'</code>.</p>
<p>We also extend the pretty printer and error reporting with positions, feel free to consult the source code.</p>
<h3>Better syntax for bindings</h3>
<p>This is a fairly trivial change. It is annoying to have to write things like</p>
<pre class="brush: plain; title: ; notranslate">fun x : A =&gt; fun y : A =&gt; fun z : B =&gt; fun w : B =&gt; ...
</pre>
<p>We improve the parser so that it accepts syntax like</p>
<pre class="brush: plain; title: ; notranslate">fun (x y : A) (z w : B) =&gt; ...
</pre>
<p>Let us read out the relevant portion of <a href="https://github.com/andrejbauer/tt/blob/blog-part-II/parser.mly">parser.mly</a>, namely the rules <code>abstraction</code>, <code>bind1</code> and <code>binds</code>:</p>
<pre class="brush: plain; title: ; notranslate">abstraction:
  | b = bind1
    { [b] }
  | bs = binds
    { bs }

bind1: mark_position(plain_bind1) { $1 }
plain_bind1:
  | xs = nonempty_list(NAME) COLON t = expr
    { (List.map (fun x -&gt; String x) xs, t) }

binds:
  | LPAREN b = bind1 RPAREN
    { [b] }
  | LPAREN b = bind1 RPAREN lst = binds
    { b :: lst }
</pre>
<p>A <code>bind1</code> is something of the form <code>x y ... z : t</code>. A <code>binds</code> is a non-empty list of parenthesized <code>bind1</code>‘s. An abstraction is either a <code>bind1</code> or a <code>binds</code>. Thus we can write <code>fun x y z : t =&gt; ...</code> and <code>fun (x y z : t) =&gt; ...</code> and <code>fun (x y : t) (z : t) =&gt; ...</code> but not <code>fun x y : y (z : t) =&gt; ...</code>.</p>
<h3>Normalization by evaluation</h3>
<p>In the first version we performed normalization by substitution, just like theory books say we should. But this is horribly inefficient. We could improve efficiency by keeping a current substitution (a “runtime” environment) which maps variables to the expressions. When we encounter a variable we look up its value in the current substitution. This way at least we do not keep traversing expressions during substitutions.</p>
<p>An even cooler way to normalize is known as normalization by evaluation. We first “evaluate” expressions to actual OCaml values in such a way that definitionally equal expressions evaluate to (observationally) equivalent values, and then we reconstruct the expression from the value (the fancy speak is that we <a href="http://dictionary.reference.com/browse/reify">reify</a> the value). Apart from giving us a normal form there are all sorts of other benefits (Dan Grayson keeps asking me which, perhaps the more knowledgable readers can point them out).</p>
<p>We need a datatype <code>value</code> into which we evaluate expressions. We need to evaluate expressions with free variables, which means that we are going to get stuck on applications of the form <code>x v1 v2 .. vn</code> where <code>x</code> is a free variable (these are called head-normal). We collect those in a separate datatype <code>neutral</code>:</p>
<pre class="brush: plain; title: ; notranslate">type value =
  | Neutral of neutral
  | Universe of int
  | Pi of abstraction
  | Lambda of abstraction

and abstraction = variable * value * (value -&gt; value)

and neutral =
  | Var of variable
  | App of neutral * value
</pre>
<p>Abstractions will be evaluated to OCaml functions (so OCaml will take care of substitutions). Thus an abstraction like <code>fun x : t =&gt; e</code> should be evaluated to a pair <code>(u, v)</code> where <code>u</code> is the value of <code>t</code> and <code>v</code> is the function $x \mapsto e$. But if you look at the definition of <code>abstraction</code> above you see that we also keep around the variable name. This we do for pretty-printing purposes. When we reify an evaluated abstraction back to its expression form, we use the variable name as a hint.</p>
<p>You should take the time to read <a href="https://github.com/andrejbauer/tt/blob/blog-part-II/value.ml"><code>value.ml</code></a> which contains evaluation and reification, and comparison of values. Also note that <code>Infer.normalize</code> really is just the composition of evaluation and reification.</p>
<p>We are now at 759 lines of code. We added 90 codes for evaluation by normalization and 51 for the for keeping track of source code positions.</p>
<h3>Trying something out</h3>
<p>Ok, let us try something fun. How about <a href="http://en.wikipedia.org/wiki/Church_encoding">Church numerals</a>?</p>
<pre class="brush: plain; title: ; notranslate">Parameter N : Type 0.
Parameter z : N.
Parameter s : N -&gt; N.

Definition numeral := forall A : Type 0, (A -&gt; A) -&gt; (A -&gt; A).

Definition zero := fun (A : Type 0) (f : A -&gt; A) (x : A) =&gt; x.
Definition one := fun (A : Type 0) (f : A -&gt; A) =&gt; f.
Definition two := fun (A : Type 0) (f : A -&gt; A) (x : A) =&gt; f (f x).
Definition three := fun (A : Type 0) (f : A -&gt; A) (x : A) =&gt; f (f (f x)).

Definition plus :=
  fun (m n : numeral) (A : Type 0) (f : A -&gt; A) (x : A) =&gt; m A f (n A f x).

Definition times :=
  fun (m n : numeral) (A : Type 0) (f : A -&gt; A) (x : A) =&gt; m A (n A f) x.

Definition power :=
  fun (m n : numeral) (A : Type 0) =&gt; m (A -&gt; A) (n A).
  
Definition four := plus two two.
Definition five := plus two three.
</pre>
<p>If you put the above code in <code>church.tt</code> you can load it into <code>tt</code> by</p>
<pre class="brush: plain; title: ; notranslate">./tt.native -l church.tt
</pre>
<p>Dare we compute $2^{16}$? Sure:</p>
<pre class="brush: plain; title: ; notranslate"># Eval power two (power two four) N s z.
    = s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s (s
      (s (s (s (s (s (s (s (s (s (s (... (...)))))))))))))))))))))))))))))))))))))))
    : N
</pre>
<p>It takes a moment, but that is mostly because of pretty-printing (if you evaluate the same expression in non-interactive mode by placing it in a file, you will notice no delay). How about $2^{20}$?</p>
<pre class="brush: plain; title: ; notranslate"># Eval power two (times four five).
Fatal error: exception Stack_overflow
</pre>
<p>Oh well. We will have to do something smarter (I am open to suggestions), or increase the stack size. Next time we are going some more types, and then I would like to focus on how to implement an interactive mode.</p><a onclick="switchContent('post4','post3')" class="btn" href="#431d644e0dbbcb19dfd5282281069a9f">Hide</a></div></span>
<a name="b4f4adcad86f1f55317ed49cdf532cb2"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/mnf/"> Master and Footballer</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">11 Nov 2012</span></span><span class="rss-description">Master and Footballer is a managing football game. The players manage team composition, tactics, finance, player-transfer...and their own career.</span>
<a name="25917b210243d63ffd6dedf3d61f3b40"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/~scherer/gagallium/resolving-field-names-2/index.html"> Resolution of label and constructor names: the devil in the details</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">08 Nov 2012</span></span><span class="rss-description"><div id="post5"><p>This is a following to the <a href="http://gallium.inria.fr/~scherer/gagallium/resolving-field-names/">previous
post</a> explaining the current
discussion around record field and variant constructors
disambiguation. This second, more technical blog post will discuss
some details of the semantics, and the last one explain some of the
philosophical/aesthetic arguments that were used to support either
proposal -- which may interest you if you like type system design, and
come back in other discussions of OCaml design choices.</p>




<h2>The devil is in the details</h2>

<h3>Disambiguation of scoped labels</h3>

<p>In Jacques' initial proposal, only non-scoped labels were
disambiguated using typing information: <code>(r:t).l</code> would get elaborated
into <code>r.l^t</code>, but <code>(r:t).P.l</code> would be looked up by the naming
environment P.l only, without using type information.</p>

<a onclick="switchContent('post5','post6')" class="btn" href="#25917b210243d63ffd6dedf3d61f3b40">Read more...</a></div><div id="post6" style="display: none"><p>This is a following to the <a href="http://gallium.inria.fr/~scherer/gagallium/resolving-field-names/">previous
post</a> explaining the current
discussion around record field and variant constructors
disambiguation. This second, more technical blog post will discuss
some details of the semantics, and the last one explain some of the
philosophical/aesthetic arguments that were used to support either
proposal -- which may interest you if you like type system design, and
come back in other discussions of OCaml design choices.</p>




<h2>The devil is in the details</h2>

<h3>Disambiguation of scoped labels</h3>

<p>In Jacques' initial proposal, only non-scoped labels were
disambiguated using typing information: <code>(r:t).l</code> would get elaborated
into <code>r.l^t</code>, but <code>(r:t).P.l</code> would be looked up by the naming
environment P.l only, without using type information.</p>

<p>In the consensus proposal, the type information is used also in this
case, but only candidates that do have the long identifier P.l (they
are possibly several in case of label shadowing) are considered. You
could also drop P altogether in this case and use only type
information (if it is present, there is only one correct choice
anyway), but this doesn't make much sense. Another possibility would
be to disambiguate in the sub-environment under P: consider all labels
of the form P.Q.l for some long prefix Q, but warn when Q is not
empty, as this is only accepted by the scope-inferring strategy.</p>

<h3>Multi-label or first-label lookup</h3>

<p>In his own implementation at Lexifi, Alain uses a multi-label lookup
scheme: in the case where you're constructing a record, you can use
not only the first label to disambiguate, but all the present
labels. This would make the following accepted:</p>

<div>


<pre class="code-ocaml"><span class="hl kwa">type</span> t1 <span class="hl opt">= {</span> foo <span class="hl opt">:</span> <span class="hl kwc">int</span><span class="hl opt">;</span> bar <span class="hl opt">:</span> <span class="hl kwc">float</span> <span class="hl opt">}</span>
<span class="hl kwa">type</span> t2 <span class="hl opt">= {</span> foo <span class="hl opt">:</span> <span class="hl kwc">int</span><span class="hl opt">;</span> baz <span class="hl opt">:</span> <span class="hl kwc">bool</span> <span class="hl opt">}</span>

<span class="hl kwa">let</span> mk1 foo bar <span class="hl opt">= {</span> foo<span class="hl opt">;</span> bar <span class="hl opt">}</span>
<span class="hl kwa">let</span> mk2 foo baz <span class="hl opt">= {</span> foo<span class="hl opt">;</span> baz <span class="hl opt">}</span>
</pre>


</div>

<p>With the current OCaml type-system, <code>mk1</code> would be rejected as <code>foo</code>
is resolved at type <code>t2</code> by the shadowing rule. Alain remarks that if
take into account all the fields, it's clear that <code>mk1</code> can only build
a <code>t1</code> because the field <code>bar</code> is present. This is a purely syntactic
criterion (no type information involved) that improves over the statu
quo.</p>

<p>The initial implementation of the type-based strategies had only
single-label lookup (using the first label appearing in the
record expression), but after some discussion multi-label lookup is
now implemented and used in absence of type information.</p>

<h3>Warn to avoid relying on shadowing</h3>

<p>One criticism that applies equally to both proposals is that the
semantics of the code now depends on the presence or absence of type
information -- in particular type annotations, while OCaml programmers
are used to consider that they are useful for clarity and debugging
purposes only.</p>

<p>In the case of access to a label that is not currently in the naming
environment, the situation is rather clear: either there is type
information available and, by the scope-inferring strategy, the
program is accepted, or there isn't and the program is rejected. In
this case, there exists a unique well-typed program and type
annotations only allow to find it.</p>

<p>The situation is more awkward in the case where you access a label
through a long identifier that does exist in the naming environment
(it was defined at the toplevel or imported by an <code>open</code>
directive). For example :</p>

<div>


<pre class="code-ocaml"><span class="hl kwa">module</span> <span class="hl kwd">P</span> <span class="hl opt">=</span> <span class="hl kwa">struct</span>
  <span class="hl kwa">type</span> t <span class="hl opt">= {</span> l1 <span class="hl opt">:</span> <span class="hl kwc">int</span> <span class="hl opt">}</span>
<span class="hl kwb">end</span>
<span class="hl kwa">open</span> <span class="hl kwd">P</span>
<span class="hl kwa">type</span> u <span class="hl opt">= {</span> l1 <span class="hl opt">:</span> <span class="hl kwc">bool</span> <span class="hl opt">}</span>

<span class="hl opt">...</span> <span class="hl com">(* some code *)</span>

<span class="hl kwa">let</span> awkward <span class="hl opt">=</span> do_something <span class="hl opt">(</span><span class="hl kwa">fun</span> r <span class="hl opt">-&gt;</span> r<span class="hl opt">.</span>l1<span class="hl opt">)</span>
</pre>


</div>

<p>The interpretation of this example depends on whether <code>do_something</code>
provides type information. If it does not, the shadowing rules applies
and the label is understood as <code>l1^u</code>. If it happens to have a type
of the form <code>(P.t -&gt; _) -&gt; _</code>, then the label is understood as
<code>l1^(P.t)</code>.  It is a bit worrying that both interpretation could be
correct, and that the choice made depends on the order of <code>open P</code> and
<code>type u = ...</code>.</p>

<p>There are two solutions to make sure this awkwardness is avoided. You
could always disable type-based lookup when name-based lookup
succeeds. This was Jacques initial proposition, but it is exactly the
opposite of what the conflict-solving proposal suggests, which is only
useful to disambiguate between several name-based lookup
possibilities, so this solution hasn't been kept.</p>

<p>The other solution is to remove the shadowing rule from the language:
in the case where a given long identifier may denote several different
labels, accept to type-check the program only in presence of type
information. You are back in the reasonable situation where there
always exists a unique way to have the program type-check. However
this solution is not conservative, as it would reject programs that
are currently accepted by the OCaml compiler (and make use of
label shadowing). This is not acceptable, and the consensus it to
raise a warning in this case.</p>

<p>(If you're beginning to think that adding warnings instead of making
a choice between "it's ok" or "it's wrong" is a convenient way to dump
hard design decisions onto the user instead of making them on the
language side, well, you might have a point. <br/>
And before you complain about warnings being hard to activate or
deactivate locally, let me note that I welcome well-thought-out
suggestions and implementations of such pragma-like systems for OCaml,
but that you will have a hard time making everyone happy about it.)</p>

<h2>Philosophical justifications for either proposals</h2>

<h3>Scoped, unscoped or type-scoped labels</h3>

<p>What was your mental model of OCaml labels and variant constructors:
did you think of them as scoped names at a particular module prefix,
or as global names like method names and polymorphic variant tags?</p>

<p>I definitely had a scoped model. Jacques seems to have an unscoped
model. This affects how we consider both proposal, the conflict-solving
one being the most natural to me (and the other one distastefully
daring in omitting module prefixes), while Jacques is at home with the
scope-inferring proposal and clearly intends to disable the
restricting warning for his personal developments.</p>

<p>In the vision Jacques explained in this post (which was at least
a formal vision you can have during this discussion, I don't claim
that it is <em>the</em> way he thinks about labels), record labels and
variant constructors are global names. Record access and variant
matching are doing a lookup based on these global names, just as
objects and polymorphic variants, and the syntactic module prefix is
just here for type-checking purposes.</p>

<p>In my mental object of OCaml records and constructions, the declarations</p>

<div>


<pre class="code-ocaml"><span class="hl kwa">type</span> record <span class="hl opt">= {</span> foo <span class="hl opt">:</span> <span class="hl kwc">int</span><span class="hl opt">;</span> bar <span class="hl opt">:</span> <span class="hl kwc">bool</span> <span class="hl opt">}</span>
<span class="hl kwa">type</span> sum <span class="hl opt">=</span> <span class="hl kwd">A</span> <span class="hl kwa">of</span> <span class="hl kwc">int</span> | <span class="hl kwd">B</span> <span class="hl kwa">of</span> <span class="hl kwc">bool</span>
</pre>


</div>

<p>can be understood as some well-supported form of syntactic sugar for
the following presentation in term of introduction and elimination
rules, introduced as primitives:</p>

<div>


<pre class="code-ocaml"><span class="hl kwa">type</span> record <span class="hl com">(* abstract type *)</span>
<span class="hl kwa">val</span> foo <span class="hl opt">:</span> record <span class="hl opt">-&gt;</span> <span class="hl kwc">int</span>
<span class="hl kwa">val</span> bar <span class="hl opt">:</span> record <span class="hl opt">-&gt;</span> <span class="hl kwc">bool</span>
<span class="hl kwa">val</span> record_intro <span class="hl opt">:</span> ~foo<span class="hl opt">:</span><span class="hl kwc">int</span> <span class="hl opt">-&gt;</span> ~bar<span class="hl opt">:</span><span class="hl kwc">int</span> <span class="hl opt">-&gt;</span> record

<span class="hl kwa">type</span> sum
<span class="hl kwa">val</span> <span class="hl kwd">A</span> <span class="hl opt">:</span> <span class="hl kwc">int</span> <span class="hl opt">-&gt;</span> sum
<span class="hl kwa">val</span> <span class="hl kwd">B</span> <span class="hl opt">:</span> <span class="hl kwc">bool</span> <span class="hl opt">-&gt;</span> sum
<span class="hl kwa">val</span> sum_elim <span class="hl opt">:</span> ~case_A<span class="hl opt">:(</span><span class="hl kwc">int</span> <span class="hl opt">-&gt;</span> 'a<span class="hl opt">) -&gt;</span> ~case_B<span class="hl opt">:(</span><span class="hl kwc">int</span> <span class="hl opt">-&gt;</span> 'a<span class="hl opt">) -&gt;</span> 'a
</pre>


</div>

<p>With this point of view, labels and constructors are essentially
identifiers like any other, for which convenient syntactic sugar is
provided: this is firmly rooted in the "scoped" view of labels. We
could consider having a functional language that is lower-level than
OCaml, and allows to implement those primitives of record and variant
construction and destruction as derived features -- in a way that is
more efficient, by the way, that what dispatch/lookup on global names
allows.</p>

<p>Finally, a third possible view of labels is that the identity of the
associated type, instead of their module prefix, is part of their full
name -- they are "type-scoped". The identity of the label is <code>l^t</code>
rather than <code>l</code>, with the type part being hidden from the programmer
for convenience. This subsumes both points of view, and I think it is
the one you need to adopt to make sense of the proposal as it will be
implemented -- also the one closest to Jacques' argumentation.</p>

<h3>Type-erasure semantics vs. type-directed elaboration</h3>

<p>A maybe subtle point of the discussion was the request by Jacques of
a "dynamic semantics that does not depend on types", also called
a type-erasure or type-erasable semantics. The idea is that if you
take an OCaml program exactly as it is written, you can drop all form
of type information, and claim that you have obtained a program in an
untyped (~ dynamically typed) language that can be executed as is. The
dynamics semantics (what happens at runtime) is free of any typing
consideration.</p>

<p>This does not hold of all programming languages. Haskell type classes,
for example, are a form of static information that has an influence
over the dynamic semantics of the program (which type-class
dictionaries get resolved where). If you drop all static information
from a Haskell program, you have lost information that is necessary to
run it. (This is different from some object-oriented overloading
scheme that resolve method calls <code>o.m(...)</code> based on the type of the
object <code>o</code>, which can be kept until runtime. In Haskell you get
return-type-based overloading which cannot be explained in this way:
<code>min :: Bounded a =&gt; a</code>.)</p>

<p>Type-erasure is not a black-and-white concept: what you do in practice
is to explain precisely which part of the type information plays
a runtime role. You do that by defining a type-directed translation
from your base language to a slightly more explicit language, that
does have a type-erasure semantics -- all the information you need has
now been exposed in the syntax. The smaller, simpler, most local this
translation ("elaboration") step is, the closer to type-erasure you language is.</p>

<p>A type-erasure semantics is good for performance (you can drop typing
information instead of maintaining it at runtime), but I think the
most important benefit is that it acts as a design pressure that can
force you to do the right thing. Forcing yourself to describe that
small elaboration step explicitly is always a good idea. In
particular, it is an excellent candidate of what a "show me the
implicit stuff" feature should reveal in an IDE for your programming
language.</p>

<p>Back to the point, Jacques remarked that, from the point of view of
the dynamic semantics, his model of unscoped labels supports
type-erasure: if your mental model of the runtime semantics of the
language is to dispatch on labels as global names, you can drop all
type annotation without changing the semantics of the program. Because
you only do that for programs that have been type-checked, you know
that you won't get a label coming from an unexpected place (at an
unexpected type).</p>

<p>On the contrary, the conflict-solving proposal combined with scoped labels
seems to break the property of having a type-erasure semantics. With
only the shadowing rule, you can give a dynamic semantics of scoped
labels that is type-erasing. As soon as you support type-directed
disambiguation instead of shadowing, you face the choice of either:</p>

<ul>
<li><p>using a dispatch model on ambiguous names, as we have for the
unscoped semantics (but then why insist on a scoped model?)</p></li>
<li><p>or using an elaboration step to explain the translation from the
overloaded <code>r.P.l</code> to the unambiguous <code>r.P.l^t</code>.</p></li>
</ul>

<p>Jacques criticized this elaboration step for first breaking the
type-erasability of the dynamic semantics, and secondly introducing
some amount of type overloading that has so far been forcefully kept
out of the OCaml language. </p>

<p>I believe we should recognize and accept this elaboration step, taking
a mental model of type-scoped labels instead of module-scoped
labels. The type-erasure semantics with unscoped label names gets
type-erasure at the cost of a richer runtime model (dispatch on
global names), which is conceptually more complex (and formally
less efficient) than the simpler semantics after the
elaboration. Besides, syntactic overloading is indeed an evil that we
all hate because of the ambiguity it introduces, but the potential for
ambiguity of the conflict-solving proposal is strictly inferior to the
ambiguity of the scope-inferring proposal; in any case, anyone
supporting either this feature accepts introducing some amount of
ambiguity on label names -- which are, I think, a reasonably
self-contained place to be ambiguous.</p>

<h3>Layered system design: name resolution before or during typing?</h3>

<p>I like to think of strongly typed languages as a layering of three set
of static rules:</p>

<ol>
<li><p>Parsing: Syntactic rules that reject syntactically invalid program,
and otherwise give you a well-formed Abstract Syntax Tree (AST)</p></li>
<li><p>Binding: Name resolution rules that take the AST and compute where each
occurrence of an identifier was bound, reject programs with unbound
variable occurrences, and return you an AST enriched with
definition-site/use-site information. The derivations used at these
steps remembers which name are defined in the current naming
environment, but not (yet) their type.</p></li>
<li><p>Typing: rules that accept this AST with name resolution
information, and returns a full typing derivation proving that the
program is well-typed (or reject it)</p></li>
</ol>

<p>In the current implementation of the OCaml compiler, steps 2. and
3. are interleaved, done at the same time (a previous version of the
"unused variable" warning implementation actually re-implemented step
2. as a separate pass). But conceptually this separation can still be
done and helps to think about the design of the language.</p>

<p>For example, the
<a href="https://bitbucket.org/camlspotter/ocamlspot">ocamlspotter</a> tool of
Jun Furuse, that can tell you where each name is defined, (currently)
depends only on the output of the name resolution pass, without
needing typing information.</p>

<p>When you consider a new feature, you can wonder how it affects these
different steps. New syntactic sugar affects only step (1) (or can be
described as an AST-to-AST rewriting step happening just after step
(1)). Introducing the <code>open</code> keyword affects steps (1) and (2), but
not step (3). Adding GADTs added new syntax (step 1) and new typing
rules (step 3), but no particular identifier-resolution rule, while
changes to pattern matching may affect all three layers.</p>

<p>How do the scope-inferring and conflict-solving proposal affect the
layer of the static semantics of our programming language?</p>

<p>With the conflict-solving proposal, the notion of "name resolution" of
a label has to be weakened: when you find an access to a long label,
<code>r.P.l</code>, you look at the set of names exported by the (sub)module <code>P</code>
in your naming environment, and instead of taking only the last <code>l</code>
defined in this environment, you have to consider the set <code>{l^t1,
l^t2..., l^tn}</code> for all types <code>t1,..,tn</code> in <code>P</code> that define the label
<code>l</code> (note that we look only at the type and label names, not at the
actual types).  Then, when you run the later step (3), you may have
access to type information. If you don't, you should use the shadowing
rule (pick the last label in the set) and potentially raise a warning
if there is more than one candidate. If you have the type of <code>r</code>, it
must be along the <code>t1,..,tn</code>, and you can disambiguate the label into
a unique possible candidate.  Note that the "multi-label"
disambiguation strategy of Alain also happens purely during step (2).</p>

<p>For the scope-inferring proposal, you cannot say anything meaningful
about labels during step (2): if you see an access with an unqualified
label <code>r.l</code>, <code>l</code> might not be present unqualified in your naming
environment, but potentially happen anywhere in a submodule. You can
only keep <code>l</code> as a global name (unscoped model), and wait until step
(3) to resolve the ambiguity.</p>

<p>Under this (admittedly personal) point of view, the
conflict-solving strategy is less complex than the scope-inferring
proposal: it displays a controlled amount of syntactic ambiguity
(resolving to a set of candidate names instead of one possibility),
which is discharged at typing time. On the other hand, the
disambiguation strategy of the scope-inferring proposal can be
explained by producing a syntactically correct disambiguated AST,
which is not the case the conflict-solving strategy, unless you were
to add the explicit construction <code>l^t</code>, which was proposed in the past
but not really considered in this discussion -- which was complex
enough already.</p><a onclick="switchContent('post6','post5')" class="btn" href="#25917b210243d63ffd6dedf3d61f3b40">Hide</a></div></span>
<a name="82f1b76b57a5bcfd226af67ec43903de"></a><span class="rss-header"><span class="rss-title"><a href="http://math.andrej.com/2012/11/08/how-to-implement-dependent-type-theory-i/"> How to implement dependent type theory I</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Andrej Bauer</span>, <span class="rss-date">08 Nov 2012</span></span><span class="rss-description"><div id="post7"><p>I am spending a semester at the <a href="http://www.ias.edu/">Institute for Advanced Study</a> where we have a special year on <a href="http://www.math.ias.edu/sp/univalent">Univalent foundations</a>. We are doing all sorts of things, among others experimenting with type theories. We <a href="http://en.wikipedia.org/wiki/Per_Martin-Löf">have</a> <a href="http://www.cse.chalmers.se/~coquand/">got</a> <a href="http://pauillac.inria.fr/~herbelin/index-eng.html">some</a> <a href="http://mattam.org">real</a> <a href="http://www.lix.polytechnique.fr/~barras/">experts</a> <a href="http://www.lix.polytechnique.fr/~assia/rech-eng.html">here</a> who know type theory and Coq inside out, and much more, and they’re doing crazy things to Coq (I will report on them when they are done). In the meanwhile I have been thinking how one might implement dependent type theories with undecidable type checking. This is a tricky subject and I am certainly not the first one to think about it. Anyhow, if I want to experiment with type theories, I need a small prototype first. Today I will present a very minimal one, and build on it in future posts.</p>
<p>Make a guess, how many lines of code does it take to implement a dependent type theory with universes, dependent products, a parser, lexer, pretty-printer, and a toplevel which uses line-editing when available?</p>
<a onclick="switchContent('post7','post8')" class="btn" href="#82f1b76b57a5bcfd226af67ec43903de">Read more...</a></div><div id="post8" style="display: none"><p>I am spending a semester at the <a href="http://www.ias.edu/">Institute for Advanced Study</a> where we have a special year on <a href="http://www.math.ias.edu/sp/univalent">Univalent foundations</a>. We are doing all sorts of things, among others experimenting with type theories. We <a href="http://en.wikipedia.org/wiki/Per_Martin-Löf">have</a> <a href="http://www.cse.chalmers.se/~coquand/">got</a> <a href="http://pauillac.inria.fr/~herbelin/index-eng.html">some</a> <a href="http://mattam.org">real</a> <a href="http://www.lix.polytechnique.fr/~barras/">experts</a> <a href="http://www.lix.polytechnique.fr/~assia/rech-eng.html">here</a> who know type theory and Coq inside out, and much more, and they’re doing crazy things to Coq (I will report on them when they are done). In the meanwhile I have been thinking how one might implement dependent type theories with undecidable type checking. This is a tricky subject and I am certainly not the first one to think about it. Anyhow, if I want to experiment with type theories, I need a small prototype first. Today I will present a very minimal one, and build on it in future posts.</p>
<p>Make a guess, how many lines of code does it take to implement a dependent type theory with universes, dependent products, a parser, lexer, pretty-printer, and a toplevel which uses line-editing when available?</p>
<p><span id="more-1284"></span>If you ever looked at my <a href="http://andrej.com/plzoo/">Programming languages zoo</a> you know it does not take that many lines of code to implement a toy language. On the other hand, dependent type theory is different from a typical compiler because we cannot meaningfully separate the type checking, compilation, and execution phases.</p>
<p><a href="http://www.cs.cmu.edu/~drl/">Dan Licata</a> pointed me to <a href="http://www.andres-loeh.de/LambdaPi/">A Tutorial Implementation of a Dependently Typed Lambda Calculus</a> by <a href="http://www.andres-loeh.de">Andreas Löh</a>, <a href="http://strictlypositive.org">Connor McBride</a>, and <a href="http://www.staff.science.uu.nl/~swier004/">Wouter Swierstra</a> which is similar to this one. It was a great inspiration to me, and you should have a look at it too, because they do things slightly differently: they use de Bruijn indices, they simplify things by assuming (paradoxically!) that $\mathtt{Type} \in \mathtt{Type}$, and they implement the calculus in <a href="http://www.haskell.org/">Haskell</a>, while we are going to do it in <a href="http://www.ocaml.org/">OCaml</a>.</p>
<h3>A minimal type theory</h3>
<p>I am going to assume you are already familiar with Martin-Löf <a href="http://en.wikipedia.org/wiki/Intuitionistic_type_theory">dependent type theory</a>. We are going to implement:</p>
<ul>
<li>a hierarchy of <a href="http://en.wikipedia.org/wiki/Intuitionistic_type_theory#Universes">universes</a> $\mathtt{Type}_0$, $\mathtt{Type}_1$, $\mathtt{Type}_2$, …</li>
<li><a href="http://en.wikipedia.org/wiki/Intuitionistic_type_theory#.CE.A0-types">dependent products</a> $\prod_{x : A} B$</li>
<li>functions $\lambda x : A . e$, and</li>
<li>application $e_1 \; e_2$.</li>
</ul>
<p>We are not going to write down the exact inference rules, although that would be a good idea in a serious experiment. Instead, we are going to read them off later by looking at the source code.</p>
<h3>Syntax</h3>
<p>We can directly translate the above to <a href="http://en.wikipedia.org/wiki/Abstract_syntax">abstract syntax</a> of expressions (in the code below think of the type <code>variable</code> as string, we will explain it later):</p>
<pre class="brush: plain; title: ; notranslate">(** Abstract syntax of expressions. *)
type expr =
  | Var of variable
  | Universe of int
  | Pi of abstraction
  | Lambda of abstraction
  | App of expr * expr

(** An abstraction [(x,t,e)] indicates that [x] of type [t] is bound in [e]. *)
and abstraction = variable * expr * expr
</pre>
<p>We choose a concrete syntax that is similar to that of <a href="http://coq.inria.fr/">Coq</a>:</p>
<ul>
<li>universes are written <code>Type 0</code>, <code>Type 1</code>, <code>Type 2</code>, …</li>
<li>the dependent product is written <code>forall x : A, B</code>,</li>
<li>a function is written <code>fun x : A =&gt; B</code>,</li>
<li>application is juxtaposition <code>e1 e2</code>.</li>
</ul>
<p>If <code>x</code> does not appear freely in <code>B</code>, then we write <code>A -&gt; B</code> instead of <code>forall x : A, B</code>.</p>
<p>In this tutorial we are not going to learn how to write a lexer and a parser, but see a comment about it below.</p>
<h3>Substitution</h3>
<p>One way or another we have to deal with substitution. We could try to avoid it by compiling into OCaml functions, or we could use de Bruijn indices. The expert opinion is that <a href="http://en.wikipedia.org/wiki/De_Bruijn_index">de Bruijn indices</a> are the way to go, but I want to keep things as simple as possible for now, so let us just implement <a href="http://en.wikipedia.org/wiki/Lambda_calculus#Substitution">substitution</a>.</p>
<p>Substitution must avoid variable capture. This means that we have to be able to generate new variable names. We can do it by simply generating an infinite sequence of them $x_1, x_2, x_3, \ldots$ But what it the user already used $x_3$, then we should not reuse it? To solve the problem we define a datatype of variable names like this:</p>
<pre class="brush: plain; title: ; notranslate">type variable =
 | String of string
 | Gensym of string * int
 | Dummy
</pre>
<p>When the user types <code>x3</code> we represent this as <code>String "x3"</code>, whereas we generate variables of the form <code>Gensym("x",3)</code>. We make sure that the integer is unique, so the variable is fresh. The string is a hint to the pretty-printer, which should try to print the generated variable as the string, if possible. For example, suppose we have a $\lambda$-abstraction</p>
<pre class="brush: plain; title: ; notranslate">Lambda (String "x", ..., ...)
</pre>
<p>and because of substitutions we refreshed the variable to something like</p>
<pre class="brush: plain; title: ; notranslate">Lambda (Gensym("x", 4124), ..., ...)
</pre>
<p>It would be silly to print this as <code>fun x4124 : ... =&gt; ...</code> if we could first rename the bound variable back to <code>x</code>, or to <code>x1</code> if <code>x</code> is taken already. This is exactly what the pretty printer will do.</p>
<p>The <code>Dummy</code> variable is one that is never used. It only appears for the purposes of pretty printing.</p>
<p>Here is the substitution code:</p>
<pre class="brush: plain; title: ; notranslate">(** [refresh x] generates a fresh variable name whose preferred form is [x]. *)
let refresh =
  let k = ref 0 in
    function
      | String x | Gensym (x, _) -&gt; (incr k ; Gensym (x, !k))
      | Dummy -&gt; (incr k ; Gensym ("_", !k))

(** [subst [(x1,e1); ...; (xn;en)] e] performs the given substitution of
    expressions [e1], ..., [en] for variables [x1], ..., [xn] in expression [e]. *)
let rec subst s = function
  | Var x -&gt; (try List.assoc x s with Not_found -&gt; Var x)
  | Universe k -&gt; Universe k
  | Pi a -&gt; Pi (subst_abstraction s a)
  | Lambda a -&gt; Lambda (subst_abstraction s a)
  | App (e1, e2) -&gt; App (subst s e1, subst s e2)

and subst_abstraction s (x, t, e) =
  let x' = refresh x in
    (x', subst s t, subst ((x, Var x') :: s) e)
</pre>
<h3>Type inference</h3>
<p>Our calculus is such that an expression has at most one type, and when it does the type can be inferred from the expression. Therefore, we are going to implement type inference. During inference we need to carry around a context which maps variables to their types. And since we will allow global definitions on the toplevel, the context should also store (optional) definitions. So we define contexts to be <a href="http://en.wikipedia.org/wiki/Association_list">association lists</a>.</p>
<pre class="brush: plain; title: ; notranslate">type context = (Syntax.variable * (Syntax.expr * Syntax.expr option)) list
</pre>
<p>We need functions that lookup up types and values of variables, and one for extending a context with a new variable:</p>
<pre class="brush: plain; title: ; notranslate">(** [lookup_ty x ctx] returns the type of [x] in context [ctx]. *)
let lookup_ty x ctx = fst (List.assoc x ctx)

(** [lookup_ty x ctx] returns the value of [x] in context [ctx], or [None]
    if [x] has no assigned value. *)
let lookup_value x ctx = snd (List.assoc x ctx)

(** [extend x t ctx] returns [ctx] extended with variable [x] of type [t],
    whereas [extend x t ~value:e ctx] returns [ctx] extended with variable [x]
    of type [t] and assigned value [e]. *)
let extend x t ?value ctx = (x, (t, value)) :: ctx
</pre>
<p>Notice that extending with a variable which already appears in the context shadows the old variable, as it should.</p>
<p>We said we would read off the typing rules from the source code:</p>
<pre class="brush: plain; title: ; notranslate">(** [infer_type ctx e] infers the type of expression [e] in context [ctx].  *)
let rec infer_type ctx = function
  | Var x -&gt;
    (try lookup_ty x ctx
     with Not_found -&gt; Error.typing "unkown identifier %t" (Print.variable x))
  | Universe k -&gt; Universe (k + 1)
  | Pi (x, t1, t2) -&gt;
    let k1 = infer_universe ctx t1 in
    let k2 = infer_universe (extend x t1 ctx) t2 in
      Universe (max k1 k2)
  | Lambda (x, t, e) -&gt;
    let _ = infer_universe ctx t in
    let te = infer_type (extend x t ctx) e in
      Pi (x, t, te)
  | App (e1, e2) -&gt;
    let (x, s, t) = infer_pi ctx e1 in
    let te = infer_type ctx e2 in
      check_equal ctx s te ;
      subst [(x, e2)] t
</pre>
<p>Ok, here we go:</p>
<ol>
<li>The type of a variable is looked up in the context.</li>
<li>The type of $\mathtt{Type}_k$ is $\mathtt{Type}_{k+1}$.</li>
<li>The type of $\prod_{x : T_1} T_2$ is $\mathtt{Type}_{\max(k, m)}$ where $T_1$ has type $\mathtt{Type}_k$ and $T_2$ has type $\mathtt{Type}_m$ in the context extended with $x : T_1$.</li>
<li>The type of $\lambda x : T \; . \; e$ is $\prod_{x : T} T’$ where $T’$ is the type of $e$ in the context extended with $x : T$.</li>
<li>The type of $e_1 \; e_2$ is $T[x/e_2]$ where $e_1$ has type $\prod_{x : S} T$ and $e_2$ has type $S$.</li>
</ol>
<p>The typing rules refer to auxiliary functions <code>infer_universe</code>, <code>infer_pi</code>, and <code>check_equal</code>, which we have not defined yet. The function <code>infer_universe</code> infers the type of an expression, makes sure that the type is of the form $\mathtt{Type}_k$, and returns $k$. A common mistake is to think that you can implement it like this:</p>
<pre class="brush: plain; title: ; notranslate">(** Why is this infer_universe wrong? *)
and bad_infer_universe ctx t =
    match infer_type ctx t with
      | Universe k -&gt; u
      | App _ | Var _ | Pi _ | Lambda _ -&gt; Error.typing "type expected"
</pre>
<p>This will not do. For example, what if <code>infer_type ctx t</code> returns the type $(\lambda x : \mathtt{Type}_{4} \; . \; x) \mathtt{Type}_3$? Then <code>infer_universe</code> will complain, because it does not see that the type it got is equal to $\mathtt{Type}_3$, even though it is not syntactically the same expression. We need to insert a normalization procedure which converts the type to a form from which we can read off its shape:</p>
<pre class="brush: plain; title: ; notranslate">(** [infer_universe ctx t] infers the universe level of type [t] in context [ctx]. *)
and infer_universe ctx t =
  let u = infer_type ctx t in
    match normalize ctx u with
      | Universe k -&gt; k
      | App _ | Var _ | Pi _ | Lambda _ -&gt; Error.typing "type expected"
</pre>
<p>We shall implement normalization in a moment, but first we write down the other two auxiliary functions:</p>
<pre class="brush: plain; title: ; notranslate">(** [infer_pi ctx e] infers the type of [e] in context [ctx], verifies that it is
    of the form [Pi (x, t1, t2)] and returns the triple [(x, t1, t2)]. *)
and infer_pi ctx e =
  let t = infer_type ctx e in
    match normalize ctx t with
      | Pi a -&gt; a
      | Var _ | App _ | Universe _ | Lambda _ -&gt; Error.typing "function expected"

(** [check_equal ctx e1 e2] checks that expressions [e1] and [e2] are equal. *)
and check_equal ctx e1 e2 =
  if not (equal ctx e1 e2)
  then Error.typing "expressions %t and %t are not equal" (Print.expr e1) (Print.expr e2)
</pre>
<h3>Normalization and equality</h3>
<p>We need a function <code>normalize</code> which takes an expression and “computes” it, so that we can tell when something is a universe, and when something is a function. There are several strategies on how we might do this, and any will do as long as we have the following property: if $e_1$ and $e_2$ are equal (type theorists say that they are <em>judgmentally equal</em>, or sometimes that they are <em>definitionally equal</em>) then after normalization they should become syntactically equal, up to renaming of bound variables.</p>
<p>Our judgmental equality essentially has just two simple rules, <a href="http://en.wikipedia.org/wiki/Beta_reduction#Reduction">$\beta$-reduction</a> and unfolding of definitions. So this is what the normalization procedure does:</p>
<pre class="brush: plain; title: ; notranslate">(** [normalize ctx e] normalizes the given expression [e] in context [ctx]. It removes
    all redexes and it unfolds all definitions. It performs normalization under binders.  *)
let rec normalize ctx = function
  | Var x -&gt;
    (match
        (try lookup_value x ctx
         with Not_found -&gt; Error.runtime "unkown identifier %t" (Print.variable x))
     with
       | None -&gt; Var x
       | Some e -&gt; normalize ctx e)
  | App (e1, e2) -&gt;
    let e2 = normalize ctx e2 in
      (match normalize ctx e1 with
        | Lambda (x, _, e1') -&gt; normalize ctx (subst [(x,e2)] e1')
        | e1 -&gt; App (e1, e2))
  | Universe k -&gt; Universe k
  | Pi a -&gt; Pi (normalize_abstraction ctx a)
  | Lambda a -&gt; Lambda (normalize_abstraction ctx a)

and normalize_abstraction ctx (x, t, e) =
  let t = normalize ctx t in
    (x, t, normalize (extend x t ctx) e)
</pre>
<p>How about testing for equality of expressions, which was needed in the rule for application? We normalize, then compare for syntactic equality. We make sure that in comparison of abstractions both bound variables are the same:</p>
<pre class="brush: plain; title: ; notranslate">(** [equal ctx e1 e2] determines whether normalized [e1] and [e2] are equal up to renaming
    of bound variables. *)
let equal ctx e1 e2 =
  let rec equal e1 e2 =
    match e1, e2 with
      | Var x1, Var x2 -&gt; x1 = x2
      | App (e11, e12), App (e21, e22) -&gt; equal e11 e21 &amp;&amp; equal e12 e22
      | Universe k1, Universe k2 -&gt; k1 = k2
      | Pi a1, Pi a2 -&gt; equal_abstraction a1 a2
      | Lambda a1, Lambda a2 -&gt; equal_abstraction a1 a2
      | (Var _ | App _ | Universe _ | Pi _ | Lambda _), _ -&gt; false
  and equal_abstraction (x, t1, e1) (y, t2, e2) =
    equal t1 t2 &amp;&amp; (equal e1 (subst [(y, Var x)] e2))
  in
    equal (normalize ctx e1) (normalize ctx e2)
</pre>
<p>And that is it! We have the core of the system written down. The rest is just <a href="http://www.jargon.net/jargonfile/c/chrome.html">chrome</a>: lexer, parser, toplevel, error reporting, pretty printer. Those are the things nobody ever explains because they are boring as soon as you have managed to implement them once. Nevertheless, let us have a brief look. The code is accessible at the Github project <a href="https://github.com/andrejbauer/tt/tree/blog-part-I"><code>andrejbauer/tt</code></a> (the branch <code>blog-part-I</code>).</p>
<h3>The infrastructure</h3>
<h4>Parser: <a href="https://github.com/andrejbauer/tt/blob/blog-part-I/parser.mly"><code>parser.mly</code></a> and <a href="https://github.com/andrejbauer/tt/blob/blog-part-I/lexer.mll"><code>lexer.mll</code></a></h4>
<p>You never ever want to write a parser with your bare hands. Insetad, you should use a <a href="http://en.wikipedia.org/wiki/Compiler-compiler">parser generator</a>. There are many, I used <a href="http://gallium.inria.fr/~fpottier/menhir/">menhir</a>. Parser generators can be a bit scary, but a good way to get started is to take someone else’s parser and fiddle with it.</p>
<h4>Pretty printer: <a href="https://github.com/andrejbauer/tt/blob/blog-part-I/print.ml"><code>print.ml</code></a> and <a href="https://github.com/andrejbauer/tt/blob/blog-part-I/beautify.ml"><code>beautify.ml</code></a></h4>
<p>Pretty printing is the opposite of parsing. In a usual programming language we do not have to print expressions with bound variables (because they get converted to non-printable closures), but here we do. It is worthwhile renaming the bound variables before printing them out, which is what <code>Beautify.beautify</code> does.</p>
<h4>Error reporting: <a href="https://github.com/andrejbauer/tt/blob/blog-part-I/error.ml"><code>error.ml</code></a></h4>
<p>Not surprisingly, errors are reported with exceptions. The only thing to note here is that it should be possible to do pretty printing in error messages, otherwise you will be tempted to produce uninformative error messages. Our implementation of course does that.</p>
<h4>Toplevel: <a href="https://github.com/andrejbauer/tt/blob/blog-part-I/tt.ml"><code>tt.ml</code></a></h4>
<p>The toplevel does nothing suprising. After parsing the command-line arguments and loading files, it enters an interactive toplevel loop. One neat trick that the toplevel does is that it looks for <a href="http://utopia.knoware.nl/~hlub/rlwrap/#rlwrap">rlwrap</a> or <a href="http://pauillac.inria.fr/~ddr/ledit/">ledit</a> and wraps itself with it. This gives us line-editing capabilities for free.</p>
<p>The toplevel commands are:</p>
<ul>
<li><code>Help.</code> print a description of toplevel commands.</li>
<li><code>Context.</code> print current context.</li>
<li><code>Parameter <i>x</i> : <i>t</i>.</code> assume that variable <code><i>x</i></code> has type <code><i>t</i></code>.</li>
<li><code>Definition <i>x</i> := <i>e</i>.</code> define <code><i>x</i></code> to be <code><i>e</i></code>.</li>
<li><code>Check <code><i>e</i></code>.</code> infer the type of <code><i>e</i></code>.</li>
<li><code>Eval <code><i>e</i></code>.</code> normalize <code><i>e</i></code>.</li>
</ul>
<p>Here is a sample session:</p>
<pre class="brush: plain; title: ; notranslate">tt blog-part-I
[Type Ctrl-D to exit or "Help." for help.]
# Parameter N : Type 0.
N is assumed
# Parameter z : N. Parameter s : N -&gt; N.
z is assumed
s is assumed
# Definition three := fun f : N -&gt; N =&gt; fun x : N =&gt; f (f (f x)).
three is defined
# Context.
three = fun f : N -&gt; N =&gt; fun x : N =&gt; f (f (f x))
    : (N -&gt; N) -&gt; N -&gt; N
s : N -&gt; N
z : N
N : Type 0
# Check (three (three s)).
three (three s)
    : N -&gt; N
# Eval (three (three s)) z.
    = s (s (s (s (s (s (s (s (s z))))))))
    : N
</pre>
<h3>Where to go from here?</h3>
<p>The whole program is 618 lines of code, and only 312 if we discount empty lines and comments. The core is just 92 lines, the rest is infrastructure. Not too bad. There are many ways in which we can improve <code>tt</code>, such as:</p>
<ol>
<li>Improve efficiency by implementing de Bruijn indice or some other mechanism that avoids substitutions.</li>
<li>Improve the normalization procedure so that it unfolds definitins on demand, rather than eagerly.</li>
<li>Improve the parser so that it accepts more flexible syntax.</li>
<li>Improve type inference so that not all bound variables have to be explicitly typed.</li>
<li>Add basic datatypes <code>unit</code>, <code>bool</code> and <code>nat</code>.</li>
<li>Add simple products, coproducts and dependent sums.</li>
<li>Implement a cummulative hierachy so that $\mathtt{Type}_k$ is a subtype of $\mathtt{Type}_{k+1}$.</li>
<li>Add inductive datatypes.</li>
<li>Add a stronger judgmental equality, for example $\eta$-reduction.</li>
<li>Implement tactics and an interactive proof mode.</li>
<li>Rule the world.</li>
</ol>
<p>I may do some of these in subsequent blog posts, if there is interest. Or if you do it, make a pull request on git and write a guest blog post!</p><a onclick="switchContent('post8','post7')" class="btn" href="#82f1b76b57a5bcfd226af67ec43903de">Hide</a></div></span>
<a name="c9dff814a3f828b079d606253d06c218"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/~scherer/gagallium/resolving-field-names/index.html"> Using well-disciplined type-propagation to disambiguate label and constructor names</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">07 Nov 2012</span></span><span class="rss-description"><div id="post9"><p>An explanation of the <a href="http://caml.inria.fr/mantis/view.php?id=5759">raging
discussion</a> that has
taken place on the OCaml bugtracker about new ways to resolve record
fields and variant constructor names using type information. Read more
for a presentation of the different proposals and an explanation of the
consensus reached.</p>




<h2>Resolving record fields and variant constructors in OCaml today</h2>

<p>Today, when you write an access to a record field/label <code>r.l</code>, the
OCaml type-checker will look for what the label <code>l</code> means. If your
code is correct, it will find in the typing environment that the label
<code>l</code> corresponds to some record type <code>t</code> (defined as a record of the
form <code>{...; l:foo; ...}</code>), infer that the expression <code>r</code> must have
type <code>t</code>, and that the return type of <code>r.l</code> must be the type of the
field <code>l</code> in <code>t</code> (<code>foo</code> in our example).</p>

<p></p><pre class="code-ocaml"></pre><div># <span class="hl kwa">type</span> t <span class="hl opt">= {</span>l1 <span class="hl opt">:</span> <span class="hl kwc">int</span><span class="hl opt">;</span> l2<span class="hl opt">:</span> <span class="hl kwc">bool</span><span class="hl opt">};;</span>
</div><div class="ocaml-toplevel">type t = { l1 : int; l2 : bool; }</div><div># <span class="hl kwa">let</span> test r <span class="hl opt">=</span> r<span class="hl opt">.</span>l1<span class="hl opt">;;</span>
</div><div class="ocaml-toplevel">val test : t -&gt; int = &lt;fun&gt;</div><p></p>

<a onclick="switchContent('post9','post10')" class="btn" href="#c9dff814a3f828b079d606253d06c218">Read more...</a></div><div id="post10" style="display: none"><p>An explanation of the <a href="http://caml.inria.fr/mantis/view.php?id=5759">raging
discussion</a> that has
taken place on the OCaml bugtracker about new ways to resolve record
fields and variant constructor names using type information. Read more
for a presentation of the different proposals and an explanation of the
consensus reached.</p>




<h2>Resolving record fields and variant constructors in OCaml today</h2>

<p>Today, when you write an access to a record field/label <code>r.l</code>, the
OCaml type-checker will look for what the label <code>l</code> means. If your
code is correct, it will find in the typing environment that the label
<code>l</code> corresponds to some record type <code>t</code> (defined as a record of the
form <code>{...; l:foo; ...}</code>), infer that the expression <code>r</code> must have
type <code>t</code>, and that the return type of <code>r.l</code> must be the type of the
field <code>l</code> in <code>t</code> (<code>foo</code> in our example).</p>

<p></p><pre class="code-ocaml"></pre><div># <span class="hl kwa">type</span> t <span class="hl opt">= {</span>l1 <span class="hl opt">:</span> <span class="hl kwc">int</span><span class="hl opt">;</span> l2<span class="hl opt">:</span> <span class="hl kwc">bool</span><span class="hl opt">};;</span>
</div><div class="ocaml-toplevel">type t = { l1 : int; l2 : bool; }</div><div># <span class="hl kwa">let</span> test r <span class="hl opt">=</span> r<span class="hl opt">.</span>l1<span class="hl opt">;;</span>
</div><div class="ocaml-toplevel">val test : t -&gt; int = &lt;fun&gt;</div><p></p>

<p>In case you have actually defined <code>t</code> and its labels not in the
current module but in a sub-module that has not been opened, you need
to prefix the label with the module name.
</p><pre class="code-ocaml"></pre><div># <span class="hl kwa">module</span> <span class="hl kwd">P</span> <span class="hl opt">=</span> <span class="hl kwa">struct</span>
    <span class="hl kwa">type</span> t <span class="hl opt">= {</span>l1 <span class="hl opt">:</span> <span class="hl kwc">int</span><span class="hl opt">;</span> l2<span class="hl opt">:</span> <span class="hl kwc">bool</span><span class="hl opt">}</span>
  <span class="hl kwb">end</span><span class="hl opt">;;</span>
</div><div class="ocaml-toplevel">module P : sig type t = { l1 : int; l2 : bool; } end</div><div># <span class="hl kwa">let</span> test r <span class="hl opt">=</span> r<span class="hl opt">.</span><span class="hl kwd">P</span><span class="hl opt">.</span>l1<span class="hl opt">;;</span>
</div><div class="ocaml-toplevel">val test : P.t -&gt; int = &lt;fun&gt;</div><p></p>

<p>Symmetrically, when constructing a record, OCaml will look at the
labels to determine the type of the whole expression. <code>{P.l1 = 1; P.l2 =
true}</code> will be inferred at type <code>P.t</code>. The exact same story holds for
variant/sum types: if you write <code>Some 12</code>, OCaml will look in the
typing environment for the type having constructor <code>Some</code> (it is the
builtin type <code>'a option</code>), and infer the result type <code>int
option</code>. Symmetrically, when pattern matching (<code>match v with None -&gt;
true | Some _ -&gt; false</code>), it checks that <code>v</code> indeed has an option
type.</p>

<p>Note that this is fundamentally different from how ocaml <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual005.html">objects</a>
and <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual006.html#toc36">polymorphic variants</a> work. They are open, extensible types,
you do not need to have defined types with a given method or
polymorphic variant tag to use it.</p>

<p></p><pre class="code-ocaml"></pre><div># <span class="hl kwa">let</span> get_m <span class="hl opt">=</span> <span class="hl kwa">fun</span> o <span class="hl opt">-&gt;</span> o#m<span class="hl opt">;;</span>
</div><div class="ocaml-toplevel">val get_m : &lt; m : 'a; .. &gt; -&gt; 'a = &lt;fun&gt;</div><div># <span class="hl kwa">let</span> foo <span class="hl opt">=</span> `<span class="hl kwd">Foo</span> <span class="hl kwc">true</span><span class="hl opt">;;</span>
</div><div class="ocaml-toplevel">val foo : [&gt; `Foo of bool ] = `Foo true</div><p></p>

<p>To infer the type for <code>get_m</code>, the type checker didn't have to know
"which type" had a method named <code>m</code>: it works for any object type with
such a method. Similarly, the <code>[&gt;</code> in the type of <code>foo</code> indicate that
this value has a polymorphic type: it is not typed with a particular
sum type having the constructor <code>`Foo</code>, but is of the type of <em>any</em>
polymorphic variant having at least a constructor <code>`Foo</code> with
a single parameter of type <code>bool</code>.</p>

<p>One way to say this is that methods have "polymorphic" access (they
can work on any types with that has this method) while record fields
have "monomorphic" access: they denote a field in a unique,
well-determined record type that has this label.</p>

<p>(In this regard, variant constructors behave like record fields, and
polymorphic variant tags behave like object methods. This will be the
case during much of the discussion, so I won't repeat it and keep
talking about fields, while I really mean to discuss both record
fields and variant constructors.)</p>

<p>In particular, it does not make sense to prefix a method name with
a module (<code>o#P.m</code>), because the method name <code>m</code> does not have a "point
of definition" that would be in a module, it is a global name. The
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual011.html#field">OCaml manual says</a> that record fields are "named
objects" that may be prefixed by an access path of one or several
module names, while method names are "global labels" that "need not be
qualified".</p>

<p>There are two perceived issues with the current state of how field
access is type-checked, that led to this discussion of how to add
a new feature to alleviate them.</p>

<h3>Problem 1: Writing module prefixes can be inconvenient</h3>

<p>If the type of the record you're trying to build is named in the
submodule <code>Bar</code> of the module <code>Foo</code>, building a value with
<code>{Foo.Bar.l1 = ...; Foo.Bar.l2 = ...}</code> can be inconvenient. Similarly,
pattern matching with two cases, one on the constructor <code>Foo.Bar.Var
x</code> and the other on <code>Foo.Bar.App (a,b)</code> is redundant and painful.</p>

<p>In the case of record construction, this problem has been solved (in
3.12 I believe) by allowing to prefix only one of the labels, instead
of all the labels: it is legal OCaml to only write <code>{Foo.Bar.l1 = ...;
l2 = ...}</code>, the type-checker will notice that you gave the full name
for one of the fields (not necessarily the first one) and not
complain.</p>

<p>Perhaps strangely, this feature has not been implemented for variant
pattern matching. But since 3.12, thanks to Alain Frisch's feature
proposal, you can locally open modules <code>let open Foo.Bar in ...</code> or
even <code>Foo.Bar.( ... )</code> around expressions using those labels or
constructors. Compared to global open, this avoids some environment
pollution, but you still get a lot of names imported in your scope
(that may shadow names in your environment) when you only wanted to
speak about those damn variant constructors.</p>

<h3>Problem 2: Label shadowing is possible and extremely awkward</h3>

<p>You are allowed to define two types that share some record names in
the same module.</p>

<div>
<pre class="code-ocaml"></pre><div><span class="hl kwa">type</span> t1 <span class="hl opt">= {</span> foo <span class="hl opt">:</span> char<span class="hl opt">;</span> bar <span class="hl opt">:</span> <span class="hl kwc">bool</span> <span class="hl opt">}</span>
<span class="hl kwa">let</span> make_t1 foo bar <span class="hl opt">= {</span> foo<span class="hl opt">;</span> bar <span class="hl opt">}</span>

<span class="hl kwa">type</span> t2 <span class="hl opt">= {</span> foo <span class="hl opt">:</span> <span class="hl kwc">bool</span><span class="hl opt">;</span> baz <span class="hl opt">:</span> <span class="hl kwc">int</span> <span class="hl opt">}</span>
<span class="hl kwa">let</span> make_t2 foo baz <span class="hl opt">= {</span> foo<span class="hl opt">;</span> baz <span class="hl opt">};;</span>
</div>
</div>

<p>(The feature I used in the <code>make_..</code> functions is record field
punning, where at record creation time <code>foo;</code> is syntactic sugar for
<code>foo = foo</code>. You may not know that if your record is defined in
a submodule <code>P</code>, then <code>let (foo, bar) = (1, true) in {P.foo; bar}</code>
will do the right thing.)</p>

<p>If you do that, you end up in an uncomfortable situation where you may
create value at types <code>t1</code> or <code>t2</code>, but you cannot access the field
<code>foo</code> of the type <code>t1</code> anymore: it has been shadowed by the definition
of <code>t2</code>. If you use the label <code>foo</code> anywhere in your program after
those definitions, it may only mean the label <code>foo</code> <em>of <code>t2</code></em>.</p>

<div>
<pre class="code-ocaml"></pre><div># <span class="hl kwa">let</span> get_bar r <span class="hl opt">=</span> r<span class="hl opt">.</span>bar<span class="hl opt">;;</span>
</div><div class="ocaml-toplevel">val get_bar : t1 -&gt; bool = &lt;fun&gt;</div><div># <span class="hl kwa">let</span> get_foo_and_bar r <span class="hl opt">= (</span>r<span class="hl opt">.</span>foo<span class="hl opt">,</span> r<span class="hl opt">.</span>bar<span class="hl opt">);;</span>
</div><div class="ocaml-toplevel ocaml-exc">Line 1, characters 32-33:
Error: This expression has type t2 but an expression was expected of type t1</div>
</div>

<p>Note that there is an interaction between those two issues: to avoid
writing qualified labels, you can <code>open</code> the modules in which the
labels are defined. But if you open two (sub)modules that share some
labels, you get into the shadowing problem. To avoid shadowing, you
need to use long names more often than you would like. One typical
example is the following, where you translate from some form of
Abstract Syntax Tree (AST) to another, that have been defined in
different modules but share some natural constructor names:</p>

<div>


<pre class="code-ocaml"><span class="hl kwa">let rec</span> type_check env <span class="hl opt">:</span> <span class="hl kwd">UntypedAst</span><span class="hl opt">.</span>expr <span class="hl opt">-&gt;</span> <span class="hl kwd">TypedAst</span><span class="hl opt">.</span>expr <span class="hl opt">*</span> <span class="hl kwd">Type</span><span class="hl opt">.</span>t <span class="hl opt">=</span>
  <span class="hl kwa">function</span>
  | <span class="hl kwd">UntypedAst</span><span class="hl opt">.</span><span class="hl kwd">Var</span> x <span class="hl opt">-&gt;</span>
      <span class="hl opt">(</span><span class="hl kwd">TypedAst</span><span class="hl opt">.</span><span class="hl kwd">Var</span> x<span class="hl opt">,</span> lookup x env<span class="hl opt">)</span>
  | <span class="hl opt">...</span>
</pre>


</div>

<p>One may open either <code>UntypedAst</code> or <code>TypedAst</code> or both, but for
conflicting constructor names (<code>Var</code>, <code>App</code>...) only those of the
module opened last can be used unqualified. Short of using polymorphic
variants to avoid this issue, the idiomatic solution is to prefix such
constructor names with a letter, for example <code>UVar</code> in <code>UntypedAst</code>
and <code>TVar</code> in <code>TypedAst</code> to be able to open them both without
shadowing. This is a specialized example of the real-world cases
(syntax transformations) that Alain is considering problematic in
OCaml today.</p>

<h2>The two competing feature proposal</h2>

<h3>Fixing problem 1: the scope-inferring proposal</h3>

<p>Jacques Garrigue (re)started the discussion with a rather simple
change proposal for the type-checker that had the following effect: if
type information is available, the type-checker guesses the module
prefix that needs not be written explicitly. This was merely a simple
prototype to explore the subject, and Jacques expected the final
semantics to be different; but this initial proposal is still
important to understand the design space.</p>

<p>Consider the following example:</p>

<div>


<pre class="code-ocaml"><span class="hl kwa">module</span> <span class="hl kwd">Foo</span> <span class="hl opt">=</span> <span class="hl kwa">struct</span>
  <span class="hl kwa">type</span> t <span class="hl opt">= {</span>l1 <span class="hl opt">:</span> <span class="hl kwc">int</span><span class="hl opt">;</span> l2 <span class="hl opt">:</span> <span class="hl kwc">int</span><span class="hl opt">}</span>
<span class="hl kwb">end</span>

<span class="hl kwa">let</span> tuple <span class="hl opt">(</span>r <span class="hl opt">:</span> <span class="hl kwd">Foo</span><span class="hl opt">.</span>t<span class="hl opt">) = (</span>r<span class="hl opt">.</span><span class="hl kwd">Foo</span><span class="hl opt">.</span>l1<span class="hl opt">,</span> r<span class="hl opt">.</span><span class="hl kwd">Foo</span><span class="hl opt">.</span>l2<span class="hl opt">)</span>
</pre>


</div>

<p>With this scope-inferring proposal, <code>tuple</code> can be simply written</p>

<div>


<pre class="code-ocaml"><span class="hl kwa">let</span> tuple <span class="hl opt">(</span>r <span class="hl opt">:</span> <span class="hl kwd">Foo</span><span class="hl opt">.</span>t<span class="hl opt">) = (</span>r<span class="hl opt">.</span>l1<span class="hl opt">,</span> r<span class="hl opt">.</span>l2<span class="hl opt">)</span>
</pre>


</div>

<p>The labels <code>l1</code> and <code>l2</code> appear to be unknown (note that we did not
<code>open</code> the module <code>Foo</code>), but type information is available and the
type-checker can rewrite it into the previous form.</p>

<p>While this proposal doesn't directly help with the problem of label
shadowing, it can be used to work around it. Indeed, we can rewrite
the previous conflicting example into:</p>

<div>


<pre class="code-ocaml"><span class="hl kwa">module</span> <span class="hl kwd">M</span> <span class="hl opt">=</span> <span class="hl kwa">struct</span>
  <span class="hl kwa">type</span> t1 <span class="hl opt">= {</span> foo <span class="hl opt">:</span> char<span class="hl opt">;</span> bar <span class="hl opt">:</span> <span class="hl kwc">bool</span> <span class="hl opt">}</span>
<span class="hl kwb">end</span>
<span class="hl kwa">module</span> <span class="hl kwd">N</span> <span class="hl opt">=</span> <span class="hl kwa">struct</span>
  <span class="hl kwa">type</span> t2 <span class="hl opt">= {</span> foo <span class="hl opt">:</span> <span class="hl kwc">bool</span><span class="hl opt">;</span> baz <span class="hl opt">:</span> <span class="hl kwc">int</span> <span class="hl opt">}</span>
<span class="hl kwb">end</span>
<span class="hl kwa">open</span> <span class="hl kwd">M</span>
<span class="hl kwa">open</span> <span class="hl kwd">N</span>

<span class="hl kwa">let</span> get_foo_and_bar <span class="hl opt">(</span>r <span class="hl opt">:</span> t1<span class="hl opt">) = (</span>r<span class="hl opt">.</span>foo<span class="hl opt">,</span> r<span class="hl opt">.</span>bar<span class="hl opt">)</span>
</pre>


</div>

<p>I have wrapped the two conflicting record declarations into distinct
submodules. Then, by providing a type annotation <code>(r : t1)</code>, we can
access <code>r.foo</code> which is understood as <code>r.M.foo</code>. In a sense, the
non-ambiguous prefix <code>M</code> was inferred.</p>

<p>This also works naturally in the AST transformation example, as the
conflicting labels are already defined in distinct submodules. With
this proposal you could then write the following:</p>

<div>


<pre class="code-ocaml"><span class="hl kwa">let rec</span> type_check env <span class="hl opt">:</span> <span class="hl kwd">UntypedAst</span><span class="hl opt">.</span>expr <span class="hl opt">-&gt;</span> <span class="hl kwd">TypedAst</span><span class="hl opt">.</span>expr <span class="hl opt">*</span> <span class="hl kwd">Type</span><span class="hl opt">.</span>t <span class="hl opt">=</span>
  <span class="hl kwa">function</span>
  | <span class="hl kwd">Var</span> x <span class="hl opt">-&gt; (</span><span class="hl kwd">Var</span> x<span class="hl opt">,</span> lookup x env<span class="hl opt">)</span>
  | <span class="hl opt">...</span>
</pre>


</div>

<p>One downside of this proposal is that may not be obvious to understand
which module prefixes are inferred (type information can flow from
less explicit places such as function applications or annotations that
are far away); an user that has been used to the idea that labels
appearing unqualified in the code are available in the naming
environment can be surprised and have a difficulty finding the
definition place of the labels/constructors -- specialized tooling
such as Jun Furuse's
<a href="https://bitbucket.org/camlspotter/ocamlspot">ocamlspotter</a> could help
with this issue.</p>

<p>On the other front, this proposal is not intended to help with the
problem 2 of conflicting labels, and the possible workaround is not
terribly convenient. Alain Frisch, in his local variant of the OCaml
language at Lexifi, has been using conflict-solving strategies for
a long time, and was asking for a change that would address this
problem as well.</p>

<h3>Fixing problem 2: the conflict-solving proposal</h3>

<p>Solving conflicting label names is another way to use type
information. Remember the initial wrong example:</p>

<div>


<pre class="code-ocaml"><span class="hl kwa">type</span> t1 <span class="hl opt">= {</span> foo <span class="hl opt">:</span> char<span class="hl opt">;</span> bar <span class="hl opt">:</span> <span class="hl kwc">bool</span> <span class="hl opt">}</span>
<span class="hl kwa">type</span> t2 <span class="hl opt">= {</span> foo <span class="hl opt">:</span> <span class="hl kwc">bool</span><span class="hl opt">;</span> baz <span class="hl opt">:</span> <span class="hl kwc">int</span> <span class="hl opt">}</span>

<span class="hl kwa">let</span> get_foo_and_bar <span class="hl opt">(</span>r <span class="hl opt">:</span> t1<span class="hl opt">) = (</span>r<span class="hl opt">.</span>foo<span class="hl opt">,</span> r<span class="hl opt">.</span>bar<span class="hl opt">)</span>
</pre>


</div>

<p>In this situation, the type-checker knows when checking <code>r.foo</code> that
<code>r</code> has type <code>t1</code>, and could resolve the field access as meaning "the
field <code>foo</code> of <code>t1</code>" rather than using the shadowing rule (the last
field <code>t1</code> defined or opened in the naming environment). We could
write this explicitly by an imaginary extension of the OCaml syntax,
where the label <code>l</code> at type <code>t</code> would be written <code>l^t</code>. In our
example, the type-checker could disambiguate <code>r.foo</code> into <code>r.foo^t1</code>.</p>

<p>This proposal corresponds to a rather unoriginal treatment of
type-directed overloading: some restricted class of identifiers is
considered to have potentially several simultaneous meanings, and
a type-directed disambiguation strategy is applied. Labels are "named
objects" and resolved as such; on the other hand, restricting the
potential ambiguities to only labels (and variant constructors) limits
the scope of the ambiguity and its potential dangers of making the
code harder to read.</p>

<p>A similar feature exists in the Agda programming language, where
constructor names do not follow a strict shadowing discipline but may
be disambiguated by typing. This is very convenient in a dependently
typed language where the current techniques to ornaments of data
structures is to define several versions of the same inductive type
with varying degrees of type information.</p>

<p>This proposal doesn't directly address the problem 1: if <code>t1</code> and <code>t2</code>
were both defined in a submodule <code>P</code>, you would still need to write
<code>(r.P.foo, r.P.bar)</code>; the type information is only used to
disambiguate between the two candidate labels <code>foo^(P.t1)</code> and
<code>foo^(P.t2)</code>.</p>

<p>This feature also works if the two types added to the unqualified scope
came from different modules. Therefore it help solve the problem of
having to prefix labels by their module paths. Indeed, you can then
<code>open</code> the corresponding modules, and use type-based disambiguation to
avoid the shadowing problem. For example you could write:</p>

<div>


<pre class="code-ocaml"><span class="hl kwa">let rec</span> type_check env <span class="hl opt">:</span> <span class="hl kwd">UntypedAst</span><span class="hl opt">.</span>expr <span class="hl opt">-&gt;</span> <span class="hl kwd">TypedAst</span><span class="hl opt">.</span>expr <span class="hl opt">*</span> <span class="hl kwd">Type</span><span class="hl opt">.</span>t <span class="hl opt">=</span>
  <span class="hl kwa">let open</span> <span class="hl kwd">UntypedAst</span> <span class="hl kwa">in</span>
  <span class="hl kwa">let open</span> <span class="hl kwd">TypedAst</span> <span class="hl kwa">in</span>
  <span class="hl kwa">function</span>
  | <span class="hl kwd">Var</span> x <span class="hl opt">-&gt; (</span><span class="hl kwd">Var</span> x<span class="hl opt">,</span> lookup x env<span class="hl opt">)</span>
  | <span class="hl opt">...</span>
</pre>


</div>

<p>and have it disambiguated into</p>

<div>


<pre class="code-ocaml"><span class="hl kwa">let rec</span> type_check env <span class="hl opt">:</span> <span class="hl kwd">UntypedAst</span><span class="hl opt">.</span>expr <span class="hl opt">-&gt;</span> <span class="hl kwd">TypedAst</span><span class="hl opt">.</span>expr <span class="hl opt">*</span> <span class="hl kwd">Type</span><span class="hl opt">.</span>t <span class="hl opt">=</span>
  <span class="hl kwa">let open</span> <span class="hl kwd">UntypedAst</span> <span class="hl kwa">in</span>
  <span class="hl kwa">let open</span> <span class="hl kwd">TypedAst</span> <span class="hl kwa">in</span>
  <span class="hl kwa">function</span>
  | <span class="hl kwd">Var</span>^<span class="hl opt">(</span><span class="hl kwd">UntypedAst</span><span class="hl opt">.</span>expr<span class="hl opt">)</span> x <span class="hl opt">-&gt;</span>
      <span class="hl opt">(</span><span class="hl kwd">Var</span>^<span class="hl opt">(</span><span class="hl kwd">TypedAst</span><span class="hl opt">.</span>expr<span class="hl opt">)</span> x<span class="hl opt">,</span> lookup x env<span class="hl opt">)</span>
  | <span class="hl opt">...</span>
</pre>


</div>

<p>It is more explicit than the scope-inferring proposal as to where the
labels are defined. Compared to this example with the scope-inferring
proposal, we had to use two <code>open</code> directives that explicitly enrich
the naming environment.</p>

<p>Note that while the explicit syntax <code>r.P.l^t</code> is not available in
OCaml, this proposal adds a way to express it: you can write
<code>(r:t).P.l</code>, where the type annotation <code>(r:t)</code> guarantees that
type-based disambiguation will work. This proposal is therefore
strictly more convenient than adding <code>r.P.l^t</code> alone: you can have the
type annotation somewhere close (the type information is propagated),
as in my <code>type_check</code> example where I annotate the whole function
rather than each constructor.</p>

<p>Still, the scope-inferring proposal had the nice property that the
result of the disambiguation could be expressed as an explicit OCaml
program without type annotations, by adding the inferred module
prefixes. In absence of the explicit <code>l^t</code> syntax, this proposal
doesn't have this desirable property. More generally, it adds a form
of syntactic overloading, which has been carefully avoided in the
design of OCaml so far.</p>

<h2>Choices, consequences and compromises</h2>

<p>The argument in favor of the scope-inferring proposal is that you need
to write less code, in situations where the conflict-solving proposal
would require either an <code>open</code> (with the associated environment
pollution risk) or an explicit module prefix.</p>

<p>The converse argument supports the conflict-solving proposal: by
requiring to be strictly more explicit in terms of which labels are
meant, programs are easier to read and more robust to change of type
information (removal of an annotation, etc.). In particular, the
"specific semantics" introduced by the proposal would only kick in
when two labels exist in the same scope, instead of being a general
way to shorten label denotations: you only pay (in complexity of the
part of system that needs to be explained to understand the program)
in the already-fishy case where label shadowing happens.</p>

<p>In the bugtracker discussion, Jacques was in favor of the
scope-inferring proposal, Alain wished to have both proposals
implemented, while Leo P. White and myself were in favor of the
conflict-solving proposal only. After some time to reach convergence,
the arguments on all sides were well-understood, and there remained
a difference of opinion that couldn't be resolved (no pun intended) by
objective arguments. Jacques and Alain carry a lot of weight in the
discussion, as Jacques is the maintainer of the type-checker code
(and is therefore the person that ultimately has a say on the matter),
and Alain has implemented and used (a variant of) the two proposals in
his own dialect of the OCaml language used at Lexifi. Leo opinion was
also important in keeping the discussion open, as he is one of the few
brave souls to have worked on the type-checker code to implement his
external <a href="https://sites.google.com/site/ocamlopen/">extensible open
datatypes</a> proposal
for OCaml).</p>

<p>I don't want to give the impression that this is only a matter of
blunt opinion and authority: there were theoretical arguments on the
side of both proposals, but I don't know how to sum them up concisely
so they will be the topic of a <a href="http://gallium.inria.fr/~scherer/gagalliumresolving-field-names-2/">second, more technical blog
post</a>.</p>

<p>In the end, the following compromise made consensus : implement both
type-directed disambiguation strategies (scope inference and label
conflict resolution) as a way to subsume both proposals, but raise
a warning when scope inference has an effect. By treating this warning
as an error, you get exactly the conflict-solving proposal. By
disabling this warning, you get the union of the conflict-solving and
scope-inferring proposal.</p>

<p>The implementation of this feature is surprisingly tricky and Jacques
and Leo are discussing back-and-forth on how to do that
properly. While I don't have enough information to give any guarantee
on this (the proposal may still be rejected by other developers
feeling the feature is too adventurous, and indeed it seems
quite complex), I would not be surprised to see this compromise
effectively available in the next major version of OCaml
(4.01)... maybe.</p>

<p>That's it!</p>

<p>PS: after this post, you may also want to read the <a href="http://gallium.inria.fr/~scherer/gagallium/resolving-field-names-2/">second
post</a> for a more technical
exposition of the details and design arguments.</p><a onclick="switchContent('post10','post9')" class="btn" href="#c9dff814a3f828b079d606253d06c218">Hide</a></div></span>
<script type="text/javascript">function switchContent(id1,id2) {
     // Get the DOM reference
     var contentId1 = document.getElementById(id1);
     var contentId2 = document.getElementById(id2);
     // Toggle
     contentId1.style.display = "none";
     contentId2.style.display = "block";
     }</script></div>

  
    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
</body></html>
