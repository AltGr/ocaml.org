<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: OCaml Planet</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contributors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="OCaml Planet" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it Online</a></li>
    <li><a href="../taste.html">100 Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who Is Using It?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a>
        <a href="http://langref.org/ocaml">langref.org</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
    <li><a href="../papers.html">Papers</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../releases/">Releases</a></li>
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development Tools</a></li>
    <li><a href="../books.html#manual">User Manual</a></li>
    <li><a href="../cheat_sheets.html">Cheat Sheets</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API Search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">GitHub</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing Lists</a></li>
    <li><a href="../planet/">Blogs</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>OCaml Planet
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

    <h1>OCaml Planet</h1>

    <p>The OCaml Planet aggregates various blogs from the OCaml
    community.  It is kindly provided
    by <a href="http://www.ocamlcore.com/">OCamlCore</a>.  If you
    would like to be added, read
    the <a href="http://www.ocamlcore.org/planet/">Planet
    subscription HOWTO</a>.</p>

    <br/>
    <div style="float: right; margin-right: 0; margin-top: 0" class="span2 planet-subscriptions"><em>Subscriptions</em>
      <ul><li><a href="http://alexleighton.tumblr.com/tagged/ocaml/rss">Alex Leighton</a></li><li><a href="http://blog.mestan.fr/feed/?cat=16">Alp Mestan</a></li><li><a href="http://andreiformiga.com/blog/?cat=5&feed=rss2">Andrei Formiga</a></li><li><a href="http://math.andrej.com/feed/">Andrej Bauer</a></li><li><a href="http://anil.recoil.org/feeds/atom.xml">Anil Madhavapeddy</a></li><li><a href="http://unnali.com/tag/ocaml/feed/">Arlen Cuss</a></li><li><a href="http://ashishagarwal.org/tag/ocaml/feed/">Ashish Agarwal</a></li><li><a href="http://www.blogger.com/feeds/7617521785419311079/posts/default">Cameleon news</a></li><li><a href="http://caml.inria.fr/news.en.rss">Caml INRIA</a></li><li><a href="http://camlspotter.blogspot.com/feeds/posts/default?alt=rss">Caml Spotting</a></li><li><a href="http://alan.petitepomme.net/cwn/cwn.rss">Caml Weekly News</a></li><li><a href="http://procrastiblog.com/category/ocaml/feed/">Christopher Conway</a></li><li><a href="http://coherentpdf.com/blog/?tag=ocaml&feed=rss">Coherent Graphics</a></li><li><a href="http://coq.inria.fr/news/feed">Coq</a></li><li><a href="http://erratique.ch/feeds/news.atom">Daniel Bünzli</a></li><li><a href="http://blog.dbpatterson.com/rss">Daniel Patterson</a></li><li><a href="http://nleyten.com/atom.aspx">Dario Teixeira</a></li><li><a href="http://www.blogger.com/feeds/17133288/posts/default/-/ocaml">David Baelde</a></li><li><a href="http://bentobako.org/david/blog/index.php?feed/tag/ocaml/atom">David Mentré</a></li><li><a href="http://dutherenverseauborddelatable.wordpress.com/category/ocaml/feed/">David Teller</a></li><li><a href="http://www.examachine.net/blog/?feed=rss2&cat=4">Eray Özkural</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/CodeHacking/Ocaml/index.rss20">Erik de Castro Lopo</a></li><li><a href="http://blog.emillon.org/feeds/ocaml.xml">Etienne Millon</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/FP-Syd/index.rss20">FP-Sydney</a></li><li><a href="http://www.blogger.com/feeds/8964007124326996693/posts/default/-/ocaml">Fayssal Martani</a></li><li><a href="http://frama-c.com/rss.xml">Frama-C</a></li><li><a href="http://functionaljobs.com/jobs/search/?q=ocaml&format=rss">Functional Jobs</a></li><li><a href="http://gallium.inria.fr/blog/index.rss">GaGallium</a></li><li><a href="http://gaiustech.wordpress.com/category/ocaml/feed/">Gaius Hammond</a></li><li><a href="http://blog.camlcity.org/blog/rss">Gerd Stolpmann</a></li><li><a href="http://www.wisdomandwonder.com/tag/OCaml/feed">Grant Rettke</a></li><li><a href="http://hongboz.wordpress.com/feed/">Hong bo Zhang</a></li><li><a href="http://blog.incubaid.com/tag/ocaml/feed/">Incubaid Research</a></li><li><a href="http://ambassadortothecomputers.blogspot.com/feeds/posts/default?alt=rss">Jake Donham</a></li><li><a href="http://scattered-thoughts.net/rss?tag=ocaml">Jamie Brandon</a></li><li><a href="http://ocaml.janestcapital.com/?q=rss.xml">Jane Street</a></li><li><a href="http://lpw25.net/rss.xml">Leo White</a></li><li><a href="http://www.lexifi.com/blogs/ocaml/feed">LexiFi</a></li><li><a href="http://savonet.sourceforge.net/liquidsoap.rss">Liquidsoap</a></li><li><a href="http://syntaxexclamation.wordpress.com/tag/ocaml/feed/">Matthias Puech</a></li><li><a href="http://www.blogger.com/feeds/5888658295182480819/posts/default">Matías Giovannini</a></li><li><a href="http://eigenclass.org/R2/feeds/rss2/all">Mauricio Fernandez</a></li><li><a href="http://www.elehack.net/michael/blog/tags/ocaml?format=rss">Michael Ekstrand</a></li><li><a href="http://www.rktmb.org:82/feed/category/work/ocaml/atom">Mihamina Rakotomandimby</a></li><li><a href="http://mcclurmc.wordpress.com/feed/">Mike McClurg</a></li><li><a href="http://nyc-ocaml.posterous.com/rss.xml">NYC OCaml</a></li><li><a href="http://ocamlhackers.ning.com/profiles/blog/feed?tag=ocaml&xn_auth=no">OCaml Hackers</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfnews.php">OCamlCore Forge News</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfprojects.php">OCamlCore Forge Projects</a></li><li><a href="http://www.ocamlcore.com/wp/?feed=rss2&amp;language=en&#038;language=en">OCamlCore.com</a></li><li><a href="http://www.ocamlpro.com/feed/atom.xml">OCamlPro</a></li><li><a href="http://odns.tuxfamily.org/feed/">ODNS project</a></li><li><a href="http://ox.tuxfamily.org/feed/">Ocaml XMPP project</a></li><li><a href="http://ocsigen.org/news.atom">Ocsigen project</a></li><li><a href="http://www.blogger.com/feeds/2073503406800427577/posts/default">Opa</a></li><li><a href="http://www.openmirage.org/blog/atom.xml">Open Mirage</a></li><li><a href="http://functional-orbitz.blogspot.com/feeds/posts/default/-/planetocaml?alt=rss">Orbitz</a></li><li><a href="http://www.donadeo.net/facets/programming-languages/objective-caml/feed/">Paolo Donadeo</a></li><li><a href="https://mancoosi.org/~abate/taxonomy/term/5/0/feed">Pietro Abate</a></li><li><a href="http://redlizards.com/blog/feed/?tag=ocaml">Red Lizard Software</a></li><li><a href="http://rwmj.wordpress.com/tag/ocaml/feed/">Richard Jones</a></li><li><a href="http://blog.rastageeks.org/spip.php?page=rss&id_mot=2">Romain Beauxis</a></li><li><a href="http://seb.mondet.org/blog/feed/ocaml.rss">Sebastien Mondet</a></li><li><a href="http://upsilon.cc/~zack/tags/ocaml/index.rss">Stefano Zacchiroli</a></li><li><a href="http://le-gall.net/sylvain+violaine/blog/index.php?feed/tag/ocaml/atom">Sylvain Le Gall</a></li><li><a href="http://caml.inria.fr/hump.rss">The Caml Humps</a></li><li><a href="http://www.blogger.com/feeds/6115529230232389198/posts/default">Till Varoquaux</a></li><li><a href="http://www.nicollet.net/toroidal/ocaml/feed/">Victor Nicollet</a></li><li><a href="http://y-node.com/blog/feeds/tag/ocaml/">y-node</a></li></ul>

      <a href="http://planet.ocaml.org/rss20.xml"><img src=".././img/rss20.png"/></a>
      <a href="http://planet.ocaml.org/opml.xml"><img src=".././img/opml.png"/></a>
    </div>
    <div class="planet"><a name="00ec978ade6c4d3f5b6ce89570ef0ff1"></a><span class="rss-header"><span class="rss-title"><a href="http://hongboz.wordpress.com/2013/02/05/syntactic-meta-programming-in-ocaml-ii-5/"> Syntactic Meta-Programming in OCaml (II)</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Hong bo Zhang</span>, <span class="rss-date">05 Feb 2013</span></span><span class="rss-description"><div id="post1"><p>In this post, we continue discussing syntactic meta-programming<br/>
following <a href="http://hongboz.wordpress.com/2013/01/28/random-thoughts-about-syntactic-meta-programming-i/">last post</a>.
</p>
<p>
My years of experience in different meta-program system(Common Lisp,<br/>
Template Haskell, Camlp4) tell me that quosi-quotation is the most<br/>
essential part in syntactic meta programming. Though all three claims<br/>
they have quosi-quotation support. But Template Haskell’s<br/>
quosi-quotation falls far behind either Camlp4 or Common Lisp. For a<br/>
decent quosi-quotation system, first, nested quotation and<br/>
anti-quotation is necessary, second, like Lisp, every part should be<br/>
able to be quoted and antiquoted except keywords position, that’s to<br/>
say, each part of the code fragment can be parametrized.
</p>
<p>
For the notation, we denote <code>Ast^0</code> as the normal Ast, <code>Ast^1</code> as Ast<br/>
encoding <code>Ast^0</code>, the same as <code>Ast^n</code>.
</p>
<p>
So in this post, we discuss the quosi-quotation first.
</p>
<a onclick="switchContent('post1','post2')" class="btn" href="#00ec978ade6c4d3f5b6ce89570ef0ff1">Read more...</a></div><div id="post2" style="display: none"><p>In this post, we continue discussing syntactic meta-programming<br/>
following <a href="http://hongboz.wordpress.com/2013/01/28/random-thoughts-about-syntactic-meta-programming-i/">last post</a>.
</p>
<p>
My years of experience in different meta-program system(Common Lisp,<br/>
Template Haskell, Camlp4) tell me that quosi-quotation is the most<br/>
essential part in syntactic meta programming. Though all three claims<br/>
they have quosi-quotation support. But Template Haskell’s<br/>
quosi-quotation falls far behind either Camlp4 or Common Lisp. For a<br/>
decent quosi-quotation system, first, nested quotation and<br/>
anti-quotation is necessary, second, like Lisp, every part should be<br/>
able to be quoted and antiquoted except keywords position, that’s to<br/>
say, each part of the code fragment can be parametrized.
</p>
<p>
For the notation, we denote <code>Ast^0</code> as the normal Ast, <code>Ast^1</code> as Ast<br/>
encoding <code>Ast^0</code>, the same as <code>Ast^n</code>.
</p>
<p>
So in this post, we discuss the quosi-quotation first.
</p>
<p>
The implementation of quosi-quotation heavily relies on the<br/>
implementation of the compiler, so let’s limit the scope of how to get<br/>
quosi-quotation done to OCaml.
</p>
<p>
Let’s ignore the antiquote part, and focus the quote part first, the<br/>
essential of quosi-quotation is to encode the Ast using Ast itself in<br/>
the meta level: there are different technologies to implement<br/>
quosi-quotations, to my knowledge, I summarized three here:
</p>
<div id="outline-container-1" class="outline-3">
<h3 id="sec-1">Raw String manipulation</h3>
<div id="text-1" class="outline-text-3">
<p>   This is the most intuitive way, given a string input, the normal<br/>
   way of parsing is transform it into a parsetree,
</p>
<pre class="src src-ocaml"><span style="color: #ffa500; font-weight: bold;">val</span> <span style="color: #dfaf8f;">parse</span><span style="color: #f0e68c;">:</span> <span style="color: #8cd0d3;">string </span><span style="color: #f0e68c;">-&gt;</span><span style="color: #8cd0d3;"> ast</span>
</pre>
<p>
   To encode the meta-level ast, we can do the unparsing again,<br/>
   assume we have an unparsing function which unparse the ast
</p>
<pre class="src src-ocaml"><span style="color: #ffa500; font-weight: bold;">val</span> <span style="color: #dfaf8f;">unparse</span><span style="color: #f0e68c;">:</span> <span style="color: #8cd0d3;">ast </span><span style="color: #f0e68c;">-&gt;</span><span style="color: #8cd0d3;"> string</span>
</pre>
<p>
   so after the composition of parse and unparse, you transformed a<br/>
   string into the meta-level
</p>
<pre class="src src-ocaml"><span style="color: #f0e68c;">(</span>parse <span style="color: #cc9393;">"3"</span><span style="color: #f0e68c;">)</span>
<span style="color: #f0e68c;">-</span> `Int <span style="color: #cc9393;">"3"</span>
unparse<span style="color: #f0e68c;">(</span>parse <span style="color: #cc9393;">"3"</span><span style="color: #f0e68c;">)</span>
<span style="color: #f0e68c;">-</span> <span style="color: #cc9393;">"`Int \"3\""</span>

</pre>
<p>
   Then you can do <code>parse</code> again, after <code>parse(unparse (parse "3"))</code>,<br/>
   we managed to lift the Ast in the meta level. There are serious<br/>
   defects with this way, First, it’s very brittle, since we are doing<br/>
   string manipulation in different levels, second, after <b>unparsing</b>,<br/>
   the location is totally lost, location is one of the most tedious<br/>
   but necessary part for a practical meta programming system, third,<br/>
   there is no easy way to integrate with antiquot. This technique is<br/>
   quite intuitive and easy to understand, but I don’t know any<br/>
   meta-system do it this way, so feel free to tell me if you know<br/>
   anyone does similar work <img src="http://s1.wp.com/wp-includes/images/smilies/icon_wink.gif" alt=";-)" class="wp-smiley"/>
</p>
</div>
</div>
<div id="outline-container-2" class="outline-3">
<h3 id="sec-2">Maintaining different parsers</h3>
<div id="text-2" class="outline-text-3">
<p>
   Unlike the string manipulation, it write different parsers for<br/>
   different actions. Suppose we are in OCaml, if we want to support<br/>
   quosi-quotations in such syntax categories
</p>
<pre class="example">sig_item, str_item, patt, expr, module_type, module_expr, class_type
class_expr, class_sig_item, class_str_item, with_constr, binding, rec_binding,
match_case,
</pre>
<p>
   And you want the quosi-quotaion appears in both <code>expr</code> and <code>patt</code><br/>
   positions, then you have to write <code>14 x (2+1)</code> parsers, the parser can<br/>
   not be re-usable, if you want to support <code>overloaded quotations</code> (I<br/>
   will talk about it later), then you have to roll your own parser<br/>
   again. Writing parser is not hard, but it’s not fun either, and<br/>
   keeping sync up different parsers is a nightmare.
</p>
<p>
   To make things worse, once anti-quotation is considered, for each<br/>
   category, there are three parsers to write, but anti-quot makes<br/>
   them slightly different. To be honest, this way is impractical.
</p>
</div>
</div>
<div id="outline-container-3" class="outline-3">
<h3 id="sec-3">Ast Lifting</h3>
<div id="text-3" class="outline-text-3">
<p>   Another mechanism to do quosi-quotation is that imaging we have a<br/>
   powerful function:
</p>
<pre class="src src-ocaml"><span style="color: #ffa500; font-weight: bold;">val</span> <span style="color: #dfaf8f;">meta</span><span style="color: #f0e68c;">:</span> <span style="color: #8cd0d3;">ast</span><span style="color: #f0e68c;">^</span>0 <span style="color: #f0e68c;">-&gt;</span> ast<span style="color: #f0e68c;">^</span>1
</pre>
<p>
   This seems magic, but it’s possible even though in OCaml we don’t<br/>
   have generic programming support, since we have the definition<br/>
   of ast.
</p>
<p>
   The problem with this technique is that it requires an explicit<br/>
   <code>Ant</code> tag in the ast representation, since at <code>ast^0</code> level, you<br/>
   have to store <code>Ant</code> as intermediate node which will be removed when<br/>
   applied <code>meta</code> function.
</p>
<p>
   Let’s walk through each phase in Fan
</p>
<p>
   Think about how such piece of code would be parsed in Fan:
</p>
<pre class="src src-ocaml"><span style="color: #f0e68c;">{:</span><span style="color: #8cd0d3;">expr</span><span style="color: #f0e68c;">|</span> <span style="color: #f0e68c;">$</span>x <span style="color: #f0e68c;">+</span> y<span style="color: #f0e68c;">|}</span>
</pre>
<p>
   For the first phase (I removed the location for simplicity)
</p>
<pre class="src src-ocaml">`App<span style="color: #f0e68c;">(</span>`App
      <span style="color: #f0e68c;">(</span> `Id <span style="color: #f0e68c;">(</span> `Lid <span style="color: #f0e68c;">(</span> <span style="color: #cc9393;">"+"</span><span style="color: #f0e68c;">)),</span>
        `Ant <span style="color: #f0e68c;">(</span> <span style="color: #f0e68c;">{</span>cxt <span style="color: #f0e68c;">=</span> <span style="color: #cc9393;">"expr"</span><span style="color: #f0e68c;">;</span> sep <span style="color: #f0e68c;">=</span> None<span style="color: #f0e68c;">;</span> decorations <span style="color: #f0e68c;">=</span> <span style="color: #cc9393;">""</span><span style="color: #f0e68c;">;</span> content <span style="color: #f0e68c;">=</span> <span style="color: #cc9393;">"x"</span><span style="color: #f0e68c;">})),</span>
     `Id <span style="color: #f0e68c;">(</span> `Lid <span style="color: #f0e68c;">(</span> <span style="color: #cc9393;">"y"</span><span style="color: #f0e68c;">)))</span>
</pre>
<p>
   Here <code>Ant</code> exists only as intermediate node, it will be eliminated<br/>
   in the meta-step
</p>
<p>
   after applied with <code>meta</code> function
</p>
<pre class="src src-ocaml"><span style="color: #f0e68c;">(</span><span style="color: #8cd0d3;">Filters</span>.<span style="color: #8cd0d3;">ME</span>.meta_expr _loc <span style="color: #f0e68c;">(</span>t expr <span style="color: #cc9393;">"$x + y"</span><span style="color: #f0e68c;">));</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> <span style="color: #8cd0d3;">FanAst.expr </span><span style="color: #f0e68c;">=</span>
`App
  <span style="color: #f0e68c;">(,</span>
   `App
     <span style="color: #f0e68c;">(,</span> `App <span style="color: #f0e68c;">(,</span> `Vrn <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"App"</span><span style="color: #f0e68c;">),</span> `Id <span style="color: #f0e68c;">(,</span> `Lid <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"_loc"</span><span style="color: #f0e68c;">))),</span>
      `App
        <span style="color: #f0e68c;">(,</span>
         `App
           <span style="color: #f0e68c;">(,</span> `App <span style="color: #f0e68c;">(,</span> `Vrn <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"App"</span><span style="color: #f0e68c;">),</span> `Id <span style="color: #f0e68c;">(,</span> `Lid <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"_loc"</span><span style="color: #f0e68c;">))),</span>
            `App
              <span style="color: #f0e68c;">(,</span> `App <span style="color: #f0e68c;">(,</span> `Vrn <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"Id"</span><span style="color: #f0e68c;">),</span> `Id <span style="color: #f0e68c;">(,</span> `Lid <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"_loc"</span><span style="color: #f0e68c;">))),</span>
               `App
                 <span style="color: #f0e68c;">(,</span> `App <span style="color: #f0e68c;">(,</span> `Vrn <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"Lid"</span><span style="color: #f0e68c;">),</span> `Id <span style="color: #f0e68c;">(,</span> `Lid <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"_loc"</span><span style="color: #f0e68c;">))),</span>
                  `Str <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"+"</span><span style="color: #f0e68c;">)))),</span>
         `Ant <span style="color: #f0e68c;">(,</span> <span style="color: #f0e68c;">{</span>cxt <span style="color: #f0e68c;">=</span> <span style="color: #cc9393;">"expr"</span><span style="color: #f0e68c;">;</span> sep <span style="color: #f0e68c;">=</span> None<span style="color: #f0e68c;">;</span> decorations <span style="color: #f0e68c;">=</span> <span style="color: #cc9393;">""</span><span style="color: #f0e68c;">;</span> content <span style="color: #f0e68c;">=</span> <span style="color: #cc9393;">"x"</span><span style="color: #f0e68c;">}))),</span>
   `App
     <span style="color: #f0e68c;">(,</span> `App <span style="color: #f0e68c;">(,</span> `Vrn <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"Id"</span><span style="color: #f0e68c;">),</span> `Id <span style="color: #f0e68c;">(,</span> `Lid <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"_loc"</span><span style="color: #f0e68c;">))),</span>
      `App <span style="color: #f0e68c;">(,</span> `App <span style="color: #f0e68c;">(,</span> `Vrn <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"Lid"</span><span style="color: #f0e68c;">),</span> `Id <span style="color: #f0e68c;">(,</span> `Lid <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"_loc"</span><span style="color: #f0e68c;">))),</span> `Str <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"y"</span><span style="color: #f0e68c;">))))</span>   
</pre>
<p>
   (t is a parsing function)<br/>
   Here we see that <code>Ant</code> node is still kept and it will be<br/>
   filtering, now we can filter the <code>Ant</code> node into a normal Ast,
</p>
<pre class="src src-ocaml"><span style="color: #f0e68c;">(</span><span style="color: #8cd0d3;">Ant</span>.antiquot_expander <span style="color: #f0e68c;">~</span>parse_patt <span style="color: #f0e68c;">~</span>parse_expr<span style="color: #f0e68c;">)#</span>expr <span style="color: #f0e68c;">(</span><span style="color: #8cd0d3;">Filters</span>.<span style="color: #8cd0d3;">ME</span>.meta_expr _loc <span style="color: #f0e68c;">(</span>t expr <span style="color: #cc9393;">" $x + y"</span><span style="color: #f0e68c;">));</span>
<span style="color: #f0e68c;">-</span> <span style="color: #f0e68c;">:</span> <span style="color: #8cd0d3;">FanAst.expr </span><span style="color: #f0e68c;">=</span>
`App
  <span style="color: #f0e68c;">(,</span>
   `App
     <span style="color: #f0e68c;">(,</span> `App <span style="color: #f0e68c;">(,</span> `Vrn <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"App"</span><span style="color: #f0e68c;">),</span> `Id <span style="color: #f0e68c;">(,</span> `Lid <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"_loc"</span><span style="color: #f0e68c;">))),</span>
      `App
        <span style="color: #f0e68c;">(,</span>
         `App
           <span style="color: #f0e68c;">(,</span> `App <span style="color: #f0e68c;">(,</span> `Vrn <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"App"</span><span style="color: #f0e68c;">),</span> `Id <span style="color: #f0e68c;">(,</span> `Lid <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"_loc"</span><span style="color: #f0e68c;">))),</span>
            `App
              <span style="color: #f0e68c;">(,</span> `App <span style="color: #f0e68c;">(,</span> `Vrn <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"Id"</span><span style="color: #f0e68c;">),</span> `Id <span style="color: #f0e68c;">(,</span> `Lid <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"_loc"</span><span style="color: #f0e68c;">))),</span>
               `App
                 <span style="color: #f0e68c;">(,</span> `App <span style="color: #f0e68c;">(,</span> `Vrn <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"Lid"</span><span style="color: #f0e68c;">),</span> `Id <span style="color: #f0e68c;">(,</span> `Lid <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"_loc"</span><span style="color: #f0e68c;">))),</span>
                  `Str <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"+"</span><span style="color: #f0e68c;">)))),</span>
         `Id <span style="color: #f0e68c;">(,</span> `Lid <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"x"</span><span style="color: #f0e68c;">)))),</span>
   `App
     <span style="color: #f0e68c;">(,</span> `App <span style="color: #f0e68c;">(,</span> `Vrn <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"Id"</span><span style="color: #f0e68c;">),</span> `Id <span style="color: #f0e68c;">(,</span> `Lid <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"_loc"</span><span style="color: #f0e68c;">))),</span>
      `App <span style="color: #f0e68c;">(,</span> `App <span style="color: #f0e68c;">(,</span> `Vrn <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"Lid"</span><span style="color: #f0e68c;">),</span> `Id <span style="color: #f0e68c;">(,</span> `Lid <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"_loc"</span><span style="color: #f0e68c;">))),</span> `Str <span style="color: #f0e68c;">(,</span> <span style="color: #cc9393;">"y"</span><span style="color: #f0e68c;">))))</span>   
</pre>
<p>
   (location in the meta-level is ignored)<br/>
   If we want to share the same grammar between the <code>Ast^n(n=0,1,2,...)</code>,<br/>
   Ast lifting (a function of type <code>Ast^0 -&gt; Ast^1</code>) is necessary.
</p>
</div>
</div>
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Summary</h2>
<div id="text-1" class="outline-text-2">
<p>
  We see the three techniques introduced here to do the<br/>
  quosi-quotation, Fan adopts the third one, suppose we pick the<br/>
  third one, let’s discuss what kind of Ast representation we need to<br/>
  make life easier.
</p>
<p>
  As we discussed previously, introducing records in the Abstract Syntax<br/>
  brings in un-necessary complexity when you want to encode the Ast<br/>
  using the Ast itself since you have to express the record in the<br/>
  meta-level as well.
</p>
<p>
  Another defect with current Parsetree is that it was designed without<br/>
  meta-programming in mind, so it does not provide an <code>Ant</code> tag in all<br/>
  syntax categories, so in the zero stage <code>Ast^0</code>, you can not have an<br/>
  Ast node <code>$x</code> in the outermost, since it’s semantically incorrect in<br/>
  <code>Ast^0</code>, but syntactically correct in <code>Ast^n(n=0,1,2,...)</code>
</p>
<p>
  The third defect with the <code>Parsetree</code> is that it’s quite irregular,<br/>
  so you can not do any meta-programming with the parsetree itself, for<br/>
  example, stripping all the location from the Ast node to derive a new<br/>
  type without locations, deriving a new type without anti-quot tags (we<br/>
  will see that such ability is quite important in <a href="https://github.com/bobzhang/Fan">Fan</a>)
</p>
<p>
  The fourth defect is more serious from the point of view of<br/>
  semantics, since in OCaml, there is no way to express absolute path,<br/>
  when you do the Ast lifting, the time you define Ast lifting is<br/>
  different from the time you use the quotations
</p>
<p>
  Camlp4′s Ast is slightly better than Parsetree, since it does not<br/>
  introduce records to increase the complexity.
</p>
<p>
  However, Camlp4′s Ast can not express the absolute path which<br/>
  results in a semantics imprecise, another serious implementation<br/>
  defect is that it tries to encode the anti-quote using both two<br/>
  techniques: either explicit <code>Ant</code> tag or via string mangling, prefix<br/>
  the string with <code>\\$:</code>, and Camlp4′s tag name is totally not<br/>
  meaningful.
</p>
<p>
  Think a bit further , about syntactic meta-programming, what we<br/>
  really care about is purely syntax, <code>Int "3"= should not be   different whether it is of type =expr</code> or <code>patt</code>, if we take a<br/>
  location of ast node, we should not care about whether its type is<br/>
  <code>expr</code> or <code>patt</code> or <code>str_item</code>, right?
</p>
<p>
  If we compose two ast node using semi syntax <code>;</code>, we really don’t<br/>
  care about whether it’s expr node or patt node
</p>
<pre class="src src-ocaml"><span style="color: #ffa500; font-weight: bold;">let</span> <span style="color: #8cd0d3;">sem</span><span style="color: #dfaf8f;"> a b </span><span style="color: #f0e68c;">=</span> <span style="color: #f0e68c;">{|</span> <span style="color: #f0e68c;">$</span>a<span style="color: #f0e68c;">;</span> <span style="color: #f0e68c;">$</span>b <span style="color: #f0e68c;">|}</span>
</pre>
<p>
  The code above should work well under already syntax categories as<br/>
  long as it support <code>`Sem</code> tag.
</p>
<p>
  Changing the underlying representation of Ast means all existing<br/>
  code in Camlp4 engine can not be reused, since the quotation-kit no<br/>
  longer apply in Fan, but the tough old days are already gone, Fan<br/>
  already managed to provide the whole quotation kit from scratch.  In<br/>
  the next post we will talk about the underly Ast using polymorphic<br/>
  variants in Fan, and argue why it’s the right direction.
</p>
<p>
  Thanks for your reading!(btw, there’s a bug in Emacs org/blog, sorry for posting several times)
</p>
</div>
</div>

<br/>  <a href="http://feeds.wordpress.com/1.0/gocomments/hongboz.wordpress.com/155/" rel="nofollow"><img src="http://feeds.wordpress.com/1.0/comments/hongboz.wordpress.com/155/" alt="" border="0"/></a> <img src="http://stats.wordpress.com/b.gif?host=hongboz.wordpress.com&amp;blog=40164267&amp;post=155&amp;subd=hongboz&amp;ref=&amp;feed=1" alt="" height="1" border="0" width="1"/><a onclick="switchContent('post2','post1')" class="btn" href="#00ec978ade6c4d3f5b6ce89570ef0ff1">Hide</a></div></span>
<a name="0eed7dbfb15f8c7e7c88f25ac195e914"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/ocaml-efl/"> OCaml EFL</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">05 Feb 2013</span></span><span class="rss-description">An OCaml interface to the Enlightenment Foundation Libraries (EFL)</span>
<a name="6c98a8cb7ee4b38f005b55fec3ab3c11"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2013.02.05.html"> Caml Weekly News, 05 Feb 2013</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">05 Feb 2013</span></span><span class="rss-description">OCaml-Java: new preview / Core Suite 109.07.00 released / ocurl forked and 0.5.4 released / multiplexing several threads / Brand-new BER MetaOCaml for OCaml 4.00.1 / Update on docs.camlcity.org / Other Caml News</span>
<a name="e7b08d975890d914e90589b0aa53cb6d"></a><span class="rss-header"><span class="rss-title"><a href="http://lpw25.net/2013/02/05/camlp4-alternative-part-2.html"> An alternative to camlp4 - Part 2</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author"><span id="ocaml_1">Leo White &#9001;leo<abbr title="(at) &rarr; @">(at)</abbr>lpw25.net (Leo White)&#9002;</span><script type="text/javascript"><!--;
local = "leo";
h = "lpw25.net (Leo White)";
document.getElementById("ocaml_1").innerHTML = '<a href="mailto:' + local + '@' + h + "\" >Leo White<\/a>";
//--></script></span>, <span class="rss-date">05 Feb 2013</span></span><span class="rss-description"><div id="post3"><p>In my <a href="http://www.lpw25.net/2013/01/23/camlp4-alternative-part-1.html">previous blog post</a> I
discussed how we might use AST transformers, attributes and quotations as a
simpler alternative to camlp4. While AST transformers are much simpler to use
than camlp4 they still require knowledge of the OCaml syntax tree, and they are
still implemented outside of the language as preprocessors.</p>

<p>In this post I'll explore how to implement extensions:</p>

<ul>
<li>within the language itself without external preprocessors</li>
<li>without the need for detailed knowledge of the OCaml syntax tree</li>
</ul>


<p>By including these extensions in the language itself the increasing number of
tools being built to support OCaml (e.g. typerex) can handle them directly. For
instance, IDEs could show the expansions of quotations by using the information
in ".cmt" files.</p>

<p>I will start with quotations, which can be implemented without any knowledge of
the OCaml syntax tree, and then expand my proposal to include other kinds of
extension.</p>

<a onclick="switchContent('post3','post4')" class="btn" href="#e7b08d975890d914e90589b0aa53cb6d">Read more...</a></div><div id="post4" style="display: none"><p>In my <a href="http://www.lpw25.net/2013/01/23/camlp4-alternative-part-1.html">previous blog post</a> I
discussed how we might use AST transformers, attributes and quotations as a
simpler alternative to camlp4. While AST transformers are much simpler to use
than camlp4 they still require knowledge of the OCaml syntax tree, and they are
still implemented outside of the language as preprocessors.</p>

<p>In this post I'll explore how to implement extensions:</p>

<ul>
<li>within the language itself without external preprocessors</li>
<li>without the need for detailed knowledge of the OCaml syntax tree</li>
</ul>


<p>By including these extensions in the language itself the increasing number of
tools being built to support OCaml (e.g. typerex) can handle them directly. For
instance, IDEs could show the expansions of quotations by using the information
in ".cmt" files.</p>

<p>I will start with quotations, which can be implemented without any knowledge of
the OCaml syntax tree, and then expand my proposal to include other kinds of
extension.</p>

<p>Since my previous post, there has been a lot of discussion on
<a href="http://lists.ocaml.org/listinfo/wg-camlp4">wg-camlp4@lists.ocaml.org</a> about
possible syntaxes for quotations and attributes and other kinds of extension. In
keeping with those ongoing discussions, I will use <code>{:id { string }}</code> as the
syntax for quotations (which transform a string into an AST node) and <code>(:id
expr)</code> as the syntax for extensions that transform an OCaml expression into an
AST node.</p>

<p>Note that the proposals in this post are more long-term than the "ppx" solution
discussed in the previous post. Moving an extension from ppx to the mechanism
described in this post would require only minimal work. So in the short/medium
term extension authors should implement their extensions using ppx.</p>

<h4>Quotations</h4>

<p>A quotation is simply a function which takes a string and returns an AST
node. To provide built-in support we need to, for every quotation <code>{:foo { bar
}}</code>:</p>

<ol>
<li>find a function that corresponds to <code>foo</code></li>
<li>apply it to the string " bar "</li>
<li>copy the resulting AST node in place of the original quotation</li>
</ol>


<h5>Quotations in modules</h5>

<p>We might want to find the function corresponding to quotation <code>foo</code> by simply
looking in the current module, or one of the other modules in our environment,
for a function called <code>foo</code>. However there are a few problems with this simple
scheme:</p>

<ol>
<li>The function we call must exist and be compiled before we can use it.</li>
<li>There is no clear separation between what is being executed at compile-time
and what is being executed and run-time.</li>
</ol>


<p>The first problem basically means that we can only use functions defined in
other files. The other problem is more subtle.</p>

<p>OCaml modules do not really exist at compile time. They are created at run-time,
and their creation encompasses the entire execution of the program. For example,
consider this simple module:</p>

<div class="highlight"><pre><code class="ocaml"><span class="c">(* main.ml *)</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Hello, world!</span><span class="se">\n</span><span class="s2">"</span>
</code></pre></div>


<p>To create the <code>Main</code> module, we must create its member <code>x</code>. Once the creation of
<code>Main</code> is finished the <code>printf</code> has been executed and the whole program has
completed. Now if we add a quotation function <code>foo</code> to this module:</p>

<div class="highlight"><pre><code class="ocaml"><span class="c">(* main.ml *)</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"Hello, world!</span><span class="se">\n</span><span class="s2">"</span>

<span class="k">let</span> <span class="n">keywords</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">13</span>
<span class="k">let</span> <span class="n">foo</span> <span class="n">str</span> <span class="o">=</span> <span class="c">(* Some expression using keywords *)</span>
</code></pre></div>


<p>How do we distinguish between data such as <code>keywords</code> which are needed at
compile-time when the quotation is run, and data like <code>x</code> whose creation is
meant to drive the program at run-time? There is nothing explicit in the
definitions of <code>foo</code> or <code>keywords</code> that indicates that they are intended for
compile-time execution.</p>

<p>These problems are related to the fact that OCaml is an impure language. Any
expression (including module definitions) can have side-effects, and the
run-time behaviour of the program is simply the combination of all these
side-effects. This makes it difficult to separate the side-effects that are
related to a quotation from the side-effects that are part of the program's
execution.</p>

<p>Despite appearing alongside other functions in the program, <code>foo</code> must be
executed in a completely separate environment. Any side-effects (e.g. mutable
state, I/O) that are produced while creating and executing <code>foo</code> will be
completely separate from the side-effects of the other functions in its module.</p>

<h5>Where can we put them?</h5>

<p>If we don't want to put quotation functions in our modules, where should we put
them? The module system provides the only mechanism for referring to functions in
other files, how can we refer to functions which are not included in a module?</p>

<p>The answer to these questions comes from the idea of <em>namespaces</em>. Namespaces
are a way to give longer names to top-level modules without changing the
module's filename. They also allow these top-level modules to be grouped
together.</p>

<p>The details of proposals for namespaces vary on their details, but they
basically allow you to take the module defined by a file "baz.ml" and refer to
it as "Bar.Baz". Here "Bar" is not a module (it cannot be used as the argument
to a functor) but a namespace.</p>

<p>Namespaces seem likely to be included in OCaml in the near future,
and they provide a convenient way to refer to quotations without putting
quotations within modules.</p>

<p>The idea is to write quotations in a "bar.mlq" file (compiled to
"bar.cmq"). These quotations would then be placed in the namespace "Bar".</p>

<p>Quotations would be defined with a syntax like:</p>

<div class="highlight"><pre><code class="ocaml"><span class="c">(* bar.mlq *)</span>
<span class="n">quotation</span> <span class="n">foo</span> <span class="n">str</span> <span class="o">=</span> <span class="o">...</span>
</code></pre></div>


<p>This could then be used with the syntax:</p>

<div class="highlight"><pre><code class="ocaml"><span class="o">{:</span><span class="nn">Bar</span><span class="p">.</span><span class="n">foo</span><span class="o">{</span> <span class="n">some</span> <span class="n">text</span> <span class="o">}}</span>
</code></pre></div>


<p>This will make it easy for quotations to be provided by libraries. So that the
following code would perfectly possible:</p>

<div class="highlight"><pre><code class="ocaml"><span class="o">{:</span><span class="nn">Core</span><span class="p">.</span><span class="nn">Web</span><span class="p">.</span><span class="n">html</span><span class="o">{&lt;</span><span class="n">body</span><span class="o">&gt;</span> <span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span> <span class="o">&lt;/</span><span class="n">body</span><span class="o">&gt;}}</span>
</code></pre></div>


<h5>Quotations in different contexts</h5>

<p>So far, we have ignored the question of what type is used to represent an AST
node. The standard library would need to provide such a type so that quotations
could be written without linking to compiler-libs. There would also need to be
different types for different kinds of AST nodes. We do not want a quotation
used as an expression returning an AST node that represents a pattern</p>

<p>However, we also might want to create quotations that can be used as both
expressions and patterns. This means that the quotation must return a different
type depending on where it is used.</p>

<p>The solution to this issue is to give quotations the type <code>'a ctx -&gt; string -&gt;
'a</code>.  The <code>ctx</code> type would be a GADT that described what context a quotation was
being used from. It could also contain other information about the context, such
as its location in the source file.</p>

<h5>Building Quotations</h5>

<p>Creating the quotation functions requires some facility for creating AST
nodes. For this purpose, the standard library would include special quotations,
for example: <code>{:Ast.expr{ x + 3 }}</code>. These quotations would be implemented
directly using the compiler's lexer and parser.</p>

<p>It would also be useful (especially for handling anti-quotations) to allow
quotations to be built from other quotations. For this we could provide another
syntax: <code>{:foo}</code> that would refer directly to the quotation function
<code>foo</code>. Obviously, this syntax would only be allowed within ".mlq" files.</p>

<h4>Other extensions</h4>

<p>This system could easily be extended to other kinds of extension. Rather than
declaring "quotations" with type <code>'a ctx -&gt; string -&gt; 'a</code>, we could declare
<em>templates</em> with type <code>'a ctx -&gt; 'a</code>. The context would contain the arguments to
the template (a string for quotations, an AST node for other templates).</p>

<p>So a template declared as:</p>

<div class="highlight"><pre><code class="ocaml"><span class="c">(* bar.mlq *)</span>
<span class="n">template</span> <span class="n">foo</span> <span class="n">str</span> <span class="o">=</span> <span class="o">...</span>
</code></pre></div>


<p>could be used with the syntax:</p>

<div class="highlight"><pre><code class="ocaml"><span class="o">(:</span><span class="nn">Bar</span><span class="p">.</span><span class="n">foo</span> <span class="n">expr</span><span class="o">)</span>
</code></pre></div>


<p>Unlike quotations, more general templates must be able to interpret AST nodes
themselves. This means we must provide mechanisms for handling AST nodes. For
this purpose, the standard library would include a simpler version of the
<code>AstMapper</code> module that is in compiler-libs.</p>

<p>We could also allow the AST quotations (e.g. `Ast.expr) to be used as
patterns. This approach can be a bit fragile because syntactic sugar can cause a
pattern to match ASTs that it was not expected to match. However, for matching
simple AST nodes it is probably fairly robust.</p>

<h4>Summary</h4>

<ol>
<li>Allow extensions to be written as OCaml functions within ".mlq" files.</li>
<li>Refer to these functions by attaching them directly to namespaces.</li>
<li>Require these functions to have type <code>'a ctx -&gt; 'a</code>, where <code>ctx</code> includes a
GADT describing the context that the extension has been used in.</li>
<li>Provide AST quotations in the standard library (e.g. <code>{:Ast.expr{ x + 3 }}</code>)
which use the compiler's own lexer and parser.</li>
</ol><a onclick="switchContent('post4','post3')" class="btn" href="#e7b08d975890d914e90589b0aa53cb6d">Hide</a></div></span>
<a name="83e740a394d1c2d5ca61795a79a53c3e"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/blog/implementing-hamt-for-ocaml"> Implementing HAMT for OCaml</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">02 Feb 2013</span></span><span class="rss-description"><div id="post5"><p>During the second part of <a href="http://gallium.inria.fr/blog/hevea-a-new-rope/">my
internship</a> this
summer, I worked on a test implementation for a new data structure in
OCaml : Hash Array Mapped Tries (HAMT). I did not have the time to
finish it, but I now have a usable and quite complete version, still
to be more documented but already available at
<a href="http://gitorious.org/ocaml-hamt">http://gitorious.org/ocaml-hamt</a>.</p>

<p>On this article, I will quickly explain the principles and the use
cases of this structure, and I will expose a few details of my
implementation in OCaml.</p>




<h3 id="hamt-why-where-how">HAMT: Why, where, how ?</h3>
<p>When you want to play with associative tables over non-integer keys, if you can use imperative constructions, you do not usually hesitate a long time : you use Hash Tables. This structure guarantees <code>O(1)</code> complexity for all elementary operations, provided you can hash your values. However, it is by essence a mutable structure: if you want to use a functional style, you need persistent ones (and copying a Hash Table at every single insertion is obviously right out).</p>
<a onclick="switchContent('post5','post6')" class="btn" href="#83e740a394d1c2d5ca61795a79a53c3e">Read more...</a></div><div id="post6" style="display: none"><p>During the second part of <a href="http://gallium.inria.fr/blog/hevea-a-new-rope/">my
internship</a> this
summer, I worked on a test implementation for a new data structure in
OCaml : Hash Array Mapped Tries (HAMT). I did not have the time to
finish it, but I now have a usable and quite complete version, still
to be more documented but already available at
<a href="http://gitorious.org/ocaml-hamt">http://gitorious.org/ocaml-hamt</a>.</p>

<p>On this article, I will quickly explain the principles and the use
cases of this structure, and I will expose a few details of my
implementation in OCaml.</p>




<h3 id="hamt-why-where-how">HAMT: Why, where, how ?</h3>
<p>When you want to play with associative tables over non-integer keys, if you can use imperative constructions, you do not usually hesitate a long time : you use Hash Tables. This structure guarantees <code>O(1)</code> complexity for all elementary operations, provided you can hash your values. However, it is by essence a mutable structure: if you want to use a functional style, you need persistent ones (and copying a Hash Table at every single insertion is obviously right out).</p>
<p>The usual choice is then to use balanced binary trees (like Maps in OCaml): if you can provide an order relation on your keys, elementary operations become <code>O(log(n))</code>. In 2001, a new data structure is introduced by Phil Bagwell: Hash Array Mapped Tries<sup><a href="http://gallium.inria.fr/blog/index.rss#fn1" id="fnref1" class="footnoteRef">1</a></sup>. Where balanced binary trees have a branching factor of 2, thus having approximately a <code>log2(n)</code> depth (<code>n</code> is the number of elements), HAMT are prefix trees which have a much greater factor, namely 32 in the original article (in fact, the best value is the size of a word of your machine, we will see why).</p>
<p>But how to build <em>prefix</em> trees with your own type of key ? That's where hashing enters the scene. If you can hash your key, then you can consider that the keys of your table are not your key type, but the hashed values of your own keys. Thus you can build a prefix tree, with an obvious notion of prefix that I will not explain. There is also a second advantage: if your hash function is correctly distributed, your tree is automagically balanced: you do not it to set up by rebalancing sometimes nor by keeping extra information. Being a "prefix tree over the hashes of the keys" is therefore the basis of the structure.</p>
<p>HAMT have been getting publicity since they where picked as a central persistent datastructure in the Clojure programming language. We have also had encouraging feedback from use in Scala, and more recently implementations in Haskell. It seems that persistent HAMT are an interesting datastructure; yet we should not jump to conclusions, as the details of one's runtime system may have important impacts on the viability of subtle data layout choices. The purpose of the current prototype was to test the waters to see whether the "HAMT success story" could be reproduced in the OCaml world.</p>
<p>Its use case is rather obvious: when you need a persistent associative table over a key that you can hash, you can use HAMT. However, there is no notion of comparison in standard HAMT: if you need to be able to get quickly the value associated with the minimal key, they are not a good choice. So where is the advantage over Maps ?</p>
<p>Here is a small, early comparison between the two structures: we test iterations of adding elements to an already big structure, finding present elements in the structure, and a mix of adding and finding (this test is executed by timing the execution of <code>tests/param.ml</code>, self-documented, by Gabriel Scherer, praise him) :</p>
<pre><code>|            | Map   | HAMT  |
| add        | 7.4s  | 8.6s  |
| find       | 7.9s  | 3.9s  |
| find + add | 14.9s | 11.8s |</code></pre>
<p>We see that the HAMT are a little (although the difference seems to increase with the dimension of the test) slower on insertions, but really quicker on searches. They use Arrays and do a quite big number of copies when modifying a key, so the GC is heavily sollicitated: if we byte-compile the file and we use <code>OCAMLRUNPARAM="s=5M"</code> to boost-up it, HAMT.add becomes a little faster than Map.add, and find is a little sped-up. However, the precise conditions leading to this results are not really understood: the size of the test has apparently a non-negligeable influence, and I cannot really make reliable performance comparisons. For an example, without modifying the GC, I just executed the following commands:</p>
<pre><code>$ time ./param.byte hamt 300000 add
./param.byte hamt 300000 add  15,98s user 0,07s system 99% cpu 16,083 total
$ time ./param.byte map 300000 add
./param.byte map 300000 add  19,59s user 0,03s system 99% cpu 19,665 total
$ time ./param.native hamt 300000 add
./param.native hamt 300000 add  8,95s user 0,09s system 99% cpu 9,061 total
$ time ./param.native map 300000 add
./param.native map 300000 add  7,41s user 0,05s system 99% cpu 7,475 total</code></pre>
<p>The bottom line is: the structure seems to be a good alternative to Maps. It is always (and often much) faster on finds, and has equivalent performances on add (sometimes faster, sometimes slower, under conditions that I do not really know). Furthermore, missed findings are faster than successful ones in HAMT, and this accentuates the difference in favour of this structure (even if it is not <em>that</em> accentuated).</p>
<p>Now that we got promising results about the structure, let's dissect it to understand how it works.</p>
<h3 id="hamt-what-is-it">HAMT: what is it ?</h3>
<p>So we already know the basis of the structure: it's a prefix tree over the hashes of the key. More precisely, every node is (for now) a leaf (<code>key, value</code> pair) or a 32 elements array (containing his sons), and to traverse the structure, we hash our key, and we take the bits from this hash 5 by 5. Thus at each level we have a 5 bits chunk, being a number between 0 and 31 which will indicate which son to choose. If it is <code>Empty</code>, then the considered key is not present in the structure. Insertion is then trivial: just replace it by your <code>Leaf (k, v)</code>. If we encounter a leaf, either its key is the one we are looking for, either... it isn't. If it is, insertion is made by changing the value. If it is not, insert an internal node (an array) at this place, take the chunks of hash corresponding to this depth of both keys, and put each one at its place (you may have to do it several times if the chunks appear to be the same). If we encounter an internal node, just take the following 5 bits and continue the descent. At the end of the hash, if we still are on an internal node, either we use open hashes (then there is no "end of the hash", but we cannot usually guarantee to terminate), or we place buckets in the last arrays instead of leaves.</p>
<p>If we use a correctly distributed hash, our structure will therefore have a depth of (at most) <code>log32(n)</code>. Let's estimate what it means: if we want to build a structure associating to each single word of <em>War and Peace</em> its number of occurrences, we only need a depth of 4. If our keys are representing every people on Earth, we need a depth of 7. If they are every single atom on the universe, it's less than 60. Of course, our hash function will not be perfect, but we can see with these numbers that with very few chunks extraction and comparison, we can index a very important key set. We also need few array copies when we modify something on our table (because, to be persistent, we need to copy the arrays leading to our tip node from the root: that's the cost of fast indexing. <em>Boire ou conduire, il faut choisir.</em>)</p>
<p>However, we have a problem with this representation: each array uses a constant space, even if it is almost empty. If our structure is not very dense, we can use up to 32 times more space than needed. On big datasets, it can be problematic. There is an (elegant) astuce to fix this: rather than arrays of size 32 at each level, we only use arrays that have exactly as many cases as sons. To get the index on our array given our "virtual" index (which is the value of our chunk), we use a <em>bitmap</em>: a 32-bits integer, where each bit indicates the presence at this position of a son of our node. The order of the elements on the array follows the order of the chunks, then to get the real indice of a chunk, we just have to count the 1-bits at a indice lower than it in the bitmap. Using this method, every case of an array is useful, and if we adapted the size of our structure as I mentioned before (remember, the branching factor), the bitmap fills exactly one machine word: we have a quite optimal space use.</p>
<p>In his <a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">article</a>, Phil Bagwell also uses a root table which is treated differently. I did not use this method in my implementation, so I will not talk much about it: just know basically that the first table is resized when the number of elements in the structure increases, to guarantee a constant-time access to every key (at the cost of resizing sometimes, which seems to be amortized over insertions<sup><a href="http://gallium.inria.fr/blog/index.rss#fn2" id="fnref2" class="footnoteRef">2</a></sup>).</p>
<p>Finally, let's talk about "theoretical performances": our complexity is the same as balanced binary trees, namely <code>O(log(n))</code> for elementary operations (insertion, deletion, searching), except that our <code>log</code> is not the same and grows very slowly (but, well, maths are strict and <code>O(.)</code> does not want to know about that). Misses are faster than successful researches: if a key is not present in the tree, and if the hash function has good properties, we should quickly find a difference between the hash of our keys and the ones of those who are in our table. But in this kind of problem, the real determining factor is the multiplicative one behind our asymptotic complexity: we saw in the first part that, in OCaml, this factor seems to be nice enough to give us good hopes about the structure. Let's now examine the practical implementation.</p>
<h3 id="in-ocaml-a-few-lines-of-code.">In OCaml: a few lines of code.</h3>
<p>In this part, I will not comment about every detail of my implementation, but simply show a few lines and give short explanations about how the stuff works. My implementation is strongly inspired by <a href="https://github.com/exclipy/pdata">exclipy's one</a> in Haskell.</p>
<p>Let's start by the counting of the 1-bits in a bitmap: the modern processors offer a <code>POPCOUNT</code> instruction which does the job. However, OCaml does not propose this instruction: we have to recode it by ourselves.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> sk5 = 0x55555555
<span class="kw">let</span> sk3 = 0x33333333
<span class="kw">let</span> skf0 = 0xf0f0f0f
<span class="kw">let</span> skff = 0xff00ff

<span class="kw">let</span> ctpop map =
  <span class="kw">let</span> map = map - (map <span class="kw">lsr</span> 1) <span class="kw">land</span> sk5 <span class="kw">in</span>
  <span class="kw">let</span> map = map <span class="kw">land</span> sk3 + (map <span class="kw">lsr</span> 2) <span class="kw">land</span> sk3 <span class="kw">in</span>
  <span class="kw">let</span> map = map <span class="kw">land</span> skf0 + (map <span class="kw">lsr</span> 4) <span class="kw">land</span> skf0
  <span class="kw">in</span> <span class="kw">let</span> map = map + map <span class="kw">lsr</span> 8
     <span class="kw">in</span> (map + map <span class="kw">lsr</span> 16) <span class="kw">land</span> 0x3f</code></pre>
<p>This code is adapted from the one Phil Bagwell proposes in C in his paper. I have no clue why it works (and I do not want to), but well, it does. It counts the number of 1-bits in a bitmap, and when you want them before a given position <code>n</code>, just use <code>land</code> to set the other bits to <code>0</code>. The interesting point is that this is a portion of code which could be fastened: in an ideal world where everybody would love HAMT, we could imagine an OCaml implementing default support for <code>CTPOP</code>. Anyway, thinking about the performances of this function would not be a loss of time when the era of micro-optimisation has come.</p>
<p>Here is the definition of the HAMT type:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> 'a t =
  | <span class="dt">Empty</span>
  | <span class="dt">Leaf</span> <span class="kw">of</span> <span class="dt">int</span> * key * 'a
  | <span class="dt">HashCollision</span> <span class="kw">of</span> <span class="dt">int</span> * (key * 'a) <span class="dt">list</span>
  | <span class="dt">BitmapIndexedNode</span> <span class="kw">of</span> <span class="dt">int</span> * 'a t <span class="dt">array</span>
  | <span class="dt">ArrayNode</span> <span class="kw">of</span> <span class="dt">int</span> * 'a t <span class="dt">array</span></code></pre>
<p>Buckets are managed by association lists: it is probably weak to hash collision attacks. Using Maps would probably fix this problem, at the cost of having to use comparable keys. We could also use open hashes: not to decide, I simply used lists and kept the <code>Leaf</code> constructor (instead of a <code>HashCollision</code> with a one element list), so that it could be easily modified in the functions if another way was preferable. As for <code>BitmapIndexedNode</code> and <code>ArrayNode</code>, they correspond to the root table of Phil Bagwell: rather than making it grow when inserting many data, I transform bitmap arrays into full length arrays when they are dense enough: therefore, there is no need to compute a <code>CTPOP</code>, and there is no big space loss because the constructor is only used when arrays already contain almost 32 elements. The performance fact is to be analysed: we could think that using only <code>ArrayNode</code> would lead to better performances (at the cost of a lot of space used), but in fact, it sensibly lowers them. Then, if even dense arrays are fast, why bother with <code>ArrayNode</code> ? Because using only <code>BitmapIndexedNode</code> also lowers the performances. The exact frontier (in terms of proportional filling of the array) between the two constructors is not yet determined, but these values seems to make it behave well:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="ot">module</span> StdConfig : <span class="dt">CONFIG</span> = <span class="kw">struct</span>
  <span class="kw">let</span> shift_step = 5
  <span class="kw">let</span> bmnode_max = 16
  <span class="kw">let</span> arrnode_min = 8
<span class="kw">end</span></code></pre>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="ot">module</span> StdConfig32 : <span class="dt">CONFIG</span> = <span class="kw">struct</span>
  <span class="kw">let</span> shift_step = 4
  <span class="kw">let</span> bmnode_max = 8
  <span class="kw">let</span> arrnode_min = 4
<span class="kw">end</span></code></pre>
<p>There is also a point to be noticed: as OCaml uses one bit of the integers for garbage collecting purposes, on 64 bits architectures, we can only use 32 bits bitmaps. This also leads to a performance issue: shiftings, intensely used in HAMT (as in every bit manipulating code), are not straight processor shiftings, because this supplementary bit has to be conserved. It cannot simply be solved in OCaml, so we must take it into account when reasoning about the performances we can expect (and the tests showed the structure was still interesting).</p>
<p>The general purpose modification function is this one:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">val</span> alter : key -&gt; ('a <span class="dt">option</span> -&gt; 'a <span class="dt">option</span>) -&gt; 'a t -&gt; 'a t</code></pre>
<p>It uses <code>option</code> type to be generic over the modification you want to implement: this allows to write only a big function (73 lines) to manage all possible cases, but could degrade the performances. When the module is stable, it could be specialised. The same sort of interface is used for the <code>alter_all</code> function, specialised in <code>map</code>, <code>filter</code> and all these things.</p>
<p>As we just saw, HAMT use many arrays. Therefore, at the insertion of an element, you need to recopy all the arrays from him to the root of the structure to keep it persistent. When you need to insert at one time many values, copying the ancestors for every element would uselessly long: we can just copy the destination HAMT first, and then use mutability to modify it in place before returning it. Internally, the mutability allows better performances, and using correct module interfaces we can prevent the user from unwillingly break his code by muting his structures. The <em>real</em> alter function (not exported) thus has this type:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">val</span> alter_node : 
  ?mute:bool -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; Key<span class="kw">.</span>t -&gt; 
  ('a <span class="dt">option</span> -&gt; 'a <span class="dt">option</span>) -&gt; 'a t -&gt; 'a t</code></pre>
<p>The first <code>int</code> parameter is the hash shift value at the given depth (it is given <code>0</code> at the beginning and is recursively incremented), the second one is the hashed value of the key (which is computed once and recursively given as a parameter rather than calculate it for every chunk). Therefore we can define another function, useful for imports:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> add_mute k v hamt =
    alter_node ~mute:true 0 (hash key) k (<span class="kw">fun</span> _ -&gt; <span class="dt">Some</span> v) hamt

<span class="ot">module</span> Import =

  <span class="kw">struct</span>

    <span class="ot">module</span> <span class="kw">type</span> <span class="dt">FOLDABLE</span> = <span class="kw">sig</span>
      <span class="kw">type</span> key
      <span class="kw">type</span> 'v t
      <span class="kw">val</span> fold : (key -&gt; 'v -&gt; 'a -&gt; 'a) -&gt; 'v t -&gt; 'a -&gt; 'a
    <span class="kw">end</span>

    <span class="ot">module</span> Make (<span class="dt">M</span> : <span class="dt">FOLDABLE</span> <span class="kw">with</span> <span class="kw">type</span> key = key) =
    <span class="kw">struct</span>
      <span class="kw">let</span> add_from x hamt = M<span class="kw">.</span>fold add_mute x (copy hamt)
      <span class="kw">let</span> from x = add_from x <span class="dt">Empty</span>
    <span class="kw">end</span>

<span class="kw">end</span></code></pre>
<p>The module <code>Import</code> provides a function usable to import many values in a HAMT, empty or not, from a structure that you can fold. It uses mutability to speed-up the process. Obviously, if your destination HAMT is already big and your structure quite small, copying the big full HAMT before muting him a few times can be slower than copying a few times the line from the root to an inserted value. When the limit is reached is to be established by the user (because a theoretical formula with logarithms would probably not be that pertinent in real code).</p>
<p>The rest of the code is quite straightforward once you understood the principles of the structure.</p>
<h3 id="conclusion">Conclusion</h3>
<p>The HAMT data structure appears to be quite promising for the language OCaml. Both its theoretical complexity and practical performances make it a good competitor to the great old Map, as long as your program does not already rely on comparisons.</p>
<p>However, this implementation should be considered more as a proof of concept rather than the final and optimal way to implement them. There are still many behaviours to be tested and understood, and quickly coded functions which could take advantage of a more thorough reflection.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn1"><p><a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">Ideal Hash Trees</a>, 2001, Phil Bagwell, Institute of Core Computing Science, Swiss Institute of Technology Lausanne<a href="http://gallium.inria.fr/blog/index.rss#fnref1">↩</a></p></li>
<li id="fn2"><p>I must confess that I think I did not totally understand this part, because I do not exactly come to the same conclusions.<a href="http://gallium.inria.fr/blog/index.rss#fnref2">↩</a></p></li>
</ol>
</div><a onclick="switchContent('post6','post5')" class="btn" href="#83e740a394d1c2d5ca61795a79a53c3e">Hide</a></div></span>
<a name="610045c7d8000afbc439e261716c2bb5"></a><span class="rss-header"><span class="rss-title"><a href="http://blog.incubaid.com/2013/02/01/user-functions-in-arakoon/"> User functions in Arakoon</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Incubaid Research</span>, <span class="rss-date">01 Feb 2013</span></span><span class="rss-description">Mahomet cald the Hill to come to him. And when the Hill stood still, he was neuer a whit abashed, but said; If the Hill will not come to Mahomet, Mahomet wil go to the hill. Francis Bacon Introduction Arakoon tries to be a simple distributed key value store that favours consistency over availability. From [...]<img src="http://stats.wordpress.com/b.gif?host=blog.incubaid.com&amp;blog=27780527&amp;post=990&amp;subd=incubaid&amp;ref=&amp;feed=1" alt="" height="1" border="0" width="1"/></span>
<a name="a659aff02da99b91b3ba73c089b356a6"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=844"> BER MetaOCaml 100</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">31 Jan 2013</span></span><span class="rss-description">BER MetaOCaml is a streamlined version of MetaOCaml -- a conservative extension of OCaml with the primitive type of code values, and three basic multi-stage expression forms: Brackets, Escape, and Run.</span>
<a name="a3e64a86c3d2ae3b4f9ccb8dcba2ee6d"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=416"> Ocurl 0.5.4</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">31 Jan 2013</span></span><span class="rss-description">An OCaml binding for the
libcurl multi-protocol file transfer library.</span>
<a name="1a026b7f6cf6c617e92908a40e7123d9"></a><span class="rss-header"><span class="rss-title"><a href="http://hongboz.wordpress.com/2013/01/31/discussions-on-the-syntactic-meta-programmingwg-camlp4-list/"> Discussions on the Syntactic Meta Programming(wg-camlp4 list)</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Hong bo Zhang</span>, <span class="rss-date">31 Jan 2013</span></span><span class="rss-description"><div id="post7"><p>There are some interesting discussions in the wg-camlp4 mailing list, I wrote a long mail yesterday, I cleaned it a bit, pasted it here </p>
<p>———</p>
<div> I rewrite the whole camlP4(named Fan) from scratch, building the quotation kit and throw away the crappy grammar parser, so plz believe me <b>that I do understand the whole technology stack of camlP4</b>, if we could reach some consensus, I would be happy to handle over the maintaining of  Fan, Fan does not loose any feature compared with camlP4, in fact it has more interesting featrues.</div>
<div> </div>
<div>   Let’s begin with some easy, not too technical parts which has a significant effect on user experience though:</div>
<div>   1. Performance</div>
<div>          Performance does matter, it’s a shame that  the most time spent in compiling the ocaml compiler is dedicated to camlP4, but it is an engineering problem, currently compiling Fan only takes less than 20s, and it can be improved further</div>
<div>   2. Building issues</div>
<a onclick="switchContent('post7','post8')" class="btn" href="#1a026b7f6cf6c617e92908a40e7123d9">Read more...</a></div><div id="post8" style="display: none"><p>There are some interesting discussions in the wg-camlp4 mailing list, I wrote a long mail yesterday, I cleaned it a bit, pasted it here </p>
<p>———</p>
<div> I rewrite the whole camlP4(named Fan) from scratch, building the quotation kit and throw away the crappy grammar parser, so plz believe me <b>that I do understand the whole technology stack of camlP4</b>, if we could reach some consensus, I would be happy to handle over the maintaining of  Fan, Fan does not loose any feature compared with camlP4, in fact it has more interesting featrues.</div>
<div> </div>
<div>   Let’s begin with some easy, not too technical parts which has a significant effect on user experience though:</div>
<div>   1. Performance</div>
<div>          Performance does matter, it’s a shame that  the most time spent in compiling the ocaml compiler is dedicated to camlP4, but it is an engineering problem, currently compiling Fan only takes less than 20s, and it can be improved further</div>
<div>   2. Building issues</div>
<div>        The design of having side effects by dynamic loading is generically a bad idea, in Fan<b> the dynamic loading only register some functionality the Fan support,</b> it <b>does not have any other side effec</b>t, each file stands alone says which (ppx , or filters, or syntax) it want to use with a good default option. so the building is always something like ‘-pp fan pluging1 plugin2 plugin3′, <b>the order of pulgings does not matter</b>, also, l<b>oading all the plugins you have does not have any side effect, even better, you can do the static linking all the plugins you collected, the building process is simplified.  </b></div>
<div><b> </b> 3. Grammar Extension (<b>Language namespace</b>)</div>
<div><b>       </b>I concur that grammar extension arbitrarily is a bad idea, and I agree with Gabrier that so far only the quotation(Here  quotation means delimited DSL, quosi-quotation means Lisp style macros) is modular, composable, and  I also agree with Gabrier -ppx<b> should not be used to do syntax overriding (this should not be called syntax extension actually), </b>that’s a terrible idea to do syntax overriding, since the user never understand what’s going on underly without reading the Makefile. So here some my suggestion is that some really conevenient syntax extesion, i.e, (let try.. in) should be merged to the built in parser. quotations does not bring too much heavy syntax (imho). In Fan, we proposed the concept of a hierarchical language name space, since once quotation is heavily used, it’s really easy to introduce conflict, <b>the language namespace querying is exactly like java package namespace,</b> you can import, close import to save some typing.</div>
<div>    Here is a taste</div>
<div>   ———————————————————————————————–</div>
<div>     {:.Fan.Lang.Meta.expr| a + b |} ——&gt; </div>
<div>      `App (`App ((`Id (`Lid “+”)), (`Id (`Lid “a”)))), (`Id (`Lid “b”)))</div>
<div>     {:.Fan.Lang.Meta.N.expr| a + b |}  —–&gt;</div>
<div>      `App</div>
<div>    (_loc,</div>
<div>      (`App</div>
<div>         (_loc, (`Id (_loc, (`Lid (_loc, “+”)))),</div>
<div>           (`Id (_loc, (`Lid (_loc, “a”)))))),</div>
<div>      (`Id (_loc, (`Lid (_loc, “b”))))) </div>
<div>
<div> ———————————————————————————————–</div>
<div> the .Fan.Lang.Meta.expr the first ‘.’ means it’s from the absolute namespace,  the <b>N.expr shares exactly the same syntax without location</b>, though</div>
</div>
<div> </div>
<div>   4. Portable to diffierrent compiler extensions(like LexiFi’s fork of ocaml)</div>
<div>       I am pretty sure it’s pretty easy to do in Fan, only Ast2pt (dumping the intemediate Ast into Parsetree) part need to be changed to diffierent compilers.
<div> </div>
<div>—————————————————————————————————————-</div>
<div>Now let’s talk about some internal parts of SMP.</div>
<div>Quasi-Quotation is the essential part of SMP,  I am surprised so far that the discussion <b>silently ignores the quasi-quotation,</b> Leo’s answer of writing   three parsers is neither satisfying nor practical(imho). </div>
<div> </div>
<div>Camlp4 is mainly composed of two parts, one is the extensible parser and <b>the other significant part is Ast Lifting</b>. Since we all agree that extensible parser increases the complexity too much, let’s simply ignore that part.</div>
<div> </div>
<div>The Ast Lifting are tightly coupled <b>with the design of the Abstract Syntax Tree.</b>  People complain about that Camlp4 Ast is hard to learn and using quasi-quotation to do the pattern match is a bad idea.</div>
<div> </div>
<div>Let me explain the topic a bit:</div>
<div>    Camlp4Ast is hard to learn, I agree, it has some alien names that nobody understand what it  means, quosi-quotation <b>is definitely a great idea</b> to boom the meta-programming, but my experience here is <b>for very very small Ast fragment, using the Abstract Syntax Tree directly,</b> otherwise Quasi-quotation is a life saver to do the meta programming.</div>
<div>   Luckily the quotation kit has nothing to do with the parser part, it’s simply several functions(I did some simplify a bit) which turns a normal runtime  </div>
<div>value into an Ast node generically, <b>such kind functions are neither easy to write nor easy to read</b>,<b>the idea case is that it should be generated once for all, and all the data types in normal ocaml</b><b>should be derived automatically</b>(some ADT with functions can not be derived). <b>I bet it’s mostly likely a nightmare if we maintain 3 parsers for the ocaml grammar while two other parsers dumping to a meta-level</b></div>
<div>  </div>
<div>   So, how to make Ast Lifting easier, </div>
<div>        The first guideline is <b>“Don’t mixing with records”, </b></div>
<div><b>         </b>Once you encoding AST with records, you have to encode the records in the meta level which increases the complexity without bringing any new features, <b>it’s simply not worthwhile.</b></div>
<div><b> </b></div>
<div><b>       </b> The second guideline is “Don’t do <b>any </b>syntax desugaring” , syntax desguaring makes the semantics of syntax meta programming a bit weird. Syntax desguaring happens everywhere in Parsetree, think about the list literals, it uses the syntax desuaring, if you don’t use any syntax desugaring, for example, you want to match the bigarray access, you simply needed to match `Bigarray(..)’ instead of </div>
<div>
<div> </div>
<div>Pexp_apply</div>
<div>        ({pexp_desc=Pexp_ident</div>
<div>                     {txt= Ldot (Ldot (Lident “Bigarray”, array), (“get”|”set” as gs)) ;_};_},</div>
<div>         label_exprs)</div>
</div>
<div>—————————-</div>
<div>       The third guideline is to<b> </b>make it <b>as uniform as possible</b></div>
<div><b>       </b>This not only helps the user, but <b>it helps the meta-programming over types to derive some utility types. </b>Take a look at my Ast encoding in Fan <a href="https://github.com/bobzhang/Fan/blob/master/src/Ast.ml" target="_blank">https://github.com/bobzhang/Fan/blob/master/src/Ast.ml</a> (it needs to be polished, plz don’t panic when you see variants I use here)</div>
<div><b>      </b>The initial Ast has locations and ant support, but<b> here we derive 3 other Asts thanks to my very regular design</b>.<b> AstN is the Ast without locations</b>, the locations are important, but it is simply not too much helpful when you only do the code generation, but it complicates the expanded code a lot), <b>AstA is the Ast without antiquotations(simply remove the ant branch), </b>it is a subtype of Ast(thanks to the choice we use variants here), <b>AstNA is the Ast without neither locations nor antiquotations</b>), it is a subtype of AstN.  <b>In practice, I found the Ast without locations is particular helpful when you only do the code generation, it simplifies this part significantly.<i><span style="text-decoration: underline;"> The beautif</span></i></b><span style="text-decoration: underline;"><b><i>u</i></b><i>l part is that  all the four Ast share the same grammar with the same quosiquotatoin mechanism, as I showed .Fan.Lang.N.expr and .Fan.Lang.expr</i></span></div>
<div>    I don’t know how many parsers you have to maintain to reach such a goal or it’s never going to happen.</div>
<div>    Using variants to encode the intermediate ast has a lots of other benefits, but I don’t want to cover it in such a short mail.</div>
<div> </div>
<div>   So,<b> my proposal is that the community design an Intermediate Ast together, and write a built-in parser to such Intermediate Ast then dump to Parsetree, but I am for that Parsetree still needs to be cleaned a bit but not too much change .  </b>I do appreciate you can take something away from Fan, I think the Parsetree is<b> not the ideal part</b> to do SMP, HTH</div>
</div>
<p> </p>
<br/>  <a href="http://feeds.wordpress.com/1.0/gocomments/hongboz.wordpress.com/69/" rel="nofollow"><img src="http://feeds.wordpress.com/1.0/comments/hongboz.wordpress.com/69/" alt="" border="0"/></a> <img src="http://stats.wordpress.com/b.gif?host=hongboz.wordpress.com&amp;blog=40164267&amp;post=69&amp;subd=hongboz&amp;ref=&amp;feed=1" alt="" height="1" border="0" width="1"/><a onclick="switchContent('post8','post7')" class="btn" href="#1a026b7f6cf6c617e92908a40e7123d9">Hide</a></div></span>
<a name="14157a6ff510a7115b1195580c0b23fd"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/blog/introduction-to-mezzo-2"> Introduction to Mezzo, continued</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">30 Jan 2013</span></span><span class="rss-description"><div id="post9"><p>In the previous blog post, I introduced a new framework for reasoning about programs: permissions, a sort of hybrid between a type system and a program logic. The main selling point is that it allows one to reason in a finer-grained manner about programs. The current incarnation of the permission mechanism is <a href="http://gallium.inria.fr/~protzenk/mezzo-lang/"><em><strong>Mezzo</strong></em></a>, a language in the tradition of ML.</p>
<p>The first question that comes fairly naturally is: why are we going such great lengths trying to design such a complex reasoning framework? Here are some answers:</p>
<ul>
<li>since mutable portions of the heap have a unique owner, programs written in <em><strong>Mezzo</strong></em> enjoy the property that they are data-race free, that is, we may never have two people trying to access a writable location at the same time;</li>
<li>thus, we are allowed to perform strong updates, that is, updates that change the type of a variable.</li>
</ul>
<a onclick="switchContent('post9','post10')" class="btn" href="#14157a6ff510a7115b1195580c0b23fd">Read more...</a></div><div id="post10" style="display: none"><p>In the previous blog post, I introduced a new framework for reasoning about programs: permissions, a sort of hybrid between a type system and a program logic. The main selling point is that it allows one to reason in a finer-grained manner about programs. The current incarnation of the permission mechanism is <a href="http://gallium.inria.fr/~protzenk/mezzo-lang/"><em><strong>Mezzo</strong></em></a>, a language in the tradition of ML.</p>
<p>The first question that comes fairly naturally is: why are we going such great lengths trying to design such a complex reasoning framework? Here are some answers:</p>
<ul>
<li>since mutable portions of the heap have a unique owner, programs written in <em><strong>Mezzo</strong></em> enjoy the property that they are data-race free, that is, we may never have two people trying to access a writable location at the same time;</li>
<li>thus, we are allowed to perform strong updates, that is, updates that change the type of a variable.</li>
</ul>
<p>The latter item may seem of dubious usefulness; indeed, the <code>mswap</code> example that I used seems artificial, and I have never needed it in practice. However, the example of <code>concat</code> at the end of the <a href="http://gallium.inria.fr/blog/introduction-to-mezzo/">previous post</a> is much more useful: it is emblematic of a more general concept of “destination-passing-style” algorithms that allow one to write functions in a safe, tail-recursive way, without resorting to unsafe hacks.</p>
<p>However, as I hinted in the conclusion of the previous blog post, with the elements I have presented so far, there are some serious limitations.</p>
<p>In this blog post, I will introduce a novel mechanism called <em>adoption</em> and <em>abandon</em>, which allows one to safely alias mutable data, while remaining inside the permission framework; in particular, this means we'll continue to guarantee the unique-owner property for mutable blocks. Of course, there's no free lunch: this <em>adoption</em> and <em>abandon</em> mechanism incurs a dynamic cost at runtime.</p>




<h3 id="a-story-of-adoption-and-abandon">A story of adoption and abandon</h3>
<h4 id="meet-the-fifo-our-favorite-example">Meet the fifo, our favorite example</h4>
<p>The running example in this section will be a first-in first-out structure, that is, a fifo. Cells are appended at the end, and popped from the front of the fifo. The loop at the end of the fifo is just a trick to avoid making the <code>next</code> field an <code>option</code> type.</p>
<div class="figure">
<img src="http://gallium.inria.fr/blog/fifo.svg" alt="The pointer structure of the fifo"/><p class="caption">The pointer structure of the fifo</p>
</div>
<ul>
<li>The type <code>cell</code> is mutable: we need to rewire the pointers when we we call either <code>retrieve</code> or <code>insert</code> on the fifo.</li>
<li>The type <code>fifo</code> is also mutable, since its <code>head</code> and <code>tail</code> fields change over time.</li>
</ul>
<h4 id="an-aliasing-problem">An aliasing problem</h4>
<p>One can see already that there is a problem with this aliasing pattern. If there's only one element in the fifo, and the user does:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> x = fifo.head <span class="kw">in</span>
<span class="kw">let</span> y = fifo.tail <span class="kw">in</span>
<span class="co">(* x @ cell ∗ y @ cell *)</span></code></pre>
<p>...then the user has aliased the same cell, and has two exclusive permissions for it. This is a violation of our rules, and the permission system definitely won't allow that! So we can't declare the <code>head</code> and <code>tail</code> field to be <code>cell</code>s...</p>
<h4 id="getting-back-an-ownership-tree">Getting back an ownership tree</h4>
<p>In essence, the problem is that the ownership graph is not a forest, and the permission system can only express forest-like ownership patterns. We need to move back to a forest-like ownership pattern. We achieve this through the <em>adoption</em> mechanism.</p>
<p>We say that the fifo can now <em>adopt the cells</em>. That is, the permission for the cells is “hidden” under the permission for the fifo; in other words, if you own the fifo, you own the cells. Once adopted, the type of a cell changes to reflect the fact that it may be owned by someone else.</p>
<h5 id="some-data-types">Some data types</h5>
<p>Let us first take a look at the definition of type <code>fifo a</code> and <code>cell a</code>, respectively fifo and cells holding elements of type <code>a</code>.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">mutable</span> data fifo a =
  | <span class="dt">Empty</span> { head: (); tail: () }
  | <span class="dt">NonEmpty</span> { head: dynamic; tail: dynamic }
adopts cell a

<span class="kw">mutable</span> data cell a =
  | <span class="dt">Cell</span> { contents: a; next: dynamic }</code></pre>
<p>The important point here is the <code>adopts</code> clause that's attached to the definition of <code>fifo</code>; this clause refers to the whole type. We will see in a minute the meaning of type <code>dynamic</code>.</p>
<h5 id="adoption">Adoption</h5>
<p>The first operation consists in giving up our ownership of a cell, and transferring it to the fifo object.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* x @ cell a ∗ f @ fifo a *)</span>
give x <span class="kw">to</span> f;
<span class="co">(* x @ dynamic ∗ f @ fifo a *)</span></code></pre>
<p>After we've given up our knowledge of <code>x</code>, we no longer know that it is a cell. The only thing that remains for us to know about <code>x</code> is that it has type <code>dynamic</code>: it means that <code>x</code> may be currently adopted by someone.</p>
<p>What is the point, then, of giving up our knowledge of <code>x</code>? The key difference is that, unlike <code>cell a</code>, <code>dynamic</code> is a duplicable type, which means we can alias <code>x</code>.</p>
<h5 id="abandon">Abandon</h5>
<p>The converse operation, abandon, works as follows; it allows one to regain the whole knowledge about a variable; in our case, regain the permission <code>x @ cell a</code>.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* x @ dynamic ∗ f @ fifo a *)</span>
take x from f;
<span class="co">(* x @ cell a ∗ f @ fifo a *)</span></code></pre>
<p>How do we know that the type that <code>x</code> should regain is <code>x @ cell a</code>? This is achieved by doing a lookup on the definition of <code>f</code>, and seeing that fifos adopt elements of type <code>cell a</code>.</p>
<p>An element, in order to be an adopter, must be mutable. Moreover, adopters can only adopt one type of elements.</p>
<p>The safety of the whole thing depends on the fact that the <em>take</em> operation must never succeed twice, otherwise we could have <code>x @ cell a ∗ x @ cell a</code>: this would be a definite breach of soundness.</p>
<p>The general idea is that when you <code>give</code> an element, you become free to alias it, but it is your responsibility to make sure you never <code>take</code> it twice, that is, to make sure you never call <code>take x from f; take y from f</code> with <code>x</code> and <code>y</code> being aliases. In the case of the fifo, it is easy to make mistakes: if the fifo only has one element, the following code will fail:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">take fifo.head from fifo;
take fifo.tail from fifo;</code></pre>
<h5 id="making-sure-the-code-fails">Making sure the code fails</h5>
<p>The last point that we need to address is how to make sure that the <em>take</em> operation cannot succeed twice for the same element. This is achieved using a hidden field and dynamic tests.</p>
<p>Each mutable object has a hidden field; the hidden field contains the address of the adopter if the object is currently adopted, <code>null</code> otherwise.</p>
<ul>
<li>When <code>give</code>'ing <code>x</code> to <code>f</code>, we set the hidden field of <code>x</code> to be the address of <code>f</code>.</li>
<li>When taking <code>x</code> from <code>f</code>, we check that the hidden field of <code>x</code> and the address of <code>f</code> match; if this is the case, we can safely assume that <code>x</code> has the type to be found in the <code>adopts</code> clause in the definition of the type of <code>f</code>; then, we null out the field.</li>
</ul>
<p>In the example of the one-element fifo, after taking <code>head</code>, the hidden field would be nulled out, and the second attempt to take <code>tail</code> would fail, since the value in the hidden field (<code>null</code>) and the address of the adopter would fail to match.</p>
<h4 id="illustrating-all-these-concepts">Illustrating all these concepts</h4>
<p>In order to better understand how we use all these mechanisms to type-check a program, we have a step-by-step animation explaining how a given piece of code is type-checked. We chose the <code>insert</code> function that inserts an element into the fifo.</p>
<p><a href="http://gallium.inria.fr/blog/insert-full.raw.html" class="fancybox fancybox.iframe">See the <code>insert</code> example</a> (use the "step forward" and "step back" links).</p>
<p>Some notes about this example:</p>
<ul>
<li>the <code>dynamic</code> permission is always available on-demand for <code>x</code>, as long as we know that there is an exclusive permission for <code>x</code>;</li>
<li>we use the <code>tag of &lt;-</code> instruction; it allows one to <em>change the tag</em> of a value; the definition for the new tag must have the same number of fields;</li>
<li>structural types feature an <code>adopts</code> clause – without it, the system would be unsound;</li>
<li>when we enter the function, the permissions we gain are those brought to us through the arguments;</li>
<li>when we exit the function, we must make sure <code>f @ fifo a</code> is still available; however, because <code>x</code> is consumed, we don't have anything to ensure about <code>x</code>.</li>
</ul>
<h4 id="the-power-of-adoptionabandon">The power of adoption/abandon</h4>
<p>Adoption and abandon provide an easy escape hatch to make sure you can write your program, even if the aliasing pattern is too complex to be expressed in the pure permission mechanism. The <code>give</code> and <code>take</code> operations are thread-safe; they incur no race conditions, that is, <code>give</code> cannot succeed in two separate threads simultaneously.</p>
<p>Of course, there is a penalty, both in terms of memory space (hidden field) and runtime tests (<code>give</code> and <code>take</code> operations). Time will tell whether this is something that we can live with, or if it is too expensive. A short-term goal is to allow one to declare a data type is being “slim” (no hidden field) or “fat” (with a hidden field). A long-term goal is to allow one to plug in a proof that the extra dynamic tests are not needed, so that the compiler can skip the tests altogether.</p>
<h3 id="what-is-the-state-of-mezzo">What is the state of <em><strong>Mezzo</strong></em>?</h3>
<p>If you've reached that stage of the blog post, you have my entire gratitude, as this was quite a technical topic and I'm afraid it has been fairly long.</p>
<h4 id="the-prototype">The prototype</h4>
<p>We currently have a prototype type-checker that is available on our <a href="http://gallium.inria.fr/~protzenk/mezzo-lang/">web page</a>, along with several examples of programs that the type-checker currently accepts. There is a fairly long to-do list, and the type-checker is currently unsound in many corners, but this is something that we're aware of and that we know how to fix.</p>
<h4 id="concurrency">Concurrency</h4>
<p>Of course, if we are to go such great lengths, we might as well have concurrency built into the language. <a href="http://gallium.inria.fr/~balabons/">Thibaut Balabonski</a> is currently tackling the problem. Here is an example of how we could leverage the permission mechanism:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">abstract lock (p: perm)
fact duplicable (lock p)
<span class="kw">val</span> create @ [p :: <span class="dt">PERM]</span> () -&gt; lock p
<span class="kw">val</span> acquire @ [p :: <span class="dt">PERM]</span> lock p -&gt; (| p)
<span class="kw">val</span> release @ [p :: <span class="dt">PERM]</span> (lock p | consumes p) -&gt; ()</code></pre>
<p>A lock simply protects access to a permission (think of <code>p</code> as <code>x @ ref int</code> where <code>x</code> is a variable in scope). You can copy the lock around, pass it to other threads, and try to <code>acquire</code> it: when you succeed, you obtain the permission. When you want to <code>release</code> the lock, you must give up the permission from your context.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">data outcome (p :: <span class="dt">PERM</span>) =
  | <span class="dt">Success</span> { | p }
  | <span class="dt">Failure</span> { }

<span class="kw">val</span> try_acquire @ [p :: <span class="dt">PERM]</span> lock p -&gt; outcome p</code></pre>
<p>If we were to implement <code>try_acquire</code>, we could write a data type that expresses the fact that in case the operation succeeds, you obtain <code>p</code> in the corresponding <code>match</code> branch.</p>
<p>The signature for a <code>spawn</code> function could be as follows:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">val</span> spawn (f: (|p) -&gt; () | p) -&gt; ()</code></pre>
<p>...where <code>f</code> requires a set of permissions <code>p</code> to execute, and <code>spawn</code> takes <code>p</code> from its caller, and uses it to launch <code>p</code>.</p>
<h4 id="compilation">Compilation</h4>
<p>We had an intern, Henri Chataing, work on a very prototype-ish implementation of a compilation scheme emitting OCaml code with calls to <code>Obj.magic</code> sprinkled in the right places. We're unsure as to whether that's the right direction; we're also considering emitting CIL code, or C# code directly to take advantage of the real multithreaded capabilities of the CLR...</p>
<h4 id="i-want-to-participate">I want to participate!</h4>
<p>We have many opportunities for internships, do contact us if you feel like you want to work on designing an exciting new language!</p><a onclick="switchContent('post10','post9')" class="btn" href="#14157a6ff510a7115b1195580c0b23fd">Hide</a></div></span>
<script type="text/javascript">function switchContent(id1,id2) {
     // Get the DOM reference
     var contentId1 = document.getElementById(id1);
     var contentId2 = document.getElementById(id2);
     // Toggle
     contentId1.style.display = "none";
     contentId2.style.display = "block";
     }</script></div>

  
    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>

    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-37808023-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

    </script>

</body></html>
