<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: OCaml Planet</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contrinutors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="OCaml Planet" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it in your browser</a></li>
    <li><a href="../taste.html">A Hundred Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who is using it?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development tools</a></li>
    <li><a href="../documentation.html">Manuals and Cheat Sheets</a></li>
    <li><a href="../tutorials/#advanced">Advanced tutorials &amp; Papers</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">Github</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing lists</a></li>
    <li><a href="../planet/">OCaml Planet (blogs)</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml-lang.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>OCaml Planet
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

    <h1>OCaml Planet</h1>

    <p>The OCaml Planet aggregates various blogs from the OCaml
    community.  It is kindly provided
    by <a href="http://www.ocamlcore.com/">OCamlCore</a>.  If you
    would like to be added, read
    the <a href="http://www.ocamlcore.org/planet/">Planet
    subscription HOWTO</a>.</p>

    <br/>
    <div style="float: right; margin-right: 0; margin-top: 0" class="span2 planet-subscriptions"><em>Subscriptions</em>
      <ul><li><a href="http://alexleighton.tumblr.com/tagged/ocaml/rss">Alex Leighton</a></li><li><a href="http://blog.mestan.fr/feed/?cat=16">Alp Mestan</a></li><li><a href="http://andreiformiga.com/blog/?cat=5&feed=rss2">Andrei Formiga</a></li><li><a href="http://math.andrej.com/feed/">Andrej Bauer</a></li><li><a href="http://anil.recoil.org/feeds/atom.xml">Anil Madhavapeddy</a></li><li><a href="http://unnali.com/tag/ocaml/feed/">Arlen Cuss</a></li><li><a href="http://ashishagarwal.org/tag/ocaml/feed/">Ashish Agarwal</a></li><li><a href="http://www.blogger.com/feeds/7617521785419311079/posts/default">Cameleon news</a></li><li><a href="http://caml.inria.fr/news.en.rss">Caml INRIA</a></li><li><a href="http://camlspotter.blogspot.com/feeds/posts/default?alt=rss">Caml Spotting</a></li><li><a href="http://alan.petitepomme.net/cwn/cwn.rss">Caml Weekly News</a></li><li><a href="http://procrastiblog.com/category/ocaml/feed/">Christopher Conway</a></li><li><a href="http://coherentpdf.com/blog/?tag=ocaml&feed=rss">Coherent Graphics</a></li><li><a href="http://coq.inria.fr/news/feed">Coq</a></li><li><a href="http://erratique.ch/feeds/news.atom">Daniel Bünzli</a></li><li><a href="http://blog.dbpatterson.com/rss">Daniel Patterson</a></li><li><a href="http://nleyten.com/atom.aspx">Dario Teixeira</a></li><li><a href="http://www.blogger.com/feeds/17133288/posts/default/-/ocaml">David Baelde</a></li><li><a href="http://bentobako.org/david/blog/index.php?feed/tag/ocaml/atom">David Mentré</a></li><li><a href="http://dutherenverseauborddelatable.wordpress.com/category/ocaml/feed/">David Teller</a></li><li><a href="http://www.examachine.net/blog/?feed=rss2&cat=4">Eray Özkural</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/CodeHacking/Ocaml/index.rss20">Erik de Castro Lopo</a></li><li><a href="http://blog.emillon.org/feeds/ocaml.xml">Etienne Millon</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/FP-Syd/index.rss20">FP-Sydney</a></li><li><a href="http://www.blogger.com/feeds/8964007124326996693/posts/default/-/ocaml">Fayssal Martani</a></li><li><a href="http://frama-c.com/rss.xml">Frama-C</a></li><li><a href="http://functionaljobs.com/jobs/search/?q=ocaml&format=rss">Functional Jobs</a></li><li><a href="http://gallium.inria.fr/~scherer/gagallium/index.rss">GaGallium</a></li><li><a href="http://gaiustech.wordpress.com/category/ocaml/feed/">Gaius Hammond</a></li><li><a href="http://blog.camlcity.org/blog/rss">Gerd Stolpmann</a></li><li><a href="http://www.wisdomandwonder.com/tag/OCaml/feed">Grant Rettke</a></li><li><a href="http://blog.incubaid.com/tag/ocaml/feed/">Incubaid Research</a></li><li><a href="http://ambassadortothecomputers.blogspot.com/feeds/posts/default?alt=rss">Jake Donham</a></li><li><a href="http://scattered-thoughts.net/rss?tag=ocaml">Jamie Brandon</a></li><li><a href="http://ocaml.janestcapital.com/?q=rss.xml">Jane Street</a></li><li><a href="http://www.lexifi.com/blogs/ocaml/feed">LexiFi</a></li><li><a href="http://savonet.sourceforge.net/liquidsoap.rss">Liquidsoap</a></li><li><a href="http://syntaxexclamation.wordpress.com/tag/ocaml/feed/">Matthias Puech</a></li><li><a href="http://www.blogger.com/feeds/5888658295182480819/posts/default">Matías Giovannini</a></li><li><a href="http://eigenclass.org/R2/feeds/rss2/all">Mauricio Fernandez</a></li><li><a href="http://www.elehack.net/michael/blog/tags/ocaml?format=rss">Michael Ekstrand</a></li><li><a href="http://www.rktmb.org:82/feed/category/work/ocaml/atom">Mihamina Rakotomandimby</a></li><li><a href="http://nyc-ocaml.posterous.com/rss.xml">NYC OCaml</a></li><li><a href="http://ocamlhackers.ning.com/profiles/blog/feed?tag=ocaml&xn_auth=no">OCaml Hackers</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfnews.php">OCamlCore Forge News</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfprojects.php">OCamlCore Forge Projects</a></li><li><a href="http://www.ocamlcore.com/wp/?feed=rss2&amp;language=en&#038;language=en">OCamlCore.com</a></li><li><a href="http://www.ocamlpro.com/feed/atom.xml">OCamlPro</a></li><li><a href="http://odns.tuxfamily.org/feed/">ODNS project</a></li><li><a href="http://ox.tuxfamily.org/feed/">Ocaml XMPP project</a></li><li><a href="http://ocsigen.org/news.atom">Ocsigen project</a></li><li><a href="http://www.blogger.com/feeds/2073503406800427577/posts/default">Opa</a></li><li><a href="http://www.openmirage.org/blog/atom.xml">Open Mirage</a></li><li><a href="http://www.donadeo.net/facets/programming-languages/objective-caml/feed/">Paolo Donadeo</a></li><li><a href="https://mancoosi.org/~abate/taxonomy/term/5/0/feed">Pietro Abate</a></li><li><a href="http://redlizards.com/blog/feed/?tag=ocaml">Red Lizard Software</a></li><li><a href="http://rwmj.wordpress.com/tag/ocaml/feed/">Richard Jones</a></li><li><a href="http://blog.rastageeks.org/spip.php?page=rss&id_mot=2">Romain Beauxis</a></li><li><a href="http://seb.mondet.org/blog/feed/ocaml.rss">Sebastien Mondet</a></li><li><a href="http://upsilon.cc/~zack/tags/ocaml/index.rss">Stefano Zacchiroli</a></li><li><a href="http://le-gall.net/sylvain+violaine/blog/index.php?feed/tag/ocaml/atom">Sylvain Le Gall</a></li><li><a href="http://caml.inria.fr/hump.rss">The Caml Humps</a></li><li><a href="http://www.blogger.com/feeds/6115529230232389198/posts/default">Till Varoquaux</a></li><li><a href="http://www.nicollet.net/toroidal/ocaml/feed/">Victor Nicollet</a></li><li><a href="http://y-node.com/blog/feeds/tag/ocaml/">y-node</a></li></ul>

      <a href="http://planet.ocaml.org/rss20.xml"><img src=".././img/rss20.png"/></a>
      <a href="http://planet.ocaml.org/opml.xml"><img src=".././img/opml.png"/></a>
    </div>
    <div class="planet"><a name="3736a0b8afed70ff31acacf3b9c5fa8e"></a><span class="rss-header"><span class="rss-title"><a href="http://ocsigen.org/"> Ocsigen Js_of_ocaml 1.3 released</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Ocsigen project</span>, <span class="rss-date">06 Dec 2012</span></span><span class="rss-description"><div id="post1"><p>I'm happy to announce release 1.3 of Js_of_ocaml, a compiler from
OCaml bytecode to Javascript. This release is compatible with OCaml
4.x. It adds WebSocket bindings and fixes a number of bugs.
</p>

<h2>Links</h2>

<ul>
<li><a href="http://ocsigen.org/js_of_ocaml/">Project home page</a>
</li><li><a href="http://ocsigen.org/download/js_of_ocaml-1.3.1.tar.gz">Download</a>
</li><li>Get source code: <code>darcs get http://ocsigen.org/darcs/js_of_ocaml/</code>
</li><li><a href="http://ocsigen.org/js_of_ocaml/manual/">Documentation</a>
</li>
</ul>

<h2>Changes</h2>

<h3>Features/Changes</h3>
<ul>
<li>Runtime and toplevel updates to support OCaml 4.0
</li><li>Add WebSocket bindings
</li><li>Added -debuginfo option to output source code location information
    (patch by Kensuke Matsuzaki)
</li><li>Dom_html: added change, input and hashChange event bindings
</li>
</ul>

<h3>Bugfixes</h3>
<a onclick="switchContent('post1','post2')" class="btn" href="#3736a0b8afed70ff31acacf3b9c5fa8e">Read more...</a></div><div id="post2" style="display: none"><p>I'm happy to announce release 1.3 of Js_of_ocaml, a compiler from
OCaml bytecode to Javascript. This release is compatible with OCaml
4.x. It adds WebSocket bindings and fixes a number of bugs.
</p>

<h2>Links</h2>

<ul>
<li><a href="http://ocsigen.org/js_of_ocaml/">Project home page</a>
</li><li><a href="http://ocsigen.org/download/js_of_ocaml-1.3.1.tar.gz">Download</a>
</li><li>Get source code: <code>darcs get http://ocsigen.org/darcs/js_of_ocaml/</code>
</li><li><a href="http://ocsigen.org/js_of_ocaml/manual/">Documentation</a>
</li>
</ul>

<h2>Changes</h2>

<h3>Features/Changes</h3>
<ul>
<li>Runtime and toplevel updates to support OCaml 4.0
</li><li>Add WebSocket bindings
</li><li>Added -debuginfo option to output source code location information
    (patch by Kensuke Matsuzaki)
</li><li>Dom_html: added change, input and hashChange event bindings
</li>
</ul>

<h3>Bugfixes</h3>
<ul>
<li>Fix array and string blitting with overlapping regions
</li><li>Url module: fix encoding of '+'
</li><li>Library: use 'this' instead of 'window' for better portability
</li><li>Dom_html: fix creation of elements with type or name attribute
    under IE 9
</li><li>Compiler: small fix to bytecode parsing that could result in
    incorrect generated code
</li><li>Dom_html: fix mouse wheel event bindings
</li><li>Dom: fix the type of item methods
</li><li>Deriving_json: tail-recursive serialisation of lists (by Hugo Heuzard)
</li><li>Deriving_json: fix parsing of float arrays and polymorphic variants
    (by Hugo Heuzard)
</li>
</ul>
<p>
-- Jérôme Vouillon
</p>
<p>
To get more frequent annoucements about Ocsigen, follow us on 
<a href="https://twitter.com/ocsigen">Twitter</a>,
<a href="https://plus.google.com/u/0/105890612060116987398/posts">Google+</a>, or
<a href="https://www.facebook.com/pages/Ocsigen/289974521051526">Facebook</a>.</p><a onclick="switchContent('post2','post1')" class="btn" href="#3736a0b8afed70ff31acacf3b9c5fa8e">Hide</a></div></span>
<a name="3c33eeb4f6e8fa3c634ac1b143a45a68"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/~scherer/gagallium/your-first-coq-plugin/index.html"> Emancipate yourself from LTac: Your first Coq plugin</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">05 Dec 2012</span></span><span class="rss-description"><div id="post3"><p>I recently started a post-doc in the Gallium team, and it is past
due-time for my first blog post. I will not start with a research
oriented blog right now (but stay tuned!); and I will rather talk
about one of my hobbies: writing Coq plugins in OCaml to build new
tactics. I reckon that this deviates a bit from standard practice, so
I will try to make things clear.</p>




<p>First, a Coq proof script is usually a program written in
<em>LTac</em>. Executing a proof script builds incrementally a
<em>proof-term</em>. The tactics themselves are not trusted: at <code>Qed</code> time, Coq
checks that the proof term that was built is well-typed and that its
type is the same as the statement of the theorem. One must remember
that LTac tactics can always be understood in terms of manipulations
of partial proof terms; and it is often instructive to get an idea of
the proof term that is being built, using the <code>Show Proof</code> vernacular
command.</p>

<a onclick="switchContent('post3','post4')" class="btn" href="#3c33eeb4f6e8fa3c634ac1b143a45a68">Read more...</a></div><div id="post4" style="display: none"><p>I recently started a post-doc in the Gallium team, and it is past
due-time for my first blog post. I will not start with a research
oriented blog right now (but stay tuned!); and I will rather talk
about one of my hobbies: writing Coq plugins in OCaml to build new
tactics. I reckon that this deviates a bit from standard practice, so
I will try to make things clear.</p>




<p>First, a Coq proof script is usually a program written in
<em>LTac</em>. Executing a proof script builds incrementally a
<em>proof-term</em>. The tactics themselves are not trusted: at <code>Qed</code> time, Coq
checks that the proof term that was built is well-typed and that its
type is the same as the statement of the theorem. One must remember
that LTac tactics can always be understood in terms of manipulations
of partial proof terms; and it is often instructive to get an idea of
the proof term that is being built, using the <code>Show Proof</code> vernacular
command.</p>

<p>Usually, one build new tactics in LTac. LTac is a powerful
domain-specific language with some interesting programming constructs,
and it is possible to build powerful new tactics using a few
combinators and leveraging the existing automation (builtin tactics,
decision procedures and so on). I have read that LTac is vindicated as
one of the <a href="http://adam.chlipala.net/cpdt/html/Intro.html">strong points of
Coq</a>, and part of me agree with that statement: there is a lot of
use cases in which LTac is a good tool.  Yet, writing a LTac tactic
is often tedious, the code that needs to be written is hard to debug,
and it may be quite inefficient.</p>

<p>The alternative is to write custom tactics in OCaml, the meta-language
that is used to implement Coq (and all the primitive tactics). In the
following, I will demonstrate how to write such a tactic, and give you
a handful of the necessary entry points into Coq's code.</p>

<p>The tactic that we are going to code is the following one, shamefully
stolen from Compcert's code.</p>

<pre class="code-"><span class="hl kwd">Lemma</span> modusponens<span class="hl opt">:</span> forall <span class="hl opt">(</span><span class="hl kwd">P Q</span><span class="hl opt">:</span> <span class="hl kwd">Prop</span><span class="hl opt">),</span> <span class="hl kwd">P</span> <span class="hl opt">-&gt; (</span><span class="hl kwd">P</span> <span class="hl opt">-&gt;</span> <span class="hl kwd">Q</span><span class="hl opt">) -&gt;</span> <span class="hl kwc">Q</span><span class="hl opt">.</span>
<span class="hl kwc">Proof</span><span class="hl opt">.</span> auto<span class="hl opt">.</span> <span class="hl kwc">Qed</span><span class="hl opt">.</span>

<span class="hl kwd">Ltac</span> exploit x <span class="hl opt">:=</span>
   refine <span class="hl opt">(</span>modusponens _ _ <span class="hl opt">(</span>x _ _ _ _ _ _ _ _ _ _ _<span class="hl opt">)</span> _<span class="hl opt">)</span>
|| refine <span class="hl opt">(</span>modusponens _ _ <span class="hl opt">(</span>x _ _ _ _ _ _ _ _ _ _<span class="hl opt">)</span> _<span class="hl opt">)</span>
<span class="hl com">(* Lots of lines elided.  The actual code handle cases upto </span>
<span class="hl com">  35 arguments *)</span>
|| refine <span class="hl opt">(</span>modusponens _ _ <span class="hl opt">(</span>x _ _ _<span class="hl opt">)</span> _<span class="hl opt">)</span>
|| refine <span class="hl opt">(</span>modusponens _ _ <span class="hl opt">(</span>x _ _<span class="hl opt">)</span> _<span class="hl opt">)</span>
|| refine <span class="hl opt">(</span>modusponens _ _ <span class="hl opt">(</span>x _<span class="hl opt">)</span> _<span class="hl opt">).</span>
</pre>

<p>What does <code>exploit</code> do ? Well, the best thing is to give an
example. In the following context, </p>

<pre class="code-"><span class="hl kwd">A</span><span class="hl opt">,</span> <span class="hl kwd">B</span><span class="hl opt">,</span> <span class="hl kwd">C</span><span class="hl opt">,</span> <span class="hl kwd">D</span><span class="hl opt">,</span> <span class="hl kwd">G</span> <span class="hl opt">:</span> <span class="hl kwd">Prop</span>
<span class="hl kwd">H</span> <span class="hl opt">:</span> <span class="hl kwd">A</span> <span class="hl opt">-&gt;</span> <span class="hl kwd">B</span> <span class="hl opt">-&gt;</span> <span class="hl kwd">C</span> <span class="hl opt">-&gt;</span> <span class="hl kwd">D</span>
<span class="hl opt">============================</span>
<span class="hl kwd">G</span>
</pre>

<p><code>exploit H</code> will produce four sub-goals in which the user needs to
prove <code>A</code>, <code>B</code>, <code>C</code>, and <code>D -&gt; G</code>. That is, the <code>exploit</code>
tactic is a generalized version of the modus-ponens.</p>

<p>This tactic has two drawbacks. First, it is a bit inefficient: it
tries to apply the <code>modusponens</code> theorem to <code>x</code> applied to a
decreasing number of arguments (obviously we do not want to get two
subgoals <code>A</code> and <code>B -&gt; C -&gt; D -&gt; G</code>). Yet, this is a pity, because
most of the time, the right application has a low number of arguments,
and the execution of <code>exploit</code> must go through twenty-something
failures before reaching a successful of <code>refine</code>. The second drawback
is that one has to repeat by hand the same pattern (<code>x</code> followed by a
given number of holes), to handle all reasonable use-cases of the
tactic. </p>

<p>Now, we probably could imagine other (LTac) implementations of exploit,
but it is not the point of this article, and you should definitely not
try to do that at home! What we will do is implement this tactic as 9
lines long tactic in an OCaml plugin, way shorter than the LTac implementation.</p>

<p>Here we go. </p>

<pre class="code-ocaml"> 
<span class="hl kwa">let</span> exploit <span class="hl opt">(</span>c<span class="hl opt">:</span> <span class="hl kwd">Term</span><span class="hl opt">.</span>constr<span class="hl opt">) =</span> <span class="hl kwa">fun</span> gl <span class="hl opt">-&gt;</span>  
<span class="hl com">(* the type of [c] is [ty] *)</span>
<span class="hl kwa">let</span> ty <span class="hl opt">=</span> <span class="hl kwd">Tacmach</span><span class="hl opt">.</span>pf_type_of gl c <span class="hl kwa">in</span> 

<span class="hl com">(* In the general case, [ty] can be written as [forall (x1:t1)</span>
<span class="hl com">... (xn:tn), t]. We decompose this arity in two parts: [ctx] which</span>
<span class="hl com">is [(xn, tn); ...; (x1,t1)] and the conclusion [t] *)</span>
<span class="hl kwa">let</span> ctx<span class="hl opt">,</span> t <span class="hl opt">=</span> <span class="hl kwd">Term</span><span class="hl opt">.</span>decompose_prod_assum ty <span class="hl kwa">in</span>

<span class="hl com">(* We will also need the type of the conclusion of the goal *)</span>
<span class="hl kwa">let</span> concl <span class="hl opt">=</span> <span class="hl kwd">Tacmach</span><span class="hl opt">.</span>pf_concl gl <span class="hl kwa">in</span> 
</pre>

<p>We encounter functions from two modules here:</p>

<ul>
<li><p><code>coq-v8.4/kernel/term.ml</code> contains the definition of Coq terms, the
<code>constr</code> data-type, and various operations on it. For instance,
<code>decompose_prod_assum</code> takes as arguments a <code>constr</code> and decomposes
it into two parts: a telescope of products (that is, a context
<code>cxt</code>), and the final type <code>t</code>. At this point, it is crucial to note
that this manipulation of terms is very syntactic: the term <code>t</code> may
contain de Bruijn indices that refers to variables bound in the
context. Therefore, we shall manipulate <code>t</code> with some care and not
forget to, e.g., lift it when needed.</p></li>
<li><p><code>coq-v8.4/proofs/tacmach.ml</code> contains the API that I use most often
to interact with the proof machinery. For instance, <code>pf_type_of</code>
takes as argument the current proof environment (that is, the goal,
the typing context, and so on) and a <code>constr</code>, and returns its coq
type. The function <code>pf_concl</code> returns the conclusion of the current
goal.</p></li>
</ul>

<p>All in all, the above snippet is quite straightforward: get the type of
the argument of the tactic, and the conclusion of the current
goal. Nothing fancy, but here comes the meaty stuff. </p>

<p>Recall that a tactic builds a partial proof-term, which is a regular
Coq term. Here, the proof-term that we want to generate is </p>

<pre class="code-"><span class="hl opt">(</span><span class="hl kwa">fun</span> <span class="hl opt">(</span>x1<span class="hl opt">:</span>t1<span class="hl opt">) ... (</span>xn<span class="hl opt">:</span>tn<span class="hl opt">) (</span>m <span class="hl opt">:</span> t <span class="hl opt">-&gt;</span> concl<span class="hl opt">) =&gt;</span> m <span class="hl opt">(</span>c x1 <span class="hl opt">...</span> xn<span class="hl opt">))</span> 
</pre>

<p>(intuitively, if we were to <code>apply</code> this term in Coq, we would get a
sub-goal for each of the arguments of the function)</p>

<pre class="code-ocaml"><span class="hl kwa">let</span> pf_body <span class="hl opt">=</span>
  <span class="hl kwd">Term</span><span class="hl opt">.</span>mkApp <span class="hl opt">(</span><span class="hl kwd">Term</span><span class="hl opt">.</span>mkRel <span class="hl num">1</span><span class="hl opt">,</span>
              <span class="hl opt">[</span>| <span class="hl kwd">Term</span><span class="hl opt">.</span>mkApp <span class="hl opt">(</span>c<span class="hl opt">,</span> <span class="hl kwd">Termops</span><span class="hl opt">.</span>extended_rel_vect <span class="hl num">1</span> ctx<span class="hl opt">)</span> |<span class="hl opt">])</span>
</pre>

<p>The term <code>pf_body</code> corresponds to the internal representation of the
above <code>m (c x1 ... xn)</code>.  As should be obvious with their names, the
function <code>Term.mkApp</code> builds an application, and <code>Term.mkRel</code> builds a
term that is a de Bruijn index that points to the nearest binder. The
function <code>Termops.extended_rel_vect</code> is slightly more complicated: it
builds a vector of de Bruijn indices, lifted by 1. </p>

<p>Now, we need to build the <code>fun</code> part. We build exactly one <code>lambda</code>
for each product that occurred in the type of the term <code>c</code>, plus one
for the parameter of type <code>t -&gt; concl</code>. To do so, we simply extend the
former context with a new definition.  (Note here that the type <code>t</code>
may depend on the context <code>ctx</code>. Yet, there is no need to lift <code>t</code>,
because it is used in the exact same context as before; and <code>concl</code>
should be a closed term.)</p>

<pre class="code-ocaml"><span class="hl kwa">let</span> ctx <span class="hl opt">= (</span><span class="hl kwd">Names</span><span class="hl opt">.</span><span class="hl kwd">Anonymous</span><span class="hl opt">,</span><span class="hl kwd">None</span><span class="hl opt">,</span> <span class="hl kwd">Term</span><span class="hl opt">.</span>mkArrow t concl <span class="hl opt">) ::</span> ctx <span class="hl kwa">in</span> 
<span class="hl kwa">let</span> pf_term <span class="hl opt">=</span> <span class="hl kwd">Term</span><span class="hl opt">.</span>it_mkLambda_or_LetIn pf_body ctx <span class="hl kwa">in</span>
</pre>

<p>The function <code>Term.it_mkLambda_or_LetIn</code> iterates the function that
creates a lambda, for each of the elements of the context
<code>ctx</code>. Finally, we can call the built-in <code>apply</code> tactics to finish the
job. </p>

<pre class="code-ocaml"><span class="hl kwd">Tactics</span><span class="hl opt">.</span>apply pf_term gl
</pre>

<p>There is one wrinkle here: with my version of Coq, the sub-goals that
are generated are not in the same order as with the LTac version
(which is a problem if we have to deal with backward compatibility of
proof-scripts). More precisely, the proof obligation that corresponds
to <code>t -&amp;gt; concl</code> comes first. In order to avoid this problem, we will
rely on a slightly more arcane piece of code.</p>

<pre class="code-ocaml"><span class="hl kwd">Tactics</span><span class="hl opt">.</span>apply_term
  pf_term <span class="hl opt">(</span><span class="hl kwd">List</span><span class="hl opt">.</span>map <span class="hl opt">(</span><span class="hl kwa">fun</span> _ <span class="hl opt">-&gt;</span> <span class="hl kwd">Evarutil</span><span class="hl opt">.</span>mk_new_meta <span class="hl opt">())</span> ctx<span class="hl opt">)</span> gl
</pre>

<p>The function <code>apply_term</code> seems to be a variant of apply to which we
give a term, and a list of arguments to which the term is
applied. Here, we provide as arguments a bunch of <code>_</code> (in the same
fashion as we would have done for <code>refine</code>). For a reason that I do
not fully grasp, this gives us exactly the same sub-goals as the above
LTac <code>exploit</code>.</p>

<p>The last line of our OCaml plugin enrichs Coq's tactic environments
with our new tactic. This declaration is made of three parts: a unique
identifier <code>foobar</code> (that is used internally by Coq), the syntax
extension, and the actual OCaml code of the tactic (here, we simply
wrap a call to <code>exploit</code>):</p>

<pre class="code-ocaml"><span class="hl kwd">TACTIC EXTEND</span> foobar
  | <span class="hl opt">[</span><span class="hl str">"exploit"</span> constr<span class="hl opt">(</span>c<span class="hl opt">)] -&gt; [</span>exploit c<span class="hl opt">]</span>
<span class="hl kwd">END</span><span class="hl opt">;;</span>
</pre>

<p>And that's it: mission accomplished. </p>

<p>There is one extra benefit to our brand new implementation of
<code>exploit</code>: the former version was not working properly if it was given
a theorem of type, e.g., <code>A -&gt; B -&gt; ~C</code>. Let <code>D</code> be the goal, the
sub-goals that were generated were <code>A</code>, <code>B</code>, <code>C</code> and <code>False -&gt; D</code>.
This short-coming is solved with our new implementation.  </p>

<p>In the end, our new tactic is 9 lines long, compared to 20 something
repetitions of the same pattern in the LTac implementation. (To be
honest, we omit on this 9 lines count a few lines of boilerplate that
must be written for each new OCaml tactic, like the makefile
that is needed to compile the plugin.)</p>

<p>Moving to OCaml, we lost the safety-belt that is provided by LTac: for
instance, it is possible to get the de Bruijn indices wrong by one
when we build a proof-term. But it gives us the full power of the best
programming language ever ;) to build our new tactics. </p>

<p>The plugin that was build in this tutorial is available from the
public GitHub repository <a href="https://github.com/braibant/exploit-plugin">here</a>. From the
root of the repository</p>

<pre class="code-txt">make
make -f Makefile.coq install
</pre>

<p>should install the plugin in your Coq plugins directory. Then, it
suffices to use the vernacular 
&lt;coq&gt;
Require Exploit.
&lt;/coq&gt;
to be able to use the <code>exploit</code> tactic, from any coq development. </p><a onclick="switchContent('post4','post3')" class="btn" href="#3c33eeb4f6e8fa3c634ac1b143a45a68">Hide</a></div></span>
<a name="202b3d99be6dd1ffbce490a1d559050d"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2012.12.04.html"> Caml Weekly News, 04 Dec 2012</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">04 Dec 2012</span></span><span class="rss-description">phantom types and identity function / Github OCaml mirror available / creating a module from a #use directive in the toplevel / Other Caml News</span>
<a name="6a0aaa9f8e0e9b830f847b4de52e42a4"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/~scherer/gagallium/union-find-and-coq-universes/index.html"> Performance improvements in the universe checker of Coq</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">03 Dec 2012</span></span><span class="rss-description"><div id="post5"><p>
One of my <a href="http://gallium.inria.fr/~scherer/gagallium/verifying-a-parser-for-a-c-compiler/">parsing-related</a>
Coq files takes more than two hours to compile, which is pretty annoying
when the file is less than one thousand lines long and does no complex
computations. After some profiling, it appeared that Coq was spending
most of its time in the <code>Univ</code> module. This module is part of the
Coq kernel, its role is to check that the user is using universes in a
consistent way.</p>



<p>You can get an introduction of what universes are in
<a href="http://adam.chlipala.net/cpdt/html/Universes.html">this book
  chapter</a>. In Coq, universes are implicit: it is the role of the
Coq kernel to determine whether it is possible to give a number to
each occurrence of <code>Type</code>, in a manner that is proved not to
introduce inconsistencies.</p>

<a onclick="switchContent('post5','post6')" class="btn" href="#6a0aaa9f8e0e9b830f847b4de52e42a4">Read more...</a></div><div id="post6" style="display: none"><p>
One of my <a href="http://gallium.inria.fr/~scherer/gagallium/verifying-a-parser-for-a-c-compiler/">parsing-related</a>
Coq files takes more than two hours to compile, which is pretty annoying
when the file is less than one thousand lines long and does no complex
computations. After some profiling, it appeared that Coq was spending
most of its time in the <code>Univ</code> module. This module is part of the
Coq kernel, its role is to check that the user is using universes in a
consistent way.</p>



<p>You can get an introduction of what universes are in
<a href="http://adam.chlipala.net/cpdt/html/Universes.html">this book
  chapter</a>. In Coq, universes are implicit: it is the role of the
Coq kernel to determine whether it is possible to give a number to
each occurrence of <code>Type</code>, in a manner that is proved not to
introduce inconsistencies.</p>

<p>This computation is done in the <code>Univ</code> module: the rest of the Coq
kernel generates some constraints, and this module is supposed to warn
if they are not satisfiable. Roughly, theses constraints are of the
form: "universe A has an index strictly smaller than universe B", or
"universe A has an index smaller or equal to universe B". In order to
check that they are satisfiable, it is enough to see all these
constraints as a graph where edges are constraints and vertexes are
universes, and check that there is no cycle containing a strict
constraint.</p>

<p>This graph can be simplified: if there is a cycle of large
constraints, that does mean that all universes in this cycle are in
fact necessarily equivalent, and we can replace this cycle with only
one universe. We have to keep track of equivalences, using a
specialized data structure. We recognize here the classical
<a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">union-find 
problem</a>, which have very efficient solutions.</p>

<p>However, in order to do this task, in Coq, a naive approach is used:
it builds equivalence trees, but nothing is done to prevent these
trees to be very unbalanced. And, in fact, that was the problem in my
file: for some reason, my tactics generated hundred of universes constraints.
All these universes were inferred to be equivalent. In order to keep track
of this information, a long chain of universes were created: for each
of them, Coq knows that it is equivalent to the next one, but it does
not know how to go directly to the head of the chain, that is effectively
present in the graph. So, it was actually spending most of its time
following this long chain...</p>

<p>In the literature, there are two main heuristics to solve this
(classical) problem: "union by rank" and "path compression". Using
either one gives logarithmic amortized complexity, and they give
a practically constant amortized complexity if implemented
together. By experience, I know that each of these heuristics gives
very good performances when used alone, because the worst case is very
rare. Moreover, it is not easy to implement path compression in a
<a href="http://en.wikipedia.org/wiki/Persistent_data_structure">persistent
  way</a>, because it involves side effects. So, I decided to
  implement "union by rank" inside the Univ module of Coq.</p>

<p>It was not really difficult: I just added a <code>rank</code> field
in the record representing the nodes of the graph, that contains the
length of the longest path of equivalences leading to this node. So,
when we are merging nodes, we can chose to keep the node having the
longest chain as the head node. This keeps the graph balanced: if the
other nodes were part of smaller chains, the longest chain's length
doesn't increase.</p>

<p>I got a spectacular improvement of performances when Coq is executed
on my code: from more than two hours, I went to about 6.5
minutes. I get a reasonable 1% improvement when compiling the Coq
standard library: it is actually expected, because the standard
library does not contain a lot of complex polymorphic code.</p>

<p>You can see the current patch (which may still evolve a bit)
in <a href="https://github.com/coq/coq/pull/2">this pull
request</a>. My first implementation was against 8.3, this patch is on
the trunk version of Coq, and we're planning to port it to 8.4
soon. Do not hesitate to test it if you have universe-heavy
developments; any feedback is welcome.</p><a onclick="switchContent('post6','post5')" class="btn" href="#6a0aaa9f8e0e9b830f847b4de52e42a4">Hide</a></div></span>
<a name="ea85e6bbd2ab0d204b6a38cb979b6ef5"></a><span class="rss-header"><span class="rss-title"><a href="http://ocsigen.org/"> Journée de cours Ocsigen à Paris - Développement d'applications Web en OCaml</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Ocsigen project</span>, <span class="rss-date">29 Nov 2012</span></span><span class="rss-description"><div id="post7"><p>[Announcement for the french speaking Ocsigen Day dedicated to OCaml
programmers. December 14 at IRILL. English version below]
</p>
<h1>
 JFLO’12
Journée Francophone de Leçons sur Ocsigen —
Développement d'applications Web en OCaml
</h1>
<p>
Nous organisons une journée didactique autour d'Ocsigen dédiée aux
programmeurs OCaml. Cette journée aura lieu le 14 décembre à l'IRILL (cf
infos pratiques plus bas). Vous êtes invités à vous inscrire en ici :
</p>
<p>
<a href="https://docs.google.com/spreadsheet/viewform?formkey=dEUyaXNCeVNWQmI5cHFnU2tTc1dmaXc6MQ">Inscription</a>
</p>
<p>
Au programme, des cours et tutoriels sur les principaux composants du
projet Ocsigen :
</p>
<ul>
<li>Programmation concurrente avec Lwt ;
</li>
<li>Programmation côté client avec le compilateur Js_of_ocaml ;
</li>
<li>Programmation d'applications Web client-server avec Eliom.</li>
</ul>
<p>
Informations pratiques :</p>
<p>
LIEU : Salle ORANGE, 5e étage, Inria, 23, avenue d'Italie,75013 Paris
</p>
<p>
DATE : Vendredi 14 Décembre de 10h00 à 18h00.
</p>
<a onclick="switchContent('post7','post8')" class="btn" href="#ea85e6bbd2ab0d204b6a38cb979b6ef5">Read more...</a></div><div id="post8" style="display: none"><p>[Announcement for the french speaking Ocsigen Day dedicated to OCaml
programmers. December 14 at IRILL. English version below]
</p>
<h1>
 JFLO’12
Journée Francophone de Leçons sur Ocsigen —
Développement d'applications Web en OCaml
</h1>
<p>
Nous organisons une journée didactique autour d'Ocsigen dédiée aux
programmeurs OCaml. Cette journée aura lieu le 14 décembre à l'IRILL (cf
infos pratiques plus bas). Vous êtes invités à vous inscrire en ici :
</p>
<p>
<a href="https://docs.google.com/spreadsheet/viewform?formkey=dEUyaXNCeVNWQmI5cHFnU2tTc1dmaXc6MQ">Inscription</a>
</p>
<p>
Au programme, des cours et tutoriels sur les principaux composants du
projet Ocsigen :
</p>
<ul>
<li>Programmation concurrente avec Lwt ;
</li>
<li>Programmation côté client avec le compilateur Js_of_ocaml ;
</li>
<li>Programmation d'applications Web client-server avec Eliom.</li>
</ul>
<p>
Informations pratiques :</p>
<p>
LIEU : Salle ORANGE, 5e étage, Inria, 23, avenue d'Italie,75013 Paris
</p>
<p>
DATE : Vendredi 14 Décembre de 10h00 à 18h00.
</p>
<ul>
<li>les cours seront en français ;</li>
<li>il est fortement conseillé de venir muni de son ordinateur portable ;</li>
<li>si possible avec une version récente d'Eliom installée.</li>
</ul>
<p>
To get more frequent annoucements about Ocsigen, follow us on 
<a href="https://twitter.com/ocsigen">Twitter</a>,
<a href="https://plus.google.com/u/0/105890612060116987398/posts">Google+</a>, or
<a href="https://www.facebook.com/pages/Ocsigen/289974521051526">Facebook</a>.</p><a onclick="switchContent('post8','post7')" class="btn" href="#ea85e6bbd2ab0d204b6a38cb979b6ef5">Hide</a></div></span>
<a name="488819739afed57419cb3e91edff7efc"></a><span class="rss-header"><span class="rss-title"><a href="http://math.andrej.com/2012/11/29/how-to-implement-dependent-type-theory-iii/"> How to implement dependent type theory III</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Andrej Bauer</span>, <span class="rss-date">29 Nov 2012</span></span><span class="rss-description"><div id="post9"><p>I spent a week trying to implement higher-order pattern unification. I looked at couple of PhD dissertations, talked to lots of smart people, and failed because the substitutions were just getting in the way all the time. So today we are going to bite the bullet and implement <a href="http://en.wikipedia.org/wiki/De_Bruijn_index">de Bruijn indices</a> and <a href="http://en.wikipedia.org/wiki/Explicit_substitution">explicit substitutions</a>.</p>
<p>The code is available on Github in the repository <a href="https://github.com/andrejbauer/tt/tree/blog-part-III">andrejbauer/tt</a> (the <code>blog-part-III</code> branch).</p>
<p><span id="more-1337"></span></p>
<p>People say that de Bruijn indices and explicit substitutions are difficult to implement. I agree, I spent far too long debugging my code. But because every bug crashed and burnt my program immediately, I at least knew I was not done. In contrast, “manual” substitutions hide their bugs really well, and so are even more difficult to get right. I am convinced that my implementation from part II is still buggy.</p>
<h3>Blitz introduction to de Bruijn indices and explicit substitution</h3>
<a onclick="switchContent('post9','post10')" class="btn" href="#488819739afed57419cb3e91edff7efc">Read more...</a></div><div id="post10" style="display: none"><p>I spent a week trying to implement higher-order pattern unification. I looked at couple of PhD dissertations, talked to lots of smart people, and failed because the substitutions were just getting in the way all the time. So today we are going to bite the bullet and implement <a href="http://en.wikipedia.org/wiki/De_Bruijn_index">de Bruijn indices</a> and <a href="http://en.wikipedia.org/wiki/Explicit_substitution">explicit substitutions</a>.</p>
<p>The code is available on Github in the repository <a href="https://github.com/andrejbauer/tt/tree/blog-part-III">andrejbauer/tt</a> (the <code>blog-part-III</code> branch).</p>
<p><span id="more-1337"></span></p>
<p>People say that de Bruijn indices and explicit substitutions are difficult to implement. I agree, I spent far too long debugging my code. But because every bug crashed and burnt my program immediately, I at least knew I was not done. In contrast, “manual” substitutions hide their bugs really well, and so are even more difficult to get right. I am convinced that my implementation from part II is still buggy.</p>
<h3>Blitz introduction to de Bruijn indices and explicit substitution</h3>
<p>If you do not know about <a href="http://en.wikipedia.org/wiki/De_Bruijn_index">de Bruijn indices</a> and <a href="http://en.wikipedia.org/wiki/Explicit_substitution">explicit substitutions</a> you should first read the relevant Wikipedia pages, and perhaps the <a href="http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-54.pdf">original paper on explicit substitutions</a>, written by a truly impressive group of authors. Here is an inadequate short explanation for those who cannot be bothered to click on links.</p>
<p>We keep looking up variables in a context by their names, which seems a bit inefficient. We might have the bright idea of referring to <em>positions</em> in the context directly. We can indeed do this, and because a context is like a stack there are two choices:</p>
<ul>
<li><em>de Bruijn levels</em> are positions as counted from the bottom of the stack,</li>
<li><em>de Bruijn indices</em> are positions as counter from the top of the stack.</li>
</ul>
<p>We will use the indices. Thus, when the context grows all the old indices have to be <em>shifted</em> by one, which sounds more horrible than it is, as levels bring their own problems (which?). For instance, the $\lambda$-term $\lambda x \,.\, \lambda y \,.\, x$ is written with de Bruijn indices as $\lambda \, (\lambda \, 1)$, whereas $\lambda x \,.\, \lambda y \,.\, y$ is written as $\lambda \, (\lambda \, 0)$. (Just go read the Wikipedia article on <a href="http://en.wikipedia.org/wiki/De_Bruijn_index">de Bruijn indices</a> if you have not seen this before.)</p>
<p>The shifting and pushing of new things onto the context is expressed with explicit substitutions:</p>
<pre class="brush: plain; title: ; notranslate">type substitution =
  | Shift of int
  | Dot of expr * substitution
</pre>
<p>Read <code>Shift k</code> as “add $k$ to all indices” and <code>Dot(e,s)</code> as “push $e$ and use $s$”. In mathematical notation we write $\uparrow^n$ instead of <code>Shift n</code> and $e \cdot \sigma$ instead of <code>Dot(e,sigma)</code>. An explicit substitution $\sigma$ acts on an expression $e$ to give a new expression $[\sigma] e$. For example:</p>
<ul>
<li>$[\uparrow^k] (\mathtt{Var}\, m) = \mathtt{Var} (k + m)$</li>
<li>$[e \cdot \sigma)] (\mathtt{Var}\, 0) = e$</li>
<li>$[e \cdot \sigma)] (\mathtt{Var}\, (k+1)) = [\sigma](\mathtt{Var}\, k).$</li>
</ul>
<p>Below we will read off the other equations from the source code. Substitutions are performed on demand, which means that $[\sigma] e$ is an expression that needs to be accounted for in the syntax.</p>
<h3>Splitting the syntax</h3>
<p>The user is going to type in syntax with names, which we have to convert to an internal syntax that uses the indices. We should also keep the original names around for pretty-printing purposes. Therefore we need a datatype <a href="https://github.com/andrejbauer/tt/blob/blog-part-III/input.ml"><code>Input.exp</code></a> for parsing,</p>
<pre class="brush: plain; title: ; notranslate">(** Abstract syntax of expressions as given by the user. *)
type expr = expr' * Common.position
and expr' =
  | Var of Common.variable
  | Universe of int
  | Pi of abstraction
  | Lambda of abstraction
  | App of expr * expr

(** An abstraction [(x,t,e)] indicates that [x] of type [t] is bound in [e]. *)
and abstraction = Common.variable * expr * expr
</pre>
<p>and a datatype <a href="https://github.com/andrejbauer/tt/blob/blog-part-III/syntax.ml"><code>Syntax.expr</code></a> for the internal syntax:</p>
<pre class="brush: plain; title: ; notranslate">(** Abstract syntax of expressions, where de Bruijn indices are used to represent
    variables. *)
type expr = expr' * Common.position
and expr' =
  | Var of int                   (* de Briujn index *)
  | Subst of substitution * expr (* explicit substitution *)
  | Universe of universe
  | Pi of abstraction
  | Lambda of abstraction
  | App of expr * expr

(** An abstraction [(x,t,e)] indicates that [x] of type [t] is bound in [e]. We also keep around
    the original name [x] of the bound variable for pretty-printing purposes. *)
and abstraction = Common.variable * expr * expr

(** Explicit substitutions. *)
and substitution =
  | Shift of int
  | Dot of expr * substitution
</pre>
<p>Conversion from one to the other is done by <a href="https://github.com/andrejbauer/tt/blob/blog-part-III/desugar.ml"><code>Desugar.desugar</code></a>. Notice that we do not throw away variable names, but rather keep them around in the internal syntax so that we can print them out later. Strangely enough, <a href="https://github.com/andrejbauer/tt/blob/blog-part-III/beautify.ml"><code>beautify.ml</code></a> gets shorter with de Bruijn indices.</p>
<h3>Explicit substitutions</h3>
<p>The <a href="https://github.com/andrejbauer/tt/blob/blog-part-III/syntax.ml"><code>Syntax</code></a> module contains a couple of functions for handling explicit substitutions. First we have <code>Syntax.composition</code> which tells us how substitutions are composed:</p>
<pre class="brush: plain; title: ; notranslate">let rec compose s t =
  match s, t with
    | s, Shift 0 -&gt; s
    | Dot (e, s), Shift m -&gt; compose s (Shift (m - 1))
    | Shift m, Shift n -&gt; Shift (m + n)
    | s, Dot (e, t) -&gt; Dot (mk_subst s e, compose s t)
</pre>
<p>In mathematical notation:</p>
<ul>
<li>$\sigma \circ \uparrow^0 = \sigma$</li>
<li>$(e \cdot \sigma) \circ \uparrow^{m} = s \circ \uparrow^{m-1}$</li>
<li>$\uparrow^{m} \circ \uparrow^{n} = \uparrow^{m + n}$</li>
<li>$\sigma \circ (e \cdot \tau) = [\sigma] e \cdot (\sigma \circ \tau)$</li>
</ul>
<p>Of course, composition $\circ$ is the operation characterized by the equation $[\sigma \circ \tau] e = [\sigma]([\tau] e)$. Next we have <code>Syntax.subst</code> which explains how substitutions are performed:</p>
<pre class="brush: plain; title: ; notranslate">(** [subst s e] applies explicit substitution [s] in expression [e]. It does so
    lazily, i.e., it does just enough to expose the outermost constructor of [e]. *)
let subst =
  let rec subst s ((e', loc) as e) =
    match s, e' with
      | Shift m, Var k -&gt; Var (k + m), loc
      | Dot (e, s), Var 0 -&gt; subst idsubst e
      | Dot (e, s), Var k -&gt; subst s (Var (k - 1), loc)
      | s, Subst (t, e) -&gt; subst s (subst t e)
      | _, Universe _ -&gt; e
      | s, Pi a -&gt; Pi (subst_abstraction s a), loc
      | s, Lambda a -&gt; Lambda (subst_abstraction s a), loc
      | s, App (e1, e2) -&gt; App (mk_subst s e1, mk_subst s e2), loc
  and subst_abstraction s (x, e1, e2) =
    let e1 = mk_subst s e1 in
    let e2 = mk_subst (Dot (mk_var 0, compose (Shift 1) s)) e2 in
      (x, e1, e2)
  in
    subst
</pre>
<p>The code is not very readable, but in mathematical notation the interesting bits say:</p>
<ul>
<li>$[\uparrow^m](\mathtt{Var}\,k) = \mathtt{Var}\,(k + m)$</li>
<li>$[e \cdot \sigma] (\mathtt{Var}\,0) = e$</li>
<li>$[e \cdot \sigma] (\mathtt{Var}\,k) = [\sigma](\mathtt{Var}(k-1))$</li>
<li>$[\sigma](\lambda\, e) = \lambda \, ([\mathtt{Var}\,0 \cdot (\uparrow^1 \circ \sigma)] e)$</li>
<li>$[\sigma](e_1\,e_2) = ([\sigma]e_1)([\sigma]e_2)$</li>
</ul>
<p>There is also <code>Syntax.occurs</code> which checks whether a given index appears freely in an expression. This is not entirely trivial because explicit substitutions and abstractions change the indices, so the function has to keep track of what is what.</p>
<p>You may wonder what happened to $\beta$-reduction. If you look at <code>Norm.norm</code> you will discover it burried in the code for normalization of applications:<br/>
$$(\lambda \, e_1)\, e_2 = [e_2 \cdot \uparrow^0] e_1.$$</p>
<h3>Normalization</h3>
<p>In the last part we demonstrated normalization by evaluation. We always normalized everything all the way, which is an overkill. For example, during equality checking the <a href="http://encyclopedia2.thefreedictionary.com/Weak+Head+Normal+Form">weak head normal form</a> suffices to get the comparison started, and then we normalize on demand. So I replaced normalization by evaluation with direct normalization, as done in <a href="https://github.com/andrejbauer/tt/blob/blog-part-III/norm.ml"><code>norm.ml</code></a>. We still need normal forms when the user asks for them. Luckily, a single function can perform both kinds of normalization.</p>
<h3>Optimization</h3>
<p>The source contains no optimizations at all because its purpose is to be as clear as possible. The whole program is still pretty small, we are at 824 lines while the core is just 247 lines. The speed is comparable to the previous version, but with a bit of effort we should be able to speed it up considerably. Here are some opportunities:</p>
<ul>
<li>we normalize a definition every time we look it up in the context,</li>
<li>explicit substitutions tend to cancel out, and it is a good idea to look for common special cases, like composition with the identity substitution,</li>
<li>there is a lot of shifting happening when we look things up in the context, perhaps some of those could be avoided</li>
</ul>
<p>If anyone wants to work on these, I would be delighted to make a pull request.</p>
<p>I really have to do some serious math and stop playing around, so do not expect the next part anytime soon.</p><a onclick="switchContent('post10','post9')" class="btn" href="#488819739afed57419cb3e91edff7efc">Hide</a></div></span>
<a name="c3b516ab38f13accdd3df24b36ff284e"></a><span class="rss-header"><span class="rss-title"><a href="http://www.lexifi.com/blog/note-about-performance-printf-and-format"> A note about the performance of Printf and Format</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">LexiFi</span>, <span class="rss-date">28 Nov 2012</span></span><span class="rss-description"><div class="content-wide-padding white-bg light-grey-border">
<p>
  The goal is to display the following to stdout:
</p>
<pre>(0,0)
(1,1)
(2,2)
...
(1000000,1000000)
</pre>
<p>
  How would you implement that in OCaml?  For such a simple task, we
  probably expect the program to be IO bound, right? Ok, let's try
  with the idiomatic way, which is to use format strings as provided
  by the <tt>Printf</tt> module from OCaml standard library:
</p></div><p><a href="http://www.lexifi.com/blog/note-about-performance-printf-and-format" target="_blank">read more</a></p></span>
<a name="0b7415981db8c02f1d7c9a8d2f7c23ed"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2012.11.27.html"> Caml Weekly News, 27 Nov 2012</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">27 Nov 2012</span></span><span class="rss-description">Poll results of OASIS, package manager and misc. / open faculty position in Big Data at Wright State University / how to wrap a command line call correctly? / Monad Library? / RPM's for OCaml 4.00.1 and associated libs for Mageia 2 / opass - encrypted password db / Multithreaded https requests in ocamlnet netclient / New group: Pragmatic functional programming research / Other Caml News</span>
<a name="bfcbacfbb0db1e239d978d522713b1cb"></a><span class="rss-header"><span class="rss-title"><a href="http://www.lexifi.com/blog/type-based-selection-label-and-constructors"> Type-based selection of label and constructors</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">LexiFi</span>, <span class="rss-date">27 Nov 2012</span></span><span class="rss-description"><div class="content-wide-padding white-bg light-grey-border">
<p>
  Most languages provide some way to manipulate tuples of values with
  a proper label for each field.  They are called structures in C,
  records in OCaml; objects as found in most mainstream OO languages
  extend this same notion.
</p></div><p><a href="http://www.lexifi.com/blog/type-based-selection-label-and-constructors" target="_blank">read more</a></p></span>
<a name="9af1d5db458dcc344455b1e57d0f19a4"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=818"> Stog 0.4</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">22 Nov 2012</span></span><span class="rss-description">Stog is a kind of Jekyll in OCaml: It is a static web site generator, able to handle blog posts as well as regular pages.</span>
<script type="text/javascript">function switchContent(id1,id2) {
     // Get the DOM reference
     var contentId1 = document.getElementById(id1);
     var contentId2 = document.getElementById(id2);
     // Toggle
     contentId1.style.display = "none";
     contentId2.style.display = "block";
     }</script></div>

  
    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
</body></html>
