<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: OCaml Planet</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contributors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="OCaml Planet" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it Online</a></li>
    <li><a href="../taste.html">100 Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who Is Using It?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a>
        <a href="http://langref.org/ocaml">langref.org</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
    <li><a href="../papers.html">Papers</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../releases/latest.html">Releases</a></li>
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development Tools</a></li>
    <li><a href="../books.html#manual">User Manual</a></li>
    <li><a href="../cheat_sheets.html">Cheat Sheets</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API Search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">GitHub</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing Lists</a></li>
    <li><a href="../planet/">Blogs</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>OCaml Planet
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

    <h1>OCaml Planet</h1>

    <p>The OCaml Planet aggregates various blogs from the OCaml
    community.  It is kindly provided
    by <a href="http://www.ocamlcore.com/">OCamlCore</a>.  If you
    would like to be added, read
    the <a href="http://www.ocamlcore.org/planet/">Planet
    subscription HOWTO</a>.</p>

    <br/>
    <div style="float: right; margin-right: 0; margin-top: 0" class="span2 planet-subscriptions"><em>Subscriptions</em>
      <ul><li><a href="http://alexleighton.tumblr.com/tagged/ocaml/rss">Alex Leighton</a></li><li><a href="http://blog.mestan.fr/feed/?cat=16">Alp Mestan</a></li><li><a href="http://andreiformiga.com/blog/?cat=5&feed=rss2">Andrei Formiga</a></li><li><a href="http://math.andrej.com/feed/">Andrej Bauer</a></li><li><a href="http://anil.recoil.org/feeds/atom.xml">Anil Madhavapeddy</a></li><li><a href="http://unnali.com/tag/ocaml/feed/">Arlen Cuss</a></li><li><a href="http://ashishagarwal.org/tag/ocaml/feed/">Ashish Agarwal</a></li><li><a href="http://www.blogger.com/feeds/7617521785419311079/posts/default">Cameleon news</a></li><li><a href="http://caml.inria.fr/news.en.rss">Caml INRIA</a></li><li><a href="http://camlspotter.blogspot.com/feeds/posts/default?alt=rss">Caml Spotting</a></li><li><a href="http://alan.petitepomme.net/cwn/cwn.rss">Caml Weekly News</a></li><li><a href="http://procrastiblog.com/category/ocaml/feed/">Christopher Conway</a></li><li><a href="http://coherentpdf.com/blog/?tag=ocaml&feed=rss">Coherent Graphics</a></li><li><a href="http://coq.inria.fr/news/feed">Coq</a></li><li><a href="http://erratique.ch/feeds/news.atom">Daniel Bünzli</a></li><li><a href="http://blog.dbpatterson.com/rss">Daniel Patterson</a></li><li><a href="http://nleyten.com/atom.aspx">Dario Teixeira</a></li><li><a href="http://www.blogger.com/feeds/17133288/posts/default/-/ocaml">David Baelde</a></li><li><a href="http://bentobako.org/david/blog/index.php?feed/tag/ocaml/atom">David Mentré</a></li><li><a href="http://dutherenverseauborddelatable.wordpress.com/category/ocaml/feed/">David Teller</a></li><li><a href="http://www.examachine.net/blog/?feed=rss2&cat=4">Eray Özkural</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/CodeHacking/Ocaml/index.rss20">Erik de Castro Lopo</a></li><li><a href="http://blog.emillon.org/feeds/ocaml.xml">Etienne Millon</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/FP-Syd/index.rss20">FP-Sydney</a></li><li><a href="http://www.blogger.com/feeds/8964007124326996693/posts/default/-/ocaml">Fayssal Martani</a></li><li><a href="http://frama-c.com/rss.xml">Frama-C</a></li><li><a href="http://functionaljobs.com/jobs/search/?q=ocaml&format=rss">Functional Jobs</a></li><li><a href="http://gallium.inria.fr/blog/index.rss">GaGallium</a></li><li><a href="http://gaiustech.wordpress.com/category/ocaml/feed/">Gaius Hammond</a></li><li><a href="http://blog.camlcity.org/blog/rss">Gerd Stolpmann</a></li><li><a href="http://www.wisdomandwonder.com/tag/OCaml/feed">Grant Rettke</a></li><li><a href="http://hongboz.wordpress.com/feed/">Hong bo Zhang</a></li><li><a href="http://blog.incubaid.com/tag/ocaml/feed/">Incubaid Research</a></li><li><a href="http://ambassadortothecomputers.blogspot.com/feeds/posts/default?alt=rss">Jake Donham</a></li><li><a href="http://scattered-thoughts.net/rss?tag=ocaml">Jamie Brandon</a></li><li><a href="http://ocaml.janestcapital.com/?q=rss.xml">Jane Street</a></li><li><a href="http://lpw25.net/rss.xml">Leo White</a></li><li><a href="http://www.lexifi.com/blogs/ocaml/feed">LexiFi</a></li><li><a href="http://savonet.sourceforge.net/liquidsoap.rss">Liquidsoap</a></li><li><a href="http://syntaxexclamation.wordpress.com/tag/ocaml/feed/">Matthias Puech</a></li><li><a href="http://www.blogger.com/feeds/5888658295182480819/posts/default">Matías Giovannini</a></li><li><a href="http://eigenclass.org/R2/feeds/rss2/all">Mauricio Fernandez</a></li><li><a href="http://www.elehack.net/michael/blog/tags/ocaml?format=rss">Michael Ekstrand</a></li><li><a href="http://www.rktmb.org:82/feed/category/work/ocaml/atom">Mihamina Rakotomandimby</a></li><li><a href="http://mcclurmc.wordpress.com/feed/">Mike McClurg</a></li><li><a href="http://nyc-ocaml.posterous.com/rss.xml">NYC OCaml</a></li><li><a href="http://ocamlhackers.ning.com/profiles/blog/feed?tag=ocaml&xn_auth=no">OCaml Hackers</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfnews.php">OCamlCore Forge News</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfprojects.php">OCamlCore Forge Projects</a></li><li><a href="http://www.ocamlcore.com/wp/?feed=rss2&amp;language=en&#038;language=en">OCamlCore.com</a></li><li><a href="http://www.ocamlpro.com/feed/atom.xml">OCamlPro</a></li><li><a href="http://odns.tuxfamily.org/feed/">ODNS project</a></li><li><a href="http://ox.tuxfamily.org/feed/">Ocaml XMPP project</a></li><li><a href="http://ocsigen.org/news.atom">Ocsigen project</a></li><li><a href="http://www.blogger.com/feeds/2073503406800427577/posts/default">Opa</a></li><li><a href="http://www.openmirage.org/blog/atom.xml">Open Mirage</a></li><li><a href="http://functional-orbitz.blogspot.com/feeds/posts/default/-/planetocaml?alt=rss">Orbitz</a></li><li><a href="http://www.donadeo.net/facets/programming-languages/objective-caml/feed/">Paolo Donadeo</a></li><li><a href="https://mancoosi.org/~abate/taxonomy/term/5/0/feed">Pietro Abate</a></li><li><a href="http://redlizards.com/blog/feed/?tag=ocaml">Red Lizard Software</a></li><li><a href="http://rwmj.wordpress.com/tag/ocaml/feed/">Richard Jones</a></li><li><a href="http://blog.rastageeks.org/spip.php?page=rss&id_mot=2">Romain Beauxis</a></li><li><a href="http://seb.mondet.org/blog/feed/ocaml.rss">Sebastien Mondet</a></li><li><a href="http://upsilon.cc/~zack/tags/ocaml/index.rss">Stefano Zacchiroli</a></li><li><a href="http://le-gall.net/sylvain+violaine/blog/index.php?feed/tag/ocaml/atom">Sylvain Le Gall</a></li><li><a href="http://caml.inria.fr/hump.rss">The Caml Humps</a></li><li><a href="http://www.blogger.com/feeds/6115529230232389198/posts/default">Till Varoquaux</a></li><li><a href="http://www.nicollet.net/toroidal/ocaml/feed/">Victor Nicollet</a></li><li><a href="http://y-node.com/blog/feeds/tag/ocaml/">y-node</a></li></ul>

      <a href="http://planet.ocaml.org/rss20.xml"><img src=".././img/rss20.png"/></a>
      <a href="http://planet.ocaml.org/opml.xml"><img src=".././img/opml.png"/></a>
    </div>
    <div class="planet"><a name="83e740a394d1c2d5ca61795a79a53c3e"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/blog/implementing-hamt-for-ocaml"> Implementing HAMT for OCaml</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">02 Feb 2013</span></span><span class="rss-description"><div id="post1"><p>During the second part of <a href="http://gallium.inria.fr/blog/hevea-a-new-rope/">my
internship</a> this
summer, I worked on a test implementation for a new data structure in
OCaml : Hash Array Mapped Tries (HAMT). I did not have the time to
finish it, but I now have a usable and quite complete version, still
to be more documented but already available at
<a href="http://gitorious.org/ocaml-hamt">http://gitorious.org/ocaml-hamt</a>.</p>

<p>On this article, I will quickly explain the principles and the use
cases of this structure, and I will expose a few details of my
implementation in OCaml.</p>




<h3 id="hamt-why-where-how">HAMT: Why, where, how ?</h3>
<p>When you want to play with associative tables over non-integer keys, if you can use imperative constructions, you do not usually hesitate a long time : you use Hash Tables. This structure guarantees <code>O(1)</code> complexity for all elementary operations, provided you can hash your values. However, it is by essence a mutable structure: if you want to use a functional style, you need persistent ones (and copying a Hash Table at every single insertion is obviously right out).</p>
<a onclick="switchContent('post1','post2')" class="btn" href="#83e740a394d1c2d5ca61795a79a53c3e">Read more...</a></div><div id="post2" style="display: none"><p>During the second part of <a href="http://gallium.inria.fr/blog/hevea-a-new-rope/">my
internship</a> this
summer, I worked on a test implementation for a new data structure in
OCaml : Hash Array Mapped Tries (HAMT). I did not have the time to
finish it, but I now have a usable and quite complete version, still
to be more documented but already available at
<a href="http://gitorious.org/ocaml-hamt">http://gitorious.org/ocaml-hamt</a>.</p>

<p>On this article, I will quickly explain the principles and the use
cases of this structure, and I will expose a few details of my
implementation in OCaml.</p>




<h3 id="hamt-why-where-how">HAMT: Why, where, how ?</h3>
<p>When you want to play with associative tables over non-integer keys, if you can use imperative constructions, you do not usually hesitate a long time : you use Hash Tables. This structure guarantees <code>O(1)</code> complexity for all elementary operations, provided you can hash your values. However, it is by essence a mutable structure: if you want to use a functional style, you need persistent ones (and copying a Hash Table at every single insertion is obviously right out).</p>
<p>The usual choice is then to use balanced binary trees (like Maps in OCaml): if you can provide an order relation on your keys, elementary operations become <code>O(log(n))</code>. In 2001, a new data structure is introduced by Phil Bagwell: Hash Array Mapped Tries<sup><a href="http://gallium.inria.fr/blog/index.rss#fn1" id="fnref1" class="footnoteRef">1</a></sup>. Where balanced binary trees have a branching factor of 2, thus having approximately a <code>log2(n)</code> depth (<code>n</code> is the number of elements), HAMT are prefix trees which have a much greater factor, namely 32 in the original article (in fact, the best value is the size of a word of your machine, we will see why).</p>
<p>But how to build <em>prefix</em> trees with your own type of key ? That's where hashing enters the scene. If you can hash your key, then you can consider that the keys of your table are not your key type, but the hashed values of your own keys. Thus you can build a prefix tree, with an obvious notion of prefix that I will not explain. There is also a second advantage: if your hash function is correctly distributed, your tree is automagically balanced: you do not it to set up by rebalancing sometimes nor by keeping extra information. Being a "prefix tree over the hashes of the keys" is therefore the basis of the structure.</p>
<p>HAMT have been getting publicity since they where picked as a central persistent datastructure in the Clojure programming language. We have also had encouraging feedback from use in Scala, and more recently implementations in Haskell. It seems that persistent HAMT are an interesting datastructure; yet we should not jump to conclusions, as the details of one's runtime system may have important impacts on the viability of subtle data layout choices. The purpose of the current prototype was to test the waters to see whether the "HAMT success story" could be reproduced in the OCaml world.</p>
<p>Its use case is rather obvious: when you need a persistent associative table over a key that you can hash, you can use HAMT. However, there is no notion of comparison in standard HAMT: if you need to be able to get quickly the value associated with the minimal key, they are not a good choice. So where is the advantage over Maps ?</p>
<p>Here is a small, early comparison between the two structures: we test iterations of adding elements to an already big structure, finding present elements in the structure, and a mix of adding and finding (this test is executed by timing the execution of <code>tests/param.ml</code>, self-documented, by Gabriel Scherer, praise him) :</p>
<pre><code>|            | Map   | HAMT  |
| add        | 7.4s  | 8.6s  |
| find       | 7.9s  | 3.9s  |
| find + add | 14.9s | 11.8s |</code></pre>
<p>We see that the HAMT are a little (although the difference seems to increase with the dimension of the test) slower on insertions, but really quicker on searches. They use Arrays and do a quite big number of copies when modifying a key, so the GC is heavily sollicitated: if we byte-compile the file and we use <code>OCAMLRUNPARAM="s=5M"</code> to boost-up it, HAMT.add becomes a little faster than Map.add, and find is a little sped-up. However, the precise conditions leading to this results are not really understood: the size of the test has apparently a non-negligeable influence, and I cannot really make reliable performance comparisons. For an example, without modifying the GC, I just executed the following commands:</p>
<pre><code>$ time ./param.byte hamt 300000 add
./param.byte hamt 300000 add  15,98s user 0,07s system 99% cpu 16,083 total
$ time ./param.byte map 300000 add
./param.byte map 300000 add  19,59s user 0,03s system 99% cpu 19,665 total
$ time ./param.native hamt 300000 add
./param.native hamt 300000 add  8,95s user 0,09s system 99% cpu 9,061 total
$ time ./param.native map 300000 add
./param.native map 300000 add  7,41s user 0,05s system 99% cpu 7,475 total</code></pre>
<p>The bottom line is: the structure seems to be a good alternative to Maps. It is always (and often much) faster on finds, and has equivalent performances on add (sometimes faster, sometimes slower, under conditions that I do not really know). Furthermore, missed findings are faster than successful ones in HAMT, and this accentuates the difference in favour of this structure (even if it is not <em>that</em> accentuated).</p>
<p>Now that we got promising results about the structure, let's dissect it to understand how it works.</p>
<h3 id="hamt-what-is-it">HAMT: what is it ?</h3>
<p>So we already know the basis of the structure: it's a prefix tree over the hashes of the key. More precisely, every node is (for now) a leaf (<code>key, value</code> pair) or a 32 elements array (containing his sons), and to traverse the structure, we hash our key, and we take the bits from this hash 5 by 5. Thus at each level we have a 5 bits chunk, being a number between 0 and 31 which will indicate which son to choose. If it is <code>Empty</code>, then the considered key is not present in the structure. Insertion is then trivial: just replace it by your <code>Leaf (k, v)</code>. If we encounter a leaf, either its key is the one we are looking for, either... it isn't. If it is, insertion is made by changing the value. If it is not, insert an internal node (an array) at this place, take the chunks of hash corresponding to this depth of both keys, and put each one at its place (you may have to do it several times if the chunks appear to be the same). If we encounter an internal node, just take the following 5 bits and continue the descent. At the end of the hash, if we still are on an internal node, either we use open hashes (then there is no "end of the hash", but we cannot usually guarantee to terminate), or we place buckets in the last arrays instead of leaves.</p>
<p>If we use a correctly distributed hash, our structure will therefore have a depth of (at most) <code>log32(n)</code>. Let's estimate what it means: if we want to build a structure associating to each single word of <em>War and Peace</em> its number of occurrences, we only need a depth of 4. If our keys are representing every people on Earth, we need a depth of 7. If they are every single atom on the universe, it's less than 60. Of course, our hash function will not be perfect, but we can see with these numbers that with very few chunks extraction and comparison, we can index a very important key set. We also need few array copies when we modify something on our table (because, to be persistent, we need to copy the arrays leading to our tip node from the root: that's the cost of fast indexing. <em>Boire ou conduire, il faut choisir.</em>)</p>
<p>However, we have a problem with this representation: each array uses a constant space, even if it is almost empty. If our structure is not very dense, we can use up to 32 times more space than needed. On big datasets, it can be problematic. There is an (elegant) astuce to fix this: rather than arrays of size 32 at each level, we only use arrays that have exactly as many cases as sons. To get the index on our array given our "virtual" index (which is the value of our chunk), we use a <em>bitmap</em>: a 32-bits integer, where each bit indicates the presence at this position of a son of our node. The order of the elements on the array follows the order of the chunks, then to get the real indice of a chunk, we just have to count the 1-bits at a indice lower than it in the bitmap. Using this method, every case of an array is useful, and if we adapted the size of our structure as I mentioned before (remember, the branching factor), the bitmap fills exactly one machine word: we have a quite optimal space use.</p>
<p>In his <a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">article</a>, Phil Bagwell also uses a root table which is treated differently. I did not use this method in my implementation, so I will not talk much about it: just know basically that the first table is resized when the number of elements in the structure increases, to guarantee a constant-time access to every key (at the cost of resizing sometimes, which seems to be amortized over insertions<sup><a href="http://gallium.inria.fr/blog/index.rss#fn2" id="fnref2" class="footnoteRef">2</a></sup>).</p>
<p>Finally, let's talk about "theoretical performances": our complexity is the same as balanced binary trees, namely <code>O(log(n))</code> for elementary operations (insertion, deletion, searching), except that our <code>log</code> is not the same and grows very slowly (but, well, maths are strict and <code>O(.)</code> does not want to know about that). Misses are faster than successful researches: if a key is not present in the tree, and if the hash function has good properties, we should quickly find a difference between the hash of our keys and the ones of those who are in our table. But in this kind of problem, the real determining factor is the multiplicative one behind our asymptotic complexity: we saw in the first part that, in OCaml, this factor seems to be nice enough to give us good hopes about the structure. Let's now examine the practical implementation.</p>
<h3 id="in-ocaml-a-few-lines-of-code.">In OCaml: a few lines of code.</h3>
<p>In this part, I will not comment about every detail of my implementation, but simply show a few lines and give short explanations about how the stuff works. My implementation is strongly inspired by <a href="https://github.com/exclipy/pdata">exclipy's one</a> in Haskell.</p>
<p>Let's start by the counting of the 1-bits in a bitmap: the modern processors offer a <code>POPCOUNT</code> instruction which does the job. However, OCaml does not propose this instruction: we have to recode it by ourselves.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> sk5 = 0x55555555
<span class="kw">let</span> sk3 = 0x33333333
<span class="kw">let</span> skf0 = 0xf0f0f0f
<span class="kw">let</span> skff = 0xff00ff

<span class="kw">let</span> ctpop map =
  <span class="kw">let</span> map = map - (map <span class="kw">lsr</span> 1) <span class="kw">land</span> sk5 <span class="kw">in</span>
  <span class="kw">let</span> map = map <span class="kw">land</span> sk3 + (map <span class="kw">lsr</span> 2) <span class="kw">land</span> sk3 <span class="kw">in</span>
  <span class="kw">let</span> map = map <span class="kw">land</span> skf0 + (map <span class="kw">lsr</span> 4) <span class="kw">land</span> skf0
  <span class="kw">in</span> <span class="kw">let</span> map = map + map <span class="kw">lsr</span> 8
     <span class="kw">in</span> (map + map <span class="kw">lsr</span> 16) <span class="kw">land</span> 0x3f</code></pre>
<p>This code is adapted from the one Phil Bagwell proposes in C in his paper. I have no clue why it works (and I do not want to), but well, it does. It counts the number of 1-bits in a bitmap, and when you want them before a given position <code>n</code>, just use <code>land</code> to set the other bits to <code>0</code>. The interesting point is that this is a portion of code which could be fastened: in an ideal world where everybody would love HAMT, we could imagine an OCaml implementing default support for <code>CTPOP</code>. Anyway, thinking about the performances of this function would not be a loss of time when the era of micro-optimisation has come.</p>
<p>Here is the definition of the HAMT type:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> 'a t =
  | <span class="dt">Empty</span>
  | <span class="dt">Leaf</span> <span class="kw">of</span> <span class="dt">int</span> * key * 'a
  | <span class="dt">HashCollision</span> <span class="kw">of</span> <span class="dt">int</span> * (key * 'a) <span class="dt">list</span>
  | <span class="dt">BitmapIndexedNode</span> <span class="kw">of</span> <span class="dt">int</span> * 'a t <span class="dt">array</span>
  | <span class="dt">ArrayNode</span> <span class="kw">of</span> <span class="dt">int</span> * 'a t <span class="dt">array</span></code></pre>
<p>Buckets are managed by association lists: it is probably weak to hash collision attacks. Using Maps would probably fix this problem, at the cost of having to use comparable keys. We could also use open hashes: not to decide, I simply used lists and kept the <code>Leaf</code> constructor (instead of a <code>HashCollision</code> with a one element list), so that it could be easily modified in the functions if another way was preferable. As for <code>BitmapIndexedNode</code> and <code>ArrayNode</code>, they correspond to the root table of Phil Bagwell: rather than making it grow when inserting many data, I transform bitmap arrays into full length arrays when they are dense enough: therefore, there is no need to compute a <code>CTPOP</code>, and there is no big space loss because the constructor is only used when arrays already contain almost 32 elements. The performance fact is to be analysed: we could think that using only <code>ArrayNode</code> would lead to better performances (at the cost of a lot of space used), but in fact, it sensibly lowers them. Then, if even dense arrays are fast, why bother with <code>ArrayNode</code> ? Because using only <code>BitmapIndexedNode</code> also lowers the performances. The exact frontier (in terms of proportional filling of the array) between the two constructors is not yet determined, but these values seems to make it behave well:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="ot">module</span> StdConfig : <span class="dt">CONFIG</span> = <span class="kw">struct</span>
  <span class="kw">let</span> shift_step = 5
  <span class="kw">let</span> bmnode_max = 16
  <span class="kw">let</span> arrnode_min = 8
<span class="kw">end</span></code></pre>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="ot">module</span> StdConfig32 : <span class="dt">CONFIG</span> = <span class="kw">struct</span>
  <span class="kw">let</span> shift_step = 4
  <span class="kw">let</span> bmnode_max = 8
  <span class="kw">let</span> arrnode_min = 4
<span class="kw">end</span></code></pre>
<p>There is also a point to be noticed: as OCaml uses one bit of the integers for garbage collecting purposes, on 64 bits architectures, we can only use 32 bits bitmaps. This also leads to a performance issue: shiftings, intensely used in HAMT (as in every bit manipulating code), are not straight processor shiftings, because this supplementary bit has to be conserved. It cannot simply be solved in OCaml, so we must take it into account when reasoning about the performances we can expect (and the tests showed the structure was still interesting).</p>
<p>The general purpose modification function is this one:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">val</span> alter : key -&gt; ('a <span class="dt">option</span> -&gt; 'a <span class="dt">option</span>) -&gt; 'a t -&gt; 'a t</code></pre>
<p>It uses <code>option</code> type to be generic over the modification you want to implement: this allows to write only a big function (73 lines) to manage all possible cases, but could degrade the performances. When the module is stable, it could be specialised. The same sort of interface is used for the <code>alter_all</code> function, specialised in <code>map</code>, <code>filter</code> and all these things.</p>
<p>As we just saw, HAMT use many arrays. Therefore, at the insertion of an element, you need to recopy all the arrays from him to the root of the structure to keep it persistent. When you need to insert at one time many values, copying the ancestors for every element would uselessly long: we can just copy the destination HAMT first, and then use mutability to modify it in place before returning it. Internally, the mutability allows better performances, and using correct module interfaces we can prevent the user from unwillingly break his code by muting his structures. The <em>real</em> alter function (not exported) thus has this type:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">val</span> alter_node : 
  ?mute:bool -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; Key<span class="kw">.</span>t -&gt; 
  ('a <span class="dt">option</span> -&gt; 'a <span class="dt">option</span>) -&gt; 'a t -&gt; 'a t</code></pre>
<p>The first <code>int</code> parameter is the hash shift value at the given depth (it is given <code>0</code> at the beginning and is recursively incremented), the second one is the hashed value of the key (which is computed once and recursively given as a parameter rather than calculate it for every chunk). Therefore we can define another function, useful for imports:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> add_mute k v hamt =
    alter_node ~mute:true 0 (hash key) k (<span class="kw">fun</span> _ -&gt; <span class="dt">Some</span> v) hamt

<span class="ot">module</span> Import =

  <span class="kw">struct</span>

    <span class="ot">module</span> <span class="kw">type</span> <span class="dt">FOLDABLE</span> = <span class="kw">sig</span>
      <span class="kw">type</span> key
      <span class="kw">type</span> 'v t
      <span class="kw">val</span> fold : (key -&gt; 'v -&gt; 'a -&gt; 'a) -&gt; 'v t -&gt; 'a -&gt; 'a
    <span class="kw">end</span>

    <span class="ot">module</span> Make (<span class="dt">M</span> : <span class="dt">FOLDABLE</span> <span class="kw">with</span> <span class="kw">type</span> key = key) =
    <span class="kw">struct</span>
      <span class="kw">let</span> add_from x hamt = M<span class="kw">.</span>fold add_mute x (copy hamt)
      <span class="kw">let</span> from x = add_from x <span class="dt">Empty</span>
    <span class="kw">end</span>

<span class="kw">end</span></code></pre>
<p>The module <code>Import</code> provides a function usable to import many values in a HAMT, empty or not, from a structure that you can fold. It uses mutability to speed-up the process. Obviously, if your destination HAMT is already big and your structure quite small, copying the big full HAMT before muting him a few times can be slower than copying a few times the line from the root to an inserted value. When the limit is reached is to be established by the user (because a theoretical formula with logarithms would probably not be that pertinent in real code).</p>
<p>The rest of the code is quite straightforward once you understood the principles of the structure.</p>
<h3 id="conclusion">Conclusion</h3>
<p>The HAMT data structure appears to be quite promising for the language OCaml. Both its theoretical complexity and practical performances make it a good competitor to the great old Map, as long as your program does not already rely on comparisons.</p>
<p>However, this implementation should be considered more as a proof of concept rather than the final and optimal way to implement them. There are still many behaviours to be tested and understood, and quickly coded functions which could take advantage of a more thorough reflection.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn1"><p><a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">Ideal Hash Trees</a>, 2001, Phil Bagwell, Institute of Core Computing Science, Swiss Institute of Technology Lausanne<a href="http://gallium.inria.fr/blog/index.rss#fnref1">↩</a></p></li>
<li id="fn2"><p>I must confess that I think I did not totally understand this part, because I do not exactly come to the same conclusions.<a href="http://gallium.inria.fr/blog/index.rss#fnref2">↩</a></p></li>
</ol>
</div><a onclick="switchContent('post2','post1')" class="btn" href="#83e740a394d1c2d5ca61795a79a53c3e">Hide</a></div></span>
<a name="610045c7d8000afbc439e261716c2bb5"></a><span class="rss-header"><span class="rss-title"><a href="http://blog.incubaid.com/2013/02/01/user-functions-in-arakoon/"> User functions in Arakoon</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Incubaid Research</span>, <span class="rss-date">01 Feb 2013</span></span><span class="rss-description">Mahomet cald the Hill to come to him. And when the Hill stood still, he was neuer a whit abashed, but said; If the Hill will not come to Mahomet, Mahomet wil go to the hill. Francis Bacon Introduction Arakoon tries to be a simple distributed key value store that favours consistency over availability. From [...]<img src="http://stats.wordpress.com/b.gif?host=blog.incubaid.com&amp;blog=27780527&amp;post=990&amp;subd=incubaid&amp;ref=&amp;feed=1" alt="" height="1" border="0" width="1"/></span>
<a name="a659aff02da99b91b3ba73c089b356a6"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=844"> BER MetaOCaml 100</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">31 Jan 2013</span></span><span class="rss-description">BER MetaOCaml is a streamlined version of MetaOCaml -- a conservative extension of OCaml with the primitive type of code values, and three basic multi-stage expression forms: Brackets, Escape, and Run.</span>
<a name="a3e64a86c3d2ae3b4f9ccb8dcba2ee6d"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=416"> Ocurl 0.5.4</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">31 Jan 2013</span></span><span class="rss-description">An OCaml binding for the
libcurl multi-protocol file transfer library.</span>
<a name="1a026b7f6cf6c617e92908a40e7123d9"></a><span class="rss-header"><span class="rss-title"><a href="http://hongboz.wordpress.com/2013/01/31/discussions-on-the-syntactic-meta-programmingwg-camlp4-list/"> Discussions on the Syntactic Meta Programming(wg-camlp4 list)</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Hong bo Zhang</span>, <span class="rss-date">31 Jan 2013</span></span><span class="rss-description"><div id="post3"><p>There are some interesting discussions in the wg-camlp4 mailing list, I wrote a long mail yesterday, I cleaned it a bit, pasted it here </p>
<p>———</p>
<div> I rewrite the whole camlP4(named Fan) from scratch, building the quotation kit and throw away the crappy grammar parser, so plz believe me <b>that I do understand the whole technology stack of camlP4</b>, if we could reach some consensus, I would be happy to handle over the maintaining of  Fan, Fan does not loose any feature compared with camlP4, in fact it has more interesting featrues.</div>
<div> </div>
<div>   Let’s begin with some easy, not too technical parts which has a significant effect on user experience though:</div>
<div>   1. Performance</div>
<div>          Performance does matter, it’s a shame that  the most time spent in compiling the ocaml compiler is dedicated to camlP4, but it is an engineering problem, currently compiling Fan only takes less than 20s, and it can be improved further</div>
<div>   2. Building issues</div>
<a onclick="switchContent('post3','post4')" class="btn" href="#1a026b7f6cf6c617e92908a40e7123d9">Read more...</a></div><div id="post4" style="display: none"><p>There are some interesting discussions in the wg-camlp4 mailing list, I wrote a long mail yesterday, I cleaned it a bit, pasted it here </p>
<p>———</p>
<div> I rewrite the whole camlP4(named Fan) from scratch, building the quotation kit and throw away the crappy grammar parser, so plz believe me <b>that I do understand the whole technology stack of camlP4</b>, if we could reach some consensus, I would be happy to handle over the maintaining of  Fan, Fan does not loose any feature compared with camlP4, in fact it has more interesting featrues.</div>
<div> </div>
<div>   Let’s begin with some easy, not too technical parts which has a significant effect on user experience though:</div>
<div>   1. Performance</div>
<div>          Performance does matter, it’s a shame that  the most time spent in compiling the ocaml compiler is dedicated to camlP4, but it is an engineering problem, currently compiling Fan only takes less than 20s, and it can be improved further</div>
<div>   2. Building issues</div>
<div>        The design of having side effects by dynamic loading is generically a bad idea, in Fan<b> the dynamic loading only register some functionality the Fan support,</b> it <b>does not have any other side effec</b>t, each file stands alone says which (ppx , or filters, or syntax) it want to use with a good default option. so the building is always something like ‘-pp fan pluging1 plugin2 plugin3′, <b>the order of pulgings does not matter</b>, also, l<b>oading all the plugins you have does not have any side effect, even better, you can do the static linking all the plugins you collected, the building process is simplified.  </b></div>
<div><b> </b> 3. Grammar Extension (<b>Language namespace</b>)</div>
<div><b>       </b>I concur that grammar extension arbitrarily is a bad idea, and I agree with Gabrier that so far only the quotation(Here  quotation means delimited DSL, quosi-quotation means Lisp style macros) is modular, composable, and  I also agree with Gabrier -ppx<b> should not be used to do syntax overriding (this should not be called syntax extension actually), </b>that’s a terrible idea to do syntax overriding, since the user never understand what’s going on underly without reading the Makefile. So here some my suggestion is that some really conevenient syntax extesion, i.e, (let try.. in) should be merged to the built in parser. quotations does not bring too much heavy syntax (imho). In Fan, we proposed the concept of a hierarchical language name space, since once quotation is heavily used, it’s really easy to introduce conflict, <b>the language namespace querying is exactly like java package namespace,</b> you can import, close import to save some typing.</div>
<div>    Here is a taste</div>
<div>   ———————————————————————————————–</div>
<div>     {:.Fan.Lang.Meta.expr| a + b |} ——&gt; </div>
<div>      `App (`App ((`Id (`Lid “+”)), (`Id (`Lid “a”)))), (`Id (`Lid “b”)))</div>
<div>     {:.Fan.Lang.Meta.N.expr| a + b |}  —–&gt;</div>
<div>      `App</div>
<div>    (_loc,</div>
<div>      (`App</div>
<div>         (_loc, (`Id (_loc, (`Lid (_loc, “+”)))),</div>
<div>           (`Id (_loc, (`Lid (_loc, “a”)))))),</div>
<div>      (`Id (_loc, (`Lid (_loc, “b”))))) </div>
<div>
<div> ———————————————————————————————–</div>
<div> the .Fan.Lang.Meta.expr the first ‘.’ means it’s from the absolute namespace,  the <b>N.expr shares exactly the same syntax without location</b>, though</div>
</div>
<div> </div>
<div>   4. Portable to diffierrent compiler extensions(like LexiFi’s fork of ocaml)</div>
<div>       I am pretty sure it’s pretty easy to do in Fan, only Ast2pt (dumping the intemediate Ast into Parsetree) part need to be changed to diffierent compilers.
<div> </div>
<div>—————————————————————————————————————-</div>
<div>Now let’s talk about some internal parts of SMP.</div>
<div>Quasi-Quotation is the essential part of SMP,  I am surprised so far that the discussion <b>silently ignores the quasi-quotation,</b> Leo’s answer of writing   three parsers is neither satisfying nor practical(imho). </div>
<div> </div>
<div>Camlp4 is mainly composed of two parts, one is the extensible parser and <b>the other significant part is Ast Lifting</b>. Since we all agree that extensible parser increases the complexity too much, let’s simply ignore that part.</div>
<div> </div>
<div>The Ast Lifting are tightly coupled <b>with the design of the Abstract Syntax Tree.</b>  People complain about that Camlp4 Ast is hard to learn and using quasi-quotation to do the pattern match is a bad idea.</div>
<div> </div>
<div>Let me explain the topic a bit:</div>
<div>    Camlp4Ast is hard to learn, I agree, it has some alien names that nobody understand what it  means, quosi-quotation <b>is definitely a great idea</b> to boom the meta-programming, but my experience here is <b>for very very small Ast fragment, using the Abstract Syntax Tree directly,</b> otherwise Quasi-quotation is a life saver to do the meta programming.</div>
<div>   Luckily the quotation kit has nothing to do with the parser part, it’s simply several functions(I did some simplify a bit) which turns a normal runtime  </div>
<div>value into an Ast node generically, <b>such kind functions are neither easy to write nor easy to read</b>,<b>the idea case is that it should be generated once for all, and all the data types in normal ocaml</b><b>should be derived automatically</b>(some ADT with functions can not be derived). <b>I bet it’s mostly likely a nightmare if we maintain 3 parsers for the ocaml grammar while two other parsers dumping to a meta-level</b></div>
<div>  </div>
<div>   So, how to make Ast Lifting easier, </div>
<div>        The first guideline is <b>“Don’t mixing with records”, </b></div>
<div><b>         </b>Once you encoding AST with records, you have to encode the records in the meta level which increases the complexity without bringing any new features, <b>it’s simply not worthwhile.</b></div>
<div><b> </b></div>
<div><b>       </b> The second guideline is “Don’t do <b>any </b>syntax desugaring” , syntax desguaring makes the semantics of syntax meta programming a bit weird. Syntax desguaring happens everywhere in Parsetree, think about the list literals, it uses the syntax desuaring, if you don’t use any syntax desugaring, for example, you want to match the bigarray access, you simply needed to match `Bigarray(..)’ instead of </div>
<div>
<div> </div>
<div>Pexp_apply</div>
<div>        ({pexp_desc=Pexp_ident</div>
<div>                     {txt= Ldot (Ldot (Lident “Bigarray”, array), (“get”|”set” as gs)) ;_};_},</div>
<div>         label_exprs)</div>
</div>
<div>—————————-</div>
<div>       The third guideline is to<b> </b>make it <b>as uniform as possible</b></div>
<div><b>       </b>This not only helps the user, but <b>it helps the meta-programming over types to derive some utility types. </b>Take a look at my Ast encoding in Fan <a href="https://github.com/bobzhang/Fan/blob/master/src/Ast.ml" target="_blank">https://github.com/bobzhang/Fan/blob/master/src/Ast.ml</a> (it needs to be polished, plz don’t panic when you see variants I use here)</div>
<div><b>      </b>The initial Ast has locations and ant support, but<b> here we derive 3 other Asts thanks to my very regular design</b>.<b> AstN is the Ast without locations</b>, the locations are important, but it is simply not too much helpful when you only do the code generation, but it complicates the expanded code a lot), <b>AstA is the Ast without antiquotations(simply remove the ant branch), </b>it is a subtype of Ast(thanks to the choice we use variants here), <b>AstNA is the Ast without neither locations nor antiquotations</b>), it is a subtype of AstN.  <b>In practice, I found the Ast without locations is particular helpful when you only do the code generation, it simplifies this part significantly.<i><span style="text-decoration: underline;"> The beautif</span></i></b><span style="text-decoration: underline;"><b><i>u</i></b><i>l part is that  all the four Ast share the same grammar with the same quosiquotatoin mechanism, as I showed .Fan.Lang.N.expr and .Fan.Lang.expr</i></span></div>
<div>    I don’t know how many parsers you have to maintain to reach such a goal or it’s never going to happen.</div>
<div>    Using variants to encode the intermediate ast has a lots of other benefits, but I don’t want to cover it in such a short mail.</div>
<div> </div>
<div>   So,<b> my proposal is that the community design an Intermediate Ast together, and write a built-in parser to such Intermediate Ast then dump to Parsetree, but I am for that Parsetree still needs to be cleaned a bit but not too much change .  </b>I do appreciate you can take something away from Fan, I think the Parsetree is<b> not the ideal part</b> to do SMP, HTH</div>
</div>
<p> </p>
<br/>  <a href="http://feeds.wordpress.com/1.0/gocomments/hongboz.wordpress.com/69/" rel="nofollow"><img src="http://feeds.wordpress.com/1.0/comments/hongboz.wordpress.com/69/" alt="" border="0"/></a> <img src="http://stats.wordpress.com/b.gif?host=hongboz.wordpress.com&amp;blog=40164267&amp;post=69&amp;subd=hongboz&amp;ref=&amp;feed=1" alt="" height="1" border="0" width="1"/><a onclick="switchContent('post4','post3')" class="btn" href="#1a026b7f6cf6c617e92908a40e7123d9">Hide</a></div></span>
<a name="14157a6ff510a7115b1195580c0b23fd"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/blog/introduction-to-mezzo-2"> Introduction to Mezzo, continued</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">30 Jan 2013</span></span><span class="rss-description"><div id="post5"><p>In the previous blog post, I introduced a new framework for reasoning about programs: permissions, a sort of hybrid between a type system and a program logic. The main selling point is that it allows one to reason in a finer-grained manner about programs. The current incarnation of the permission mechanism is <a href="http://gallium.inria.fr/~protzenk/mezzo-lang/"><em><strong>Mezzo</strong></em></a>, a language in the tradition of ML.</p>
<p>The first question that comes fairly naturally is: why are we going such great lengths trying to design such a complex reasoning framework? Here are some answers:</p>
<ul>
<li>since mutable portions of the heap have a unique owner, programs written in <em><strong>Mezzo</strong></em> enjoy the property that they are data-race free, that is, we may never have two people trying to access a writable location at the same time;</li>
<li>thus, we are allowed to perform strong updates, that is, updates that change the type of a variable.</li>
</ul>
<a onclick="switchContent('post5','post6')" class="btn" href="#14157a6ff510a7115b1195580c0b23fd">Read more...</a></div><div id="post6" style="display: none"><p>In the previous blog post, I introduced a new framework for reasoning about programs: permissions, a sort of hybrid between a type system and a program logic. The main selling point is that it allows one to reason in a finer-grained manner about programs. The current incarnation of the permission mechanism is <a href="http://gallium.inria.fr/~protzenk/mezzo-lang/"><em><strong>Mezzo</strong></em></a>, a language in the tradition of ML.</p>
<p>The first question that comes fairly naturally is: why are we going such great lengths trying to design such a complex reasoning framework? Here are some answers:</p>
<ul>
<li>since mutable portions of the heap have a unique owner, programs written in <em><strong>Mezzo</strong></em> enjoy the property that they are data-race free, that is, we may never have two people trying to access a writable location at the same time;</li>
<li>thus, we are allowed to perform strong updates, that is, updates that change the type of a variable.</li>
</ul>
<p>The latter item may seem of dubious usefulness; indeed, the <code>mswap</code> example that I used seems artificial, and I have never needed it in practice. However, the example of <code>concat</code> at the end of the <a href="http://gallium.inria.fr/blog/introduction-to-mezzo/">previous post</a> is much more useful: it is emblematic of a more general concept of “destination-passing-style” algorithms that allow one to write functions in a safe, tail-recursive way, without resorting to unsafe hacks.</p>
<p>However, as I hinted in the conclusion of the previous blog post, with the elements I have presented so far, there are some serious limitations.</p>
<p>In this blog post, I will introduce a novel mechanism called <em>adoption</em> and <em>abandon</em>, which allows one to safely alias mutable data, while remaining inside the permission framework; in particular, this means we'll continue to guarantee the unique-owner property for mutable blocks. Of course, there's no free lunch: this <em>adoption</em> and <em>abandon</em> mechanism incurs a dynamic cost at runtime.</p>




<h3 id="a-story-of-adoption-and-abandon">A story of adoption and abandon</h3>
<h4 id="meet-the-fifo-our-favorite-example">Meet the fifo, our favorite example</h4>
<p>The running example in this section will be a first-in first-out structure, that is, a fifo. Cells are appended at the end, and popped from the front of the fifo. The loop at the end of the fifo is just a trick to avoid making the <code>next</code> field an <code>option</code> type.</p>
<div class="figure">
<img src="http://gallium.inria.fr/blog/fifo.svg" alt="The pointer structure of the fifo"/><p class="caption">The pointer structure of the fifo</p>
</div>
<ul>
<li>The type <code>cell</code> is mutable: we need to rewire the pointers when we we call either <code>retrieve</code> or <code>insert</code> on the fifo.</li>
<li>The type <code>fifo</code> is also mutable, since its <code>head</code> and <code>tail</code> fields change over time.</li>
</ul>
<h4 id="an-aliasing-problem">An aliasing problem</h4>
<p>One can see already that there is a problem with this aliasing pattern. If there's only one element in the fifo, and the user does:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> x = fifo.head <span class="kw">in</span>
<span class="kw">let</span> y = fifo.tail <span class="kw">in</span>
<span class="co">(* x @ cell ∗ y @ cell *)</span></code></pre>
<p>...then the user has aliased the same cell, and has two exclusive permissions for it. This is a violation of our rules, and the permission system definitely won't allow that! So we can't declare the <code>head</code> and <code>tail</code> field to be <code>cell</code>s...</p>
<h4 id="getting-back-an-ownership-tree">Getting back an ownership tree</h4>
<p>In essence, the problem is that the ownership graph is not a forest, and the permission system can only express forest-like ownership patterns. We need to move back to a forest-like ownership pattern. We achieve this through the <em>adoption</em> mechanism.</p>
<p>We say that the fifo can now <em>adopt the cells</em>. That is, the permission for the cells is “hidden” under the permission for the fifo; in other words, if you own the fifo, you own the cells. Once adopted, the type of a cell changes to reflect the fact that it may be owned by someone else.</p>
<h5 id="some-data-types">Some data types</h5>
<p>Let us first take a look at the definition of type <code>fifo a</code> and <code>cell a</code>, respectively fifo and cells holding elements of type <code>a</code>.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">mutable</span> data fifo a =
  | <span class="dt">Empty</span> { head: (); tail: () }
  | <span class="dt">NonEmpty</span> { head: dynamic; tail: dynamic }
adopts cell a

<span class="kw">mutable</span> data cell a =
  | <span class="dt">Cell</span> { contents: a; next: dynamic }</code></pre>
<p>The important point here is the <code>adopts</code> clause that's attached to the definition of <code>fifo</code>; this clause refers to the whole type. We will see in a minute the meaning of type <code>dynamic</code>.</p>
<h5 id="adoption">Adoption</h5>
<p>The first operation consists in giving up our ownership of a cell, and transferring it to the fifo object.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* x @ cell a ∗ f @ fifo a *)</span>
give x <span class="kw">to</span> f;
<span class="co">(* x @ dynamic ∗ f @ fifo a *)</span></code></pre>
<p>After we've given up our knowledge of <code>x</code>, we no longer know that it is a cell. The only thing that remains for us to know about <code>x</code> is that it has type <code>dynamic</code>: it means that <code>x</code> may be currently adopted by someone.</p>
<p>What is the point, then, of giving up our knowledge of <code>x</code>? The key difference is that, unlike <code>cell a</code>, <code>dynamic</code> is a duplicable type, which means we can alias <code>x</code>.</p>
<h5 id="abandon">Abandon</h5>
<p>The converse operation, abandon, works as follows; it allows one to regain the whole knowledge about a variable; in our case, regain the permission <code>x @ cell a</code>.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* x @ dynamic ∗ f @ fifo a *)</span>
take x from f;
<span class="co">(* x @ cell a ∗ f @ fifo a *)</span></code></pre>
<p>How do we know that the type that <code>x</code> should regain is <code>x @ cell a</code>? This is achieved by doing a lookup on the definition of <code>f</code>, and seeing that fifos adopt elements of type <code>cell a</code>.</p>
<p>An element, in order to be an adopter, must be mutable. Moreover, adopters can only adopt one type of elements.</p>
<p>The safety of the whole thing depends on the fact that the <em>take</em> operation must never succeed twice, otherwise we could have <code>x @ cell a ∗ x @ cell a</code>: this would be a definite breach of soundness.</p>
<p>The general idea is that when you <code>give</code> an element, you become free to alias it, but it is your responsibility to make sure you never <code>take</code> it twice, that is, to make sure you never call <code>take x from f; take y from f</code> with <code>x</code> and <code>y</code> being aliases. In the case of the fifo, it is easy to make mistakes: if the fifo only has one element, the following code will fail:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">take fifo.head from fifo;
take fifo.tail from fifo;</code></pre>
<h5 id="making-sure-the-code-fails">Making sure the code fails</h5>
<p>The last point that we need to address is how to make sure that the <em>take</em> operation cannot succeed twice for the same element. This is achieved using a hidden field and dynamic tests.</p>
<p>Each mutable object has a hidden field; the hidden field contains the address of the adopter if the object is currently adopted, <code>null</code> otherwise.</p>
<ul>
<li>When <code>give</code>'ing <code>x</code> to <code>f</code>, we set the hidden field of <code>x</code> to be the address of <code>f</code>.</li>
<li>When taking <code>x</code> from <code>f</code>, we check that the hidden field of <code>x</code> and the address of <code>f</code> match; if this is the case, we can safely assume that <code>x</code> has the type to be found in the <code>adopts</code> clause in the definition of the type of <code>f</code>; then, we null out the field.</li>
</ul>
<p>In the example of the one-element fifo, after taking <code>head</code>, the hidden field would be nulled out, and the second attempt to take <code>tail</code> would fail, since the value in the hidden field (<code>null</code>) and the address of the adopter would fail to match.</p>
<h4 id="illustrating-all-these-concepts">Illustrating all these concepts</h4>
<p>In order to better understand how we use all these mechanisms to type-check a program, we have a step-by-step animation explaining how a given piece of code is type-checked. We chose the <code>insert</code> function that inserts an element into the fifo.</p>
<p><a href="http://gallium.inria.fr/blog/insert-full.raw.html" class="fancybox fancybox.iframe">See the <code>insert</code> example</a> (use the "step forward" and "step back" links).</p>
<p>Some notes about this example:</p>
<ul>
<li>the <code>dynamic</code> permission is always available on-demand for <code>x</code>, as long as we know that there is an exclusive permission for <code>x</code>;</li>
<li>we use the <code>tag of &lt;-</code> instruction; it allows one to <em>change the tag</em> of a value; the definition for the new tag must have the same number of fields;</li>
<li>structural types feature an <code>adopts</code> clause – without it, the system would be unsound;</li>
<li>when we enter the function, the permissions we gain are those brought to us through the arguments;</li>
<li>when we exit the function, we must make sure <code>f @ fifo a</code> is still available; however, because <code>x</code> is consumed, we don't have anything to ensure about <code>x</code>.</li>
</ul>
<h4 id="the-power-of-adoptionabandon">The power of adoption/abandon</h4>
<p>Adoption and abandon provide an easy escape hatch to make sure you can write your program, even if the aliasing pattern is too complex to be expressed in the pure permission mechanism. The <code>give</code> and <code>take</code> operations are thread-safe; they incur no race conditions, that is, <code>give</code> cannot succeed in two separate threads simultaneously.</p>
<p>Of course, there is a penalty, both in terms of memory space (hidden field) and runtime tests (<code>give</code> and <code>take</code> operations). Time will tell whether this is something that we can live with, or if it is too expensive. A short-term goal is to allow one to declare a data type is being “slim” (no hidden field) or “fat” (with a hidden field). A long-term goal is to allow one to plug in a proof that the extra dynamic tests are not needed, so that the compiler can skip the tests altogether.</p>
<h3 id="what-is-the-state-of-mezzo">What is the state of <em><strong>Mezzo</strong></em>?</h3>
<p>If you've reached that stage of the blog post, you have my entire gratitude, as this was quite a technical topic and I'm afraid it has been fairly long.</p>
<h4 id="the-prototype">The prototype</h4>
<p>We currently have a prototype type-checker that is available on our <a href="http://gallium.inria.fr/~protzenk/mezzo-lang/">web page</a>, along with several examples of programs that the type-checker currently accepts. There is a fairly long to-do list, and the type-checker is currently unsound in many corners, but this is something that we're aware of and that we know how to fix.</p>
<h4 id="concurrency">Concurrency</h4>
<p>Of course, if we are to go such great lengths, we might as well have concurrency built into the language. <a href="http://gallium.inria.fr/~balabons/">Thibaut Balabonski</a> is currently tackling the problem. Here is an example of how we could leverage the permission mechanism:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">abstract lock (p: perm)
fact duplicable (lock p)
<span class="kw">val</span> create @ [p :: <span class="dt">PERM]</span> () -&gt; lock p
<span class="kw">val</span> acquire @ [p :: <span class="dt">PERM]</span> lock p -&gt; (| p)
<span class="kw">val</span> release @ [p :: <span class="dt">PERM]</span> (lock p | consumes p) -&gt; ()</code></pre>
<p>A lock simply protects access to a permission (think of <code>p</code> as <code>x @ ref int</code> where <code>x</code> is a variable in scope). You can copy the lock around, pass it to other threads, and try to <code>acquire</code> it: when you succeed, you obtain the permission. When you want to <code>release</code> the lock, you must give up the permission from your context.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">data outcome (p :: <span class="dt">PERM</span>) =
  | <span class="dt">Success</span> { | p }
  | <span class="dt">Failure</span> { }

<span class="kw">val</span> try_acquire @ [p :: <span class="dt">PERM]</span> lock p -&gt; outcome p</code></pre>
<p>If we were to implement <code>try_acquire</code>, we could write a data type that expresses the fact that in case the operation succeeds, you obtain <code>p</code> in the corresponding <code>match</code> branch.</p>
<p>The signature for a <code>spawn</code> function could be as follows:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">val</span> spawn (f: (|p) -&gt; () | p) -&gt; ()</code></pre>
<p>...where <code>f</code> requires a set of permissions <code>p</code> to execute, and <code>spawn</code> takes <code>p</code> from its caller, and uses it to launch <code>p</code>.</p>
<h4 id="compilation">Compilation</h4>
<p>We had an intern, Henri Chataing, work on a very prototype-ish implementation of a compilation scheme emitting OCaml code with calls to <code>Obj.magic</code> sprinkled in the right places. We're unsure as to whether that's the right direction; we're also considering emitting CIL code, or C# code directly to take advantage of the real multithreaded capabilities of the CLR...</p>
<h4 id="i-want-to-participate">I want to participate!</h4>
<p>We have many opportunities for internships, do contact us if you feel like you want to work on designing an exciting new language!</p><a onclick="switchContent('post6','post5')" class="btn" href="#14157a6ff510a7115b1195580c0b23fd">Hide</a></div></span>
<a name="f81fa2e6263500a46851e7258409c210"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/forum/forum.php?forum_id=869"> ocurl 0.5.4 released</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge News</span>, <span class="rss-date">29 Jan 2013</span></span><span class="rss-description"><pre class="rss-text">ocurl is the set of bindings to libcurl - URL transfer library, supporting HTTP and many other protocols.

This project is the fork of http://ocurl.sourceforge.net/ and accumulates many bugfixes and enhancements which didn't make it to the original version, including the multi API wrappers and pluggable asynchronous interface (which makes it possible to inject curl transfers in your event loop of choice). This is the first release for the fork, that incorporates all the bugfixes and new features from 3 years of its history, except the asynchronous api. Next release will merge branch event.

I would like to thank Lars Nilsson, the original author of ocurl, who brought this project to existence.</pre></span>
<a name="f8948c49e20787054d82ce6dd7144808"></a><span class="rss-header"><span class="rss-title"><a href="http://blog.elehack.net/tagged/ocaml?format=rss/9d1ead73e678fa2f51a70a933b0bf017"> Not Found</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Michael Ekstrand</span>, <span class="rss-date">29 Jan 2013</span></span><span class="rss-description"><p>The URL you requested could not be found.</p></span>
<a name="4c4775ee631d70b703ad0f029d59c21b"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2013.01.29.html"> Caml Weekly News, 29 Jan 2013</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">29 Jan 2013</span></span><span class="rss-description">beta-release of OPAM / Portable timeout function / omonad-0.0.1 / OCaml 4.00.1 for Android: OPAM packages / Working Group: the future of syntax extensions in OCaml, after camlp4 / If I wanted to write SWIG in OCaml, what library would I need? / Datalog-0.1 / CWN archive links / Other Caml News</span>
<a name="c8cb9f4fd1ec2a3d96ba66274368ae69"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/ocurl/"> ocurl</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">28 Jan 2013</span></span><span class="rss-description">bindings to libcurl &lt;http://curl.haxx.se/libcurl/&gt;. This is a fork of &lt;http://ocurl.sourceforge.net/&gt;, with multi API wrappers and pluggable asynchronous interface.</span>
<script type="text/javascript">function switchContent(id1,id2) {
     // Get the DOM reference
     var contentId1 = document.getElementById(id1);
     var contentId2 = document.getElementById(id2);
     // Toggle
     contentId1.style.display = "none";
     contentId2.style.display = "block";
     }</script></div>

  
    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>

    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-37808023-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

    </script>

</body></html>
