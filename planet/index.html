<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: OCaml Planet</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contributors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="OCaml Planet" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it Online</a></li>
    <li><a href="../taste.html">100 Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who Is Using It?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a>
        <a href="http://langref.org/ocaml">langref.org</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
    <li><a href="../papers.html">Papers</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../releases/">Releases</a></li>
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development Tools</a></li>
    <li><a href="../books.html#manual">User Manual</a></li>
    <li><a href="../cheat_sheets.html">Cheat Sheets</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API Search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">GitHub</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing Lists</a></li>
    <li><a href="../planet/">Blogs</a></li>
    <li><a href="../meetings/">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>OCaml Planet
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

    <h1>OCaml Planet</h1>

    <p>The OCaml Planet aggregates various blogs from the OCaml
    community.  It is kindly provided
    by <a href="http://www.ocamlcore.com/">OCamlCore</a>.  If you
    would like to be added, read
    the <a href="http://www.ocamlcore.org/planet/">Planet
    subscription HOWTO</a>.</p>

    <br/>
    <div style="float: right; margin-right: 0; margin-top: 0" class="span2 planet-subscriptions"><em>Subscriptions</em>
      <ul><li><a href="http://alexleighton.tumblr.com/tagged/ocaml/rss">Alex Leighton</a></li><li><a href="http://feeds.feedburner.com/amirmc-ocaml">Amir Chaudhry</a></li><li><a href="http://andreiformiga.com/blog/?cat=5&feed=rss2">Andrei Formiga</a></li><li><a href="http://math.andrej.com/feed/">Andrej Bauer</a></li><li><a href="http://anil.recoil.org/feeds/atom.xml">Anil Madhavapeddy</a></li><li><a href="http://ashishagarwal.org/tag/ocaml/feed/">Ashish Agarwal</a></li><li><a href="http://www.blogger.com/feeds/7617521785419311079/posts/default">Cameleon news</a></li><li><a href="http://caml.inria.fr/news.en.rss">Caml INRIA</a></li><li><a href="http://camlspotter.blogspot.com/feeds/posts/default?alt=rss">Caml Spotting</a></li><li><a href="http://alan.petitepomme.net/cwn/cwn.rss">Caml Weekly News</a></li><li><a href="http://coherentpdf.com/blog/?tag=ocaml&feed=rss">Coherent Graphics</a></li><li><a href="http://coq.inria.fr/news/feed">Coq</a></li><li><a href="http://erratique.ch/feeds/news.atom">Daniel Bünzli</a></li><li><a href="http://nleyten.com:82/feed/tag/ocaml/atom">Dario Teixeira</a></li><li><a href="http://www.blogger.com/feeds/17133288/posts/default/-/ocaml">David Baelde</a></li><li><a href="http://blog.bentobako.org/index.php?feed/tag/ocaml/atom">David Mentré</a></li><li><a href="http://dutherenverseauborddelatable.wordpress.com/category/ocaml/feed/">David Teller</a></li><li><a href="http://www.examachine.net/blog/cat/ocaml/feed/">Eray Özkural</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/index.rss20">Erik de Castro Lopo</a></li><li><a href="http://blog.emillon.org/feeds/ocaml.xml">Etienne Millon</a></li><li><a href="http://www.blogger.com/feeds/8964007124326996693/posts/default/-/ocaml">Fayssal Martani</a></li><li><a href="http://frama-c.com/rss.xml">Frama-C</a></li><li><a href="http://functionaljobs.com/jobs/search/?q=ocaml&format=rss">Functional Jobs</a></li><li><a href="http://gallium.inria.fr/blog/index.rss">GaGallium</a></li><li><a href="http://gaiustech.wordpress.com/category/ocaml/feed/">Gaius Hammond</a></li><li><a href="http://blog.camlcity.org/blog/rss">Gerd Stolpmann</a></li><li><a href="http://www.wisdomandwonder.com/tag/OCaml/feed">Grant Rettke</a></li><li><a href="http://hongboz.wordpress.com/feed/">Hong bo Zhang</a></li><li><a href="http://blog.incubaid.com/tag/ocaml/feed/">Incubaid Research</a></li><li><a href="http://ambassadortothecomputers.blogspot.com/feeds/posts/default?alt=rss">Jake Donham</a></li><li><a href="http://scattered-thoughts.net/atom.xml">Jamie Brandon</a></li><li><a href="https://ocaml.janestreet.com/?q=rss.xml">Jane Street</a></li><li><a href="http://lpw25.net/rss.xml">Leo White</a></li><li><a href="http://www.lexifi.com/blogs/ocaml/feed">LexiFi</a></li><li><a href="http://newblog.0branch.com/rss.xml">Marc Simpson</a></li><li><a href="http://syntaxexclamation.wordpress.com/tag/ocaml/feed/">Matthias Puech</a></li><li><a href="http://www.blogger.com/feeds/5888658295182480819/posts/default">Matías Giovannini</a></li><li><a href="http://www.elehack.net/michael/blog/tags/ocaml?format=rss">Michael Ekstrand</a></li><li><a href="">Mihamina Rakotomandimby</a></li><li><a href="http://mcclurmc.wordpress.com/feed/">Mike McClurg</a></li><li><a href="http://nyc-ocaml.posterous.com/rss.xml">NYC OCaml</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfnews.php">OCamlCore Forge News</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfprojects.php">OCamlCore Forge Projects</a></li><li><a href="http://www.ocamlcore.com/wp/?feed=rss2&amp;language=en&#038;language=en">OCamlCore.com</a></li><li><a href="http://www.ocamlpro.com/feed/atom.xml">OCamlPro</a></li><li><a href="http://odns.tuxfamily.org/feed/">ODNS project</a></li><li><a href="http://ox.tuxfamily.org/feed/">Ocaml XMPP project</a></li><li><a href="http://ocsigen.org/news.atom">Ocsigen project</a></li><li><a href="http://www.blogger.com/feeds/2073503406800427577/posts/default">Opa</a></li><li><a href="http://www.openmirage.org/blog/atom.xml">Open Mirage</a></li><li><a href="http://functional-orbitz.blogspot.com/feeds/posts/default/-/planetocaml?alt=rss">Orbitz</a></li><li><a href="http://www.donadeo.net/facets/programming-languages/objective-caml/feed/">Paolo Donadeo</a></li><li><a href="https://mancoosi.org/~abate/taxonomy/term/5/0/feed">Pietro Abate</a></li><li><a href="http://rwmj.wordpress.com/tag/ocaml/feed/">Richard Jones</a></li><li><a href="http://blog.rastageeks.org/spip.php?page=rss&id_mot=2">Romain Beauxis</a></li><li><a href="http://seb.mondet.org/blog/feed/ocaml.rss">Sebastien Mondet</a></li><li><a href="http://upsilon.cc/~zack/tags/ocaml/index.rss">Stefano Zacchiroli</a></li><li><a href="http://le-gall.net/sylvain+violaine/blog/index.php?feed/tag/ocaml/atom">Sylvain Le Gall</a></li><li><a href="http://caml.inria.fr/hump.rss">The Caml Humps</a></li><li><a href="http://www.blogger.com/feeds/6115529230232389198/posts/default">Till Varoquaux</a></li><li><a href="http://y-node.com/blog/feeds/latest/">y-node</a></li></ul>

      <a href="http://planet.ocaml.org/rss20.xml"><img src=".././img/rss20.png"/></a>
      <a href="http://planet.ocaml.org/opml.xml"><img src=".././img/opml.png"/></a>
    </div>
    <div class="planet"><a name="ea3a33b9f10f2055d03ae11467486927"></a><span class="rss-header"><span class="rss-title"><a href="http://syntaxexclamation.wordpress.com/?p=365"> malloc() is the new gensym()</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Matthias Puech</span>, <span class="rss-date">04 May 2013</span></span><span class="rss-description"><div id="post1"><a onclick="switchContent('post1','post2')" class="btn" href="#ea3a33b9f10f2055d03ae11467486927">Read more...</a></div><div id="post2" style="display: none"><p>Teaching an introductory course to “compilation” this semester (actually it was called <a href="http://www.pps.univ-paris-diderot.fr/~puech/ens/mv6.html">Virtual Machines</a>, but it was really about compiling expressions to stack machines), I realized something I hadn’t heard before, and wish I had been told when I first learned OCaml many years ago. Here it is: as soon as you are programming in a functional language with physical equality (i.e. pointer equality, the <code>(==)</code> operator in OCaml), then you are actually working in a “weakly impure” language, and you can for example implement a limited form of <code>gensym</code>. What? <code>gensym</code> is this classic “innocuously effectful” function returning a different <i>symbol</i>—usually a string—each time it is called. It is used pervasively to generate fresh variable names, in compilers notably. How? well, you actually don’t have much to do, except let the runtime call <code>malloc</code>: it will return a “fresh” pointer where to store your data. <code>malloc</code> and the garbage collector together ensures this freshness condition, and you can then compare two pointers with <code>(==)</code>. As a bonus, you can even store data along your fresh symbol.</p> <p>In this post, I’ll exploit that simple idea to develop an assembler for a little stack machine close to that of OCaml.</p> <p><span id="more-365"></span></p> <h3>The idea</h3> <p>In OCaml, something as simple as this is a <code>gensym</code>:</p> <pre class="brush: fsharp; title: ; notranslate">type 'a sym = C of 'a let gensym x = C x </pre> <p>Each call to say <code>gensym ()</code> will allocate one new data block in memory; you can then compare two symbols with the physical equality <code>(==)</code>.What we care about here is not the content of that memory span, but its <i>address</i>, which is unique.</p> <p>A few warnings first: in OCaml, the constructor must have arguments, otherwise the compiler optimizes the representation to a simple integer and nothing is allocated. Also, don’t replace the argument <code>x</code> to <code>C</code> by a constant, say <code>()</code>, in the function code: if you do so, the compiler will place value <code>C ()</code> in the data segment of the program, and calling <code>gensym</code> will not trigger an allocation either. There is an excellent and already classic series of blog post about OCaml’s value representation <a href="http://rwmj.wordpress.com/2009/08/04/ocaml-internals/">here</a>.</p> <p>Another way of saying the same thing is that (non-cyclic) values in OCaml are not trees, as they can be thought of considering the purely functional fragment, but DAGs, that is trees with sharing. </p> <p>I think that not many beginner/intermediate OCaml programmers realize the power of this, so I’d like to show a cool application of this remark. We will code a small compiler from a arithmetic language to a stack machine. Bear with me, it’s going to be fun!</p> <h3>An application: compiling expressions to a stack machine</h3> <p>The input language of expressions is:</p> <pre class="brush: fsharp; title: ; notranslate">type expr = | Int of int | Plus of expr * expr | If of expr * expr * expr </pre> <p>Its semantics should be clear, except for the fact that <code>If</code> are like in C: if their condition is different than 0, then their first branch is taken; if it is 0, then the second is taken. Because we have these conditionals, the stack machine will need instructions to jump around in the code. The instructions of this stack machine are:</p> <ul> <li><code>Push i</code> pushes <code>i</code> on the stack;</li> <li><code>Add</code> pops two values off the stack and pushes their sum;</li> <li><code>Halt</code> stops the machine and returning the (supposedly unique) stack value;</li> <li><code>Branch o</code> skips the next <code>o</code> instructions in the code;</li> <li><code>Branchif o</code> skips the next <code>o</code> instructions <i>if</i> the top of the stack is not <code>0</code>, and has no effect otherwise </li></ul> <p>For instance, the expression <i>1 + (if 0 then 2 else (3+3))</i> is compiled into:</p> <pre class="brush: fsharp; title: ; notranslate">[Push 1; Push 0; Branchif 3; Push 3; Push 3; Add; Branch 1; Push 2; Add; Halt] </pre> <p>and evaluates of course to <code>7</code>. Notice how the two branches of the <code>If</code> are turned around in the code? First, we’ve got the code of expression <i>2</i>, then the code of <i>3+3</i>. In general, expression <i>if e1 then e2 else e3</i> will be compiled to [<i>c1</i>; <code>Branchif</code> (|<i>c3</i>|+1); <i>c3</i>; <code>Branch</code> |<i>c2</i>|; <i>c2</i>; ...] where <i>ci</i> is the compiled code of <i>ei</i>, and |<i>l</i>| is the size of code <i>l</i>. But I’m getting ahead of myself.</p> <h3>Compilation</h3> <p>Now, compiling an <code>expr</code> to a list of instructions in one pass would be a little bit messy, because we have to compute these integer offset for jumps. Let’s follow instead the common practice and first compile expressions to an assembly language where some suffixes of the code have <i>labels</i>, which are the names referred to by instructions <code>Branch</code> and <code>Branchif</code>. This assembly language <code>asm</code> will then be well… assembled into actual <code>code</code>, where jumps are translated to integer offsets. But instead of generating label names by side-effect as customary, let’s use our trick: we will refer to them by a unique <i>pointer</i> to the code attached to it. In other words, the arguments to <code>Branch</code> and <code>Branchif</code> will actually be pointers to <code>asm</code> programs, comparable by <code>(==)</code>.</p> <p>To represent the <code>code</code> and <code>asm</code> data structures, we generalize over the notion of label:</p> <pre class="brush: fsharp; title: ; notranslate">type 'label instr = | Push of int | Add | Branchif of 'label | Branch of 'label | Halt </pre> <p>An assembly program is a list of instruction where labels are themselves assembly programs (the <code>-rectypes</code> option of OCaml is required here):</p> <pre class="brush: fsharp; title: ; notranslate">type asm = asm instr list </pre> <p>For instance, taking our previous example,</p> <pre class="brush: fsharp; title: ; notranslate">Plus (Int 1, If (Int 0, Int 2, Plus (Int 3, Int 3))) </pre> <p>is compiled to the (shared) value:</p> <pre class="brush: fsharp; title: ; notranslate">Push 1 :: Push 0 :: let k = [Add; Halt] in Branchif (Push 2 :: k) :: Push 3 :: Push 3 :: Add :: k </pre> <p>See how the suffix <code>k</code> (the continuation of the <code>If</code>) is shared among the <code>Branchif</code> and the main branch? In call-by-value, this is a value: if you reduce it any further by inlining <code>k</code>, you will get a different value, that can be told apart from the first by using <code>(==)</code>. So don’t let OCaml’s pretty-printing of values fool you: this is not a tree, the sharing of <code>k</code> <i>is</i> important! What you get is the DAG of all possible execution traces of your program; they eventually all merge in one point, the code suffix <code>k = [Add; Halt]</code>.</p> <p>The compilation function is relatively straightforward; it’s an accumulator-based function:</p> <pre class="brush: fsharp; title: ; notranslate">let rec compile e k = match e with | Int i -&gt; Push i :: k | Plus (e1, e2) -&gt; compile e1 (compile e2 (Add :: k)) | If (e1, e2, e3) -&gt; compile e1 (Branchif (compile e2 k) :: compile e3 k) let compile e = compile e [Halt] </pre> <p>The sharing discussed above is realized here in the <code>If</code> case, by compiling its two branches using the accumulator (continuation) <code>k</code> twice. Again, many people think of this erroneously as <i>duplicating</i> a piece of value. Actually, this is only mentioning twice a pointer to an already-allocated unique piece of value; and since we can compare pointers, we have a way to know that they are the same. Note also that this compilation function is purely compositional: to each subexpression corresponds a contiguous span of assembly code.</p> <h3>Assembly</h3> <p>Now, real code for our machine is simply a list of instructions where labels are represented by (positive) integers:</p> <pre class="brush: fsharp; title: ; notranslate">type code = int instr list </pre> <p>Why positive? Well, since we have no way to make a loop, code can be arranged such that all jumps are made <i>forward</i> in the code.</p> <p>The assembly function took me a while to figure out. It “linearizes” the assembly, a DAG, into a list by traversing it depth-first. The tricky part is that we don’t want to repeat the common suffixes of all branches; that’s where we use the fact that they are at the same memory address, which we can check with <code>(==)</code>. If a piece of input code has already been compiled <i>n</i> instructions ahead in the output code, instead of repeating it we just emit a <code>Branch</code> <i>n</i>.</p> <p>So practically, we must keep as an argument an association list <code>k</code> mapping already-compiled suffixes of the input to the corresponding output instruction; think of it as a kind of “cache” of the function. It also doubles as the <i>result</i> of the process: it is what’s eventually returned by <code>assemble</code>. For each input <code>is</code>, we first traverse that list <code>k</code> looking for the pointer <code>is</code>; if we find it, then we have our <code>Branch</code> instruction; otherwise, we assemble the next instruction. This first part of the job corresponds to the <code>assemble</code> function:</p> <pre class="brush: fsharp; title: ; notranslate">let rec assemble is k = try (is, Branch (List.index (fun (is', _) -&gt; is == is') k)) :: k with Not_found -&gt; assem is k </pre> <p>(<code>List.index p xs</code> returns the index of the first element <code>x</code> of <code>xs</code> such that <code>p x</code> is <code>true</code>). </p> <p>Now the auxiliary function <code>assem</code> actually assembles instructions into a list of pairs of source programs and target instruction:</p> <pre class="brush: fsharp; title: ; notranslate">and assem asm k = match asm with | (Push _ | Add | Halt as i) :: is -&gt; (asm, i) :: assemble is k | Branchif is :: js -&gt; let k = assemble is k in let k' = assemble js k in (asm, Branchif (List.length k' - List.length k)) :: k' | Branch _ :: _ -&gt; assert false | [] -&gt; k </pre> <p>Think of the arguments <code>asm</code> and <code>k</code> as one unique list <code>asm @ k</code> that is “open” for insertion in two places: at top-level, as usual, and in the middle, between <code>asm</code> and <code>k</code>. The <code>k</code> part is the already-processed suffix, and <code>asm</code> is what remains to be processed. The first case inserts the non-branching instructions <code>Push, Add, Halt</code> at top-level in the output (together with their corresponding assembly suffix of course). The second one, <code>Branchif</code>, begins by inserting the branch <code>is</code> at top-level, and then inserts the remainder <code>js</code> in front of it. Note that when assembling this remainder, we can discover sharing that was recorded in <code>k</code> when compiling the branch. Note also that there can’t be any <code>Branch</code> in the assembly since it would not make much sense (everything after a <code>Branch</code> instruction would be dead code), hence the <code>assert false</code>.</p> <p>Finally, we can strip off the “cached” information in the returned list, keeping only the target instructions:</p> <pre class="brush: fsharp; title: ; notranslate">let assemble is = snd (List.split (assemble is [])) </pre> <h3>Conclusion</h3> <p>That’s it, we have a complete compilation chain for our expression language! We can execute the target code on this machine:</p> <pre class="brush: fsharp; title: ; notranslate">let rec exec = function | s, Push i :: c -&gt; exec (i :: s, c) | i :: j :: s, Add :: c -&gt; exec (i + j :: s, c) | s, Branch n :: c -&gt; exec (s, List.drop n c) | i :: s, Branchif n :: c -&gt; exec (s, List.drop (if i&lt;&gt;0 then n else 0) c) | [i], Halt :: _ -&gt; i | _ -&gt; failwith "error" let exec c = exec ([], c) </pre> <p>The idea of using labels that are actual pointers to the code seems quite natural and seems to scale well (I implemented a compiler from a mini-ML to a virtual machine close to OCaml’s bytecode). In terms of performance however, <code>assemble</code> is quadratic: before assembling each instruction, we look up if we didn’t assemble it already. When we have real (string) labels, we can represent the “cache” as a data structure with faster lookup; unfortunately, if labels are pointers, we can’t really do this because we don’t have a total order on pointers, only equality <code>(==)</code>.</p> <p>This is only one example of how we can exploit pointer equality in OCaml to mimick a name generator. I’m sure there are lots of other applications to be discovered, or that I don’t know of (off the top of my head: to represent variables in the lambda-calculus). The big unknown for me is the nature of the language we’ve been working in, functional OCaml + pointer equality. Can we still consider it a functional language? How to reason on its programs? The comment section is right below!</p> <br/> <a href="http://feeds.wordpress.com/1.0/gocomments/syntaxexclamation.wordpress.com/365/" rel="nofollow"><img src="http://feeds.wordpress.com/1.0/comments/syntaxexclamation.wordpress.com/365/" alt="" border="0"/></a> <img src="http://stats.wordpress.com/b.gif?host=syntaxexclamation.wordpress.com&amp;blog=14690639&amp;post=365&amp;subd=syntaxexclamation&amp;ref=&amp;feed=1" alt="" height="1" border="0" width="1"/><a onclick="switchContent('post2','post1')" class="btn" href="#ea3a33b9f10f2055d03ae11467486927">Hide</a></div></span>
<a name="6a0c574fd4b679c57615365f0cbfb0d1"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/forum/forum.php?forum_id=877"> Zarith 1.2 released</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge News</span>, <span class="rss-date">20 May 2013</span></span><span class="rss-description"><pre class="rss-text">Zarith is a fast, space-efficient, GMP-based library for arbitrary-precision integer and rational arithmetic. This minor release fixes a couple of bugs, improves Windows/Mingw support, and adds a fast path coded in assembly for ARM processors.</pre></span>
<a name="6c19ae2bc30d389ea47380bb420105f2"></a><span class="rss-header"><span class="rss-title"><a href="http://www.openmirage.org/blog/the-road-to-a-dev-release"> The road to a developer preview at OSCON 2013</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author"><span id="ocaml_1">Open Mirage &#9001;anil<abbr title="(at) &rarr; @">(at)</abbr>recoil.org (Anil Madhavapeddy)&#9002;</span><script type="text/javascript"><!--;
local = "anil";
h = "recoil.org (Anil Madhavapeddy)";
hq = "recoil.org%20(Anil%20Madhavapeddy)";
document.getElementById("ocaml_1").innerHTML = '<a href="mailto:' + local + '@' + hq + "\" >Open Mirage<\/a>";
//--></script></span>, <span class="rss-date">20 May 2013</span></span><span class="rss-description"><div id="post3"><p>There's been a crazy stream of activity since the start of the year, but the most important news is that we have a release target for an integrated developer preview of the Mirage stack: a talk at <a href="http://www.oscon.com/oscon2013/public/schedule/detail/28956">O'Reilly OSCon</a> in July! Do turn up there and find <a href="http://dave.recoil.org">Dave Scott</a> and <a href="http://anil.recoil.org">Anil Madhavapeddy</a> showing off interactive demonstrations.</p><p>Meanwhile, another significant announcement has been that Xen is <a href="http://www.linuxfoundation.org/news-media/announcements/2013/04/xen-become-linux-foundation-collaborative-project">joining the Linux Foundation</a> as a collaborative project. This is great news for Mirage: as a library operating system, we can operate just as easily under other hypervisors, and even on bare-metal devices such as the <a href="http://raspberrypi.org">Raspberry Pi</a>. We're very much looking forward to getting the Xen-based developer release done, and interacting with the wider Linux community (and FreeBSD, for that matter, thanks to Gabor Pali's <a href="https://github.com/pgj/mirage-kfreebsd">kFreeBSD</a> backend).</p><p>Here's some other significant news from the past few months:</p><p></p><a onclick="switchContent('post3','post4')" class="btn" href="#6c19ae2bc30d389ea47380bb420105f2">Read more...</a></div><div id="post4" style="display: none"><p>There's been a crazy stream of activity since the start of the year, but the most important news is that we have a release target for an integrated developer preview of the Mirage stack: a talk at <a href="http://www.oscon.com/oscon2013/public/schedule/detail/28956">O'Reilly OSCon</a> in July! Do turn up there and find <a href="http://dave.recoil.org">Dave Scott</a> and <a href="http://anil.recoil.org">Anil Madhavapeddy</a> showing off interactive demonstrations.</p><p>Meanwhile, another significant announcement has been that Xen is <a href="http://www.linuxfoundation.org/news-media/announcements/2013/04/xen-become-linux-foundation-collaborative-project">joining the Linux Foundation</a> as a collaborative project. This is great news for Mirage: as a library operating system, we can operate just as easily under other hypervisors, and even on bare-metal devices such as the <a href="http://raspberrypi.org">Raspberry Pi</a>. We're very much looking forward to getting the Xen-based developer release done, and interacting with the wider Linux community (and FreeBSD, for that matter, thanks to Gabor Pali's <a href="https://github.com/pgj/mirage-kfreebsd">kFreeBSD</a> backend).</p><p>Here's some other significant news from the past few months:</p><p></p><ul> <li> <p><a href="http://www.ocamlpro.com/blog/2013/03/14/opam-1.0.0.html">OPAM 1.0 was released</a>, giving Mirage a solid package manager for handling the many libraries required to glue an application together. <a href="https://github.com/vbmithr">Vincent Bernardoff</a> joined the team at Citrix and has been building a Mirage build-frontend called <a href="https://github.com/mirage/mirari">Mirari</a> to hide much of the system complexity from a user who isn't too familiar with either Xen or OCaml.</p> </li><li> <p>A new group called the <a href="http://ocaml.io">OCaml Labs</a> has started up in the <a href="http://www.cl.cam.ac.uk">Cambridge Computer Laboratory</a>, and is working on improving the OCaml toolchain and platform. This gives Mirage a big boost, as we can re-use several of the documentation, build and test improvements in our own releases. You can read up on the group's activities via the <a href="http://ocaml.io/news">monthly updates</a>, or browse through the various <a href="http://ocaml.io/tasks">projects</a>. One of the more important projects is the <a href="http://www.cl.cam.ac.uk/projects/ocamllabs/tasks/platform.html#OCamlot">OCamlot</a> continuous build infrastructure, which will also be testing Mirage kernels as one of the supported backends.</p> </li><li> <p>As we head into release mode, we've started <a href="http://www.openmirage.org/wiki/tag/overview/meetings">weekly meetings</a> to coordinate all the activities. We're keeping notes as we go along, so you should be able to skim the notes and <a href="https://lists.cam.ac.uk/pipermail/cl-mirage/">mailing list archives</a> to get a feel for the overall activities. Anil is maintaining a <a href="http://www.openmirage.org/wiki/dev-preview-checklist">release checklist</a> for the summer developer preview.</p> </li><li> <p>Anil (along with Yaron Minsky and Jason Hickey) is finishing up an O'Reilly book on <a href="http://realworldocaml.org">Real World OCaml</a>, which will be a useful guide to using OCaml for systems and network programming. If you'd like to review an early copy, please get in touch. The final book is anticipated to be released towards the end of the year, with a <a href="http://shop.oreilly.com/category/roughcuts.do">Rough Cut</a> at the end of the summer.</p> </li><li> <p>The core system was described in an <a href="http://anil.recoil.org/papers/2013-asplos-mirage.pdf">ASPLOS 2013</a> paper, which should help you understand the background behind library operating systems. Some of the Mirage libraries are also currently being integrated into the next-generation <a href="http://blogs.citrix.com/2012/05/17/introducing-windsor-a-new-xen-based-virtualization-architecture/">Windsor</a> release of the Xen Cloud Platform, which means that several of the libraries will be used in production and hence move beyond research-quality code.</p> </li> </ul><p></p><p>In the next few months, the installation notes and getting started guides will all be revamped to match the reality of the new tooling, so expect some flux there. If you want to take an early try of Mirage beforehand, don't forget to hop on the <code>#mirage</code> IRC channel on Freenode and ping us with questions directly. We will also be migrating some of the project infrastructure to be fully self-hosted on Mirage and Xen, and placing some of the services onto the new <a href="http://xenproject.org">xenproject.org</a> infrastructure.</p><a onclick="switchContent('post4','post3')" class="btn" href="#6c19ae2bc30d389ea47380bb420105f2">Hide</a></div></span>
<a name="bf0e1600c14b203a1713ed4f5476f2dc"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2013.05.21.html"> Caml Weekly News, 21 May 2013</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">21 May 2013</span></span><span class="rss-description">ocaml-bitstring 2.0.4 / standard 3d vector library in OCaml / concurrent caml-light? / 2D vector graphics / Core Suite 109.23.00 + async_parallel / Other Caml News</span>
<a name="7b4ed147f8cb0514b9374ef6800822a1"></a><span class="rss-header"><span class="rss-title"><a href="http://scattered-thoughts.net/blog/2013/05/21/flowing-faster-external-memory"> Flowing faster: External memory</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Jamie Brandon</span>, <span class="rss-date">21 May 2013</span></span><span class="rss-description"><div id="post5"><p>I always want to be a better developer than I am. What work I do that is worthwhile happens in the few hours of flow I manage to achieve every week. A million different things break that flow every day. I suspect that a large part of achieving flow is keeping the current problem in working memory. To improve my chances I can improve my working memory, offload parts of the problem to the computer or prevent context switches. I’m on my own with the first option, but a better development environment can help with the latter two.</p> <p>The first thing that I want to fix in this series is offloading memory. There are basically two kinds of questions I regularly deal with:</p> <ul> <li><p>How did I solve this problem / build this software / configure this program X months ago?</p></li> <li><p>What was I trying to remember to change X seconds ago?</p></li> </ul> <a onclick="switchContent('post5','post6')" class="btn" href="#7b4ed147f8cb0514b9374ef6800822a1">Read more...</a></div><div id="post6" style="display: none"><p>I always want to be a better developer than I am. What work I do that is worthwhile happens in the few hours of flow I manage to achieve every week. A million different things break that flow every day. I suspect that a large part of achieving flow is keeping the current problem in working memory. To improve my chances I can improve my working memory, offload parts of the problem to the computer or prevent context switches. I’m on my own with the first option, but a better development environment can help with the latter two.</p> <p>The first thing that I want to fix in this series is offloading memory. There are basically two kinds of questions I regularly deal with:</p> <ul> <li><p>How did I solve this problem / build this software / configure this program X months ago?</p></li> <li><p>What was I trying to remember to change X seconds ago?</p></li> </ul> <p>I’ve started using <a href="http://jblevins.org/projects/deft/">deft</a> to answer both of these. Deft stores notes in a folder full of flat files and adds an incremental search buffer to emacs (searching &gt; organising). This means that my notes are simple plain text which I can easily edit, backup, grep or serve on the web.</p> <p>For long-term memory I create a new note every time I solve a problem or learn something useful. Within emacs M-’ brings up the deft window, typing triggers the incremental search and hiting Enter opens the first matching note.</p> <p>For short-term memory I have a single note called stack. Hitting C-’ opens the stack note with the cursor on a new blank line for adding items to the stack. Hitting C-DEL deletes the previous line and C-q closes the stack. Hopefully this is sufficiently low-friction that the extra memory makes up for the context switch.</p> <p>My config is <a href="https://github.com/jamii/emacs-live-packs/blob/master/deft-pack/init.el">here</a>. I’m considering writing a gnome-shell extension which displays the last line of the stack in the status bar to remind me what I’m supposed to be doing when my mental stack gets rudely dumped. I also want to add the global key bindings to gnome-shell so I don’t have to navigate to emacs first.</p> <p>This is a very simple tool, which is kind of the point. The more stucture and options added to a note-taking tool the more effort it takes to actually use it and the more likely it is that I lose my entire mental stack whilst doing so.</p><a onclick="switchContent('post6','post5')" class="btn" href="#7b4ed147f8cb0514b9374ef6800822a1">Hide</a></div></span>
<a name="e97b1deb2e7be08ce0ec0acf1528d06d"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/forum/forum.php?forum_id=878"> OCaml-RDF 0.5</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge News</span>, <span class="rss-date">22 May 2013</span></span><span class="rss-description"><pre class="rss-text">Now include a Turtle parser and writer.</pre></span>
<a name="49cce4c805c48bcf79a463c3fa2abe47"></a><span class="rss-header"><span class="rss-title"><a href="http://www.ocamlpro.com/blog/2013/05/24/optimisations-you-shouldn-t-do.html"> Optimisations you shouldn't do</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author"><span id="ocaml_2">OCamlPro &#9001;pierre.chambart<abbr title="(at) &rarr; @">(at)</abbr>ocamlpro.com (Pierre Chambart)&#9002;</span><script type="text/javascript"><!--;
local = "pierre.chambart";
h = "ocamlpro.com (Pierre Chambart)";
hq = "ocamlpro.com%20(Pierre%20Chambart)";
document.getElementById("ocaml_2").innerHTML = '<a href="mailto:' + local + '@' + hq + "\" >OCamlPro<\/a>";
//--></script></span>, <span class="rss-date">24 May 2013</span></span><span class="rss-description"><div id="post7"><h2> Doing the compiler's work</h2><p>Working at OCamlPro may have some drawbacks. I spend a lot of time hacking the OCaml compiler. Hence when I write some code, I have a good glimpse of what the generated assembly will look like. This is nice when I want to write performance sensitive code, but as I usually write code for which execution time doesn't matter much, this mainly tends to torture me. A small voice in my head is telling me "you shouldn't write it like that, you known you could avoid this allocation". And usually, following that indication would only tend to make the code less readable. But there is a solution to calm that voice: making the compiler smarter than me.</p><a onclick="switchContent('post7','post8')" class="btn" href="#49cce4c805c48bcf79a463c3fa2abe47">Read more...</a></div><div id="post8" style="display: none"><h2> Doing the compiler's work</h2><p>Working at OCamlPro may have some drawbacks. I spend a lot of time hacking the OCaml compiler. Hence when I write some code, I have a good glimpse of what the generated assembly will look like. This is nice when I want to write performance sensitive code, but as I usually write code for which execution time doesn't matter much, this mainly tends to torture me. A small voice in my head is telling me "you shouldn't write it like that, you known you could avoid this allocation". And usually, following that indication would only tend to make the code less readable. But there is a solution to calm that voice: making the compiler smarter than me.</p><p>OCaml compilation mechanisms are quite predictable. There is no dark magic to replace your ugly code by a well-behaving one, but it always generates reasonably efficient code. This is a good thing in general, as you won't be surprised by code running more slowly than what you usually expect. But it does not behave very well with dumb code. This may not often seem like a problem with code written by humans, but generated code, for example coming from camlp4/ppx, or compiled from another language to OCaml, may fall into that category. In fact, there is another common source for non-human written code: inlining.</p><h2> Inlining</h2><p>Inlining (or inline expansion) is a key optimisation in many compilers and particularly in functional languages. Inlining replaces a function call by the function body. Let's apply inlining to f in this example.</p><pre><code>let f x = x + 1 let g y = f (f y) </code></pre><p>We replace the calls to f by let for each arguments and then copy the body of f.</p><pre><code>let g y = let x1 = y in let r1 = x1 + 1 in let x2 = r1 in let r2 = x2 + 1 in r2 </code></pre><p>Inlining allows to eliminate the cost of a call (and associated spilling), but the main point is elsewhere: it puts the code in its context, allowing its specialisation. When you look at that generated code after inlining your trained eyes will notice that it looks quite dumb. And you really want to rewrite it as:</p><pre><code>let g y = y + 2 </code></pre><p>The problem is that OCaml is compiling smart code into smart assembly, but after inlining your code is not as smart as it used to be. What is missing in the current compiler is a way to get back a nice and smart code after inlining. (To be honest, OCaml is not that bad and on that example it would generate the right code: put this on the sake of the mandatory blog-post dramatic effect.)</p><p>In fact you could consider inlining as two separate things: duplication and call elimination. By duplication you make a new version of the function that is specialisable in its context, and by call elimination you replace the call by specialised code. This distinction is important because there are some cases where you only want to do duplication: recursive functions.</p><h3> Recursive function inlining</h3><p>In a recursive function duplicating and removing a call is similar to loop unrolling. This can be effective in some cases, but this is not what we want to do in general. Lets try it on <code>List.map</code></p><pre><code>let rec list_map f l = match l with | [] -&gt; [] | a::r -&gt; f a :: list_map f r let l' = let succ = (fun x -&gt; x + 1) in list_map succ l </code></pre><p>If we simply inline the body of list_map we obtain this</p><pre><code>let l' = let succ = (fun x -&gt; x + 1) in match l with | [] -&gt; [] | a::r -&gt; succ a :: list_map succ r </code></pre><p>And with some more inlining we get this which is probably not any faster than the original code.</p><pre><code>let l' = let succ = (fun x -&gt; x + 1) in match l with | [] -&gt; [] | a::r -&gt; a + 1 :: list_map succ r </code></pre><p>Instead we want the function to be duplicated.</p><pre><code>let l' = let succ = (fun x -&gt; x + 1) in let rec list_map' f l = match l with | [] -&gt; [] | a::r -&gt; f a :: list_map' f r in list_map' succ l </code></pre><p>Now we know that <code>list_map'</code> will never escape its context hence that its f parameter will always be succ. Hence we can replace <code>f</code> by succ everywhere in its body.</p><pre><code>let l' = let succ = (fun x -&gt; x + 1) in let rec list_map' f l = match l with | [] -&gt; [] | a::r -&gt; succ a :: list_map' succ r in list_map' succ l </code></pre><p>And we can now see that the <code>f</code> parameter is not used anymore, we can eliminate it.</p><pre><code>let l' = let succ = (fun x -&gt; x + 1) in let rec list_map' l = match l with | [] -&gt; [] | a::r -&gt; succ a :: list_map' r in list_map' l </code></pre><p>With some more inlining and cleaning we finally obtain this nicely specialised function which will be faster than the original.</p><pre><code>let l' = let rec list_map' l = match l with | [] -&gt; [] | a::r -&gt; a + 1 :: list_map' r in list_map' l </code></pre><h3> Current state of the OCaml inliner</h3><p>Inlining can gain a lot, but abusing it will increase code size a lot. This is not only a problem of binary size (who cares?): if your code does not fit in processor cache anymore, its speed will be limited by memory bandwidth.</p><p>To avoid that, OCaml has a threshold to the function size allowed for inlining. The compiler may also refuse to inline in other cases that are not completely justified though, mainly for reasons related to its architecture:</p><ul> <li> <p>duplication and call elimination are not separated, hence recursive function duplication is not possible.</p> </li><li> <p>functions containing structured constants or local functions are not allowed to be duplicated, preventing those functions to be inlined.</p> </li> </ul><pre><code>let constant x = let l = [1] in x::l let local_function x = let g x = some closed function in ... g x ... </code></pre><p>The assumption is that if a function contains a constant or a function it will be too big to be reasonably inlined. But there is a reasonable transformation that could allow it.</p><pre><code>let l = [1] let constant x = x::l let g x = some closed function let local_function x = ... g x ... </code></pre><p>and then we can reasonably inline <code>constant</code> and <code>local_function</code>. Those cases are only technical limitation that could easily be lifted with the new implementation.</p><p>But improving the OCaml inliner is not that easy. It is well written, but it is also doing a lot of other things at the same time:</p><h4> closure conversion</h4><p>closure conversion transforms functions to a data structure containing a code pointer and the free variables of the function. You could imagine it as that transformation:</p><pre><code>let a = 1 let f x = x + a (* a is a free variable in f *) let r = f 42 </code></pre><p>Here <code>a</code> is a free variable of <code>f</code>. We cannot compile <code>f</code> while it contains reference to free variables. To get rid of the free variables, we add a new parameter to the function, the environment, containing all the free variables.</p><pre><code>let a = 1 let f x environment = (* the new environment parameter contains all the free variables of f *) x + environment.a let f_closure = { code = f; environment = { a = a } } let r = f_closure.code 42 f_closure.environment </code></pre><h4> Value analysis</h4><p>In functional languages inlining is not as simple as it is for languages like C because the function name does not tells you which function is used at a call site:</p><pre><code>let f x = (x,(fun y -&gt; y+1)) let g x = let (a,h) = f x in h a </code></pre><p>To be able to inline h as (fun y -&gt; y+1) the compiler needs to track which values flows to variables. This is usually called a value analysis. This example can look a bit contrived, but in practice functor application generate quite similar code. This allows for instance to inline Set.Make(...).is_empty. The result of this value analysis is used by other optimisations:</p><h4> Constant folding</h4><p>When the value analysis can determine that the result of an operation is a constant, it can remove its computation:</p><pre><code>let f x = let a = 1 in let b = a + 1 in x + b </code></pre><p>Since <code>b</code> always have the value <code>2</code> and <code>a + 1</code> does not have side effects it is possible to simplify it.</p><pre><code>let f x = x + 2 </code></pre><h4> Direct call specialisation</h4><p>Sometimes it is impossible to know which function will be used at a call site:</p><pre><code>let f g x = g x </code></pre><p>There is a common representation (the closure) that allows to call a function without knowing anything about it. Using a function through its closure is called a generic call. This is efficient, but of course not as efficient as a simple assembly call (a direct call). The work of the direct call specialisation is to turn as many as possible generic call into direct ones. In practice, the vast majority of calls can be optimised.</p><h2> Improving OCaml inliner</h2><p>The current architecture is very fast and works well on a lot of cases, but it is quite difficult to improve the handling of corner cases.</p><p>I have started a complete rewrite of those passes, I am currently working on splitting all those things in their own passes. The first step was to add a new intermediate representation (flambda) more suited to doing the various analysis. The main difference with the current representation (clambda) is that closures are explicitly represented, making them easier to manipulate. As a nice side effect this intermediate representation allows to plug passes in or out, or loop on them without changing anything to the architecture. But we are losing the possibility to enforce some invariants in the type of the representation, hence we need to be careful to correctly maintain them.</p><p>With this new architecture, the closure conversion is done first (going from lambda to flambda). Then on flambda are provided a set of simple analysis:</p><ul> <li> <p>simple intraprocedural value and alias analysis</p> </li><li> <p>purity analysis</p> </li><li> <p>constant analysis</p> </li><li> <p>dead expression analysis</p> </li> </ul><p>And there is a set of simple passes using their results:</p><ul> <li> <p>dead code elimination</p> </li><li> <p>constant folding/direct call specialisation/type specialisation: a simple traversal replacing expressions with more efficient ones when the result of the value analysis allows it.</p> </li><li> <p>alias rebinding: Use results of alias analysis to know when a field access can be simplified:</p> </li> </ul><pre><code>let f x = let tuple = (x,x) in let (y,z) = tuple in y + z let f x = x + x </code></pre><p>Of course nobody would write that, but access to variables bounded in a closure can looks a lot like that after inlining:</p><pre><code>let f x = let g y = x + y in g x </code></pre><p>After closure conversion we obtain this.</p><pre><code>let f x = let g_closure = { code = fun x environment -&gt; environment.x + y; environment = { x = x } } in g_closure.code x g_closure.environment </code></pre><p>And after inlining <code>g</code>.</p><pre><code>let f x = let g_closure = { code = fun x environment -&gt; environment.x + y; environment = { x = x } } in x + closure.environment.x </code></pre><p>Inlining <code>g</code> makes some code that looks a bit stupid. <code>closure.environment.x</code> is always the same value as <code>x</code>. So there is no need to access it through the structure.</p><pre><code>let f x = let g_closure = { code = fun x environment -&gt; environment.x + y; environment = { x = x } } in x + x </code></pre><p>Now that we have simplified the code, we notice that g_closure is not used anymore, and dead code elimination can simply get rid of it.</p><pre><code>let f x = x + x </code></pre><ul> <li> <p>a really, really dumb inliner: it inlines almost anything. Its interest is to demonstrate what can be achieved when putting some code in its context.</p> </li> </ul><p>After the different optimisation passes we need to send the result to the compiler back-end. This is done by the final conversion from flambda to clambda, which is mainly doing a lot of bureaucratic transformations and mark constant structured values. Doing this constant marking separately also allows to improve a bit the generated code.</p><pre><code>let rec f x = let g y = f y in g x </code></pre><p><code>f</code> and <code>g</code> are closed functions but the current compiler will not be able to detect it and allocate a closure for g at each call of f.</p><h2> Hey ! Where are the nice charts ?</h2><p>As you noticed that there were no fancy improvements charts, and there won't be any below. Those are demonstrations passes, the generated code can (and probably will) be worse than the one generated by the current compiler. This is mainly done to show what can be achieved by combining simple passes and simple analysis and allowing to apply them multiple times. What is needed to get fast code is to change the inlining heuristic (and re-enable cross module inlining).</p><p>My current work is to write more serious analysis allowing better optimisations. In particular I expect that a reasonable interprocedural value analysis could help a lot with handling recursive function specialisation.</p><h2> My future toys</h2><p>Then I'd like to play a bit with other common things like</p><ul> <li> <p>unused parameters elimination: when a function does not use one of its parameters, remove it. This is trivial with simple functions, but it can get a bit tricky with multiply recursive functions. (that kind of code can appear after constant folding with informations from interprocedural analysis )</p> </li><li> <p>lambda lifting: turning closure into closed function by adding arguments. This can eliminate some allocations</p> </li> </ul><pre><code>let f x = let g y = x + y in g 4 </code></pre><p>If we add the <code>x</code> parameter to <code>g</code> we can avoid building its closure each time <code>f</code> is called.</p><pre><code>let f x = let g y x = x + y in g 4 x </code></pre><p>This can get quite tricky if we want to handle cases like</p><pre><code>let f x n = let g i = i + x in Array.init n g </code></pre><p>We need to add a new parameter to init also to be able to pass it to g.</p><ul> <li> <p>common sub-expression elimination:</p> </li> </ul><pre><code>let f x = let a = x + 1 in let b = x + 1 in a + b </code></pre><p>In <code>f</code> We clearly don't need to compute <code>x + 1</code> two times</p><pre><code>let f x = let a = x + 1 in a + a </code></pre><ul> <li> <p>earlier unboxing: Floats are boxed in ocaml, this means that there is an indirection when accessing the constant of a value of type float. To reduce the cost of allocating and accessing floats unboxing eliminates the indirections between some operations. I'd like to try to do this as a flambda pass to be able to use the results of the value analysis.</p> </li> </ul><p>If you want to play/hack a bit with the demo look at my <a href="https://github.com/chambart/ocaml/tree/flambda_experiments">github branch</a> (be warned, this branch may sometimes be rebased)</p><a onclick="switchContent('post8','post7')" class="btn" href="#49cce4c805c48bcf79a463c3fa2abe47">Hide</a></div></span>
<a name="03b68c1d54fc68dbfb32923fb309f984"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/dirvish-stats/"> dirvish-stats</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">25 May 2013</span></span><span class="rss-description">This program helps to compute some stats about dirvish vaults: - list vaults. - list images of a vault. - size of an image. - size of extra data between two images. - date of last image of a vault.</span>
<a name="9ca4013e6aed3d4f965269dbc57682c0"></a><span class="rss-header"><span class="rss-title"><a href="http://blog.bentobako.org/index.php?post/2013/05/26/Issues-with-distributions%2C-not-only-a-Debian-specific-problem"> Issues with distributions, not only a Debian specific problem</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">David Mentré</span>, <span class="rss-date">26 May 2013</span></span><span class="rss-description"><div id="post9"><p>Some time ago, <a href="http://blog.bentobako.org/index.php?post/2013/01/28/The-failures-of-Debian-%28and-its-derivatives%29">I blamed Debian for not looking enough at its users</a>. Apparently, I'm not the only one to make such remarks. <a href="https://plus.google.com/109922199462633401279/posts/HgdeFDfRzNe">Ingo Molnar, a famous Linux kernel developer working for Red Hat made similar remarks</a>. He even <a href="https://plus.google.com/109922199462633401279/posts/VSdDJnscewS">proposed some technical solutions</a>.</p> <p>Other solutions are already available. For example, for OCaml specific software, <a href="http://opam.ocamlpro.com/">OPAM, an OCaml specific package system, seems very interesting</a> to work around the freshness issue of OCaml Debian packages.</p> <p>I'm not sure Ingo's answers or OPAM are THE answers, but they at least open interesting perspectives. Handling of security and licensing issues are very difficult and not yet solved. Distributions are making an heavy work of integration that is currently not done by anybody else.</p> <a onclick="switchContent('post9','post10')" class="btn" href="#9ca4013e6aed3d4f965269dbc57682c0">Read more...</a></div><div id="post10" style="display: none"><p>Some time ago, <a href="http://blog.bentobako.org/index.php?post/2013/01/28/The-failures-of-Debian-%28and-its-derivatives%29">I blamed Debian for not looking enough at its users</a>. Apparently, I'm not the only one to make such remarks. <a href="https://plus.google.com/109922199462633401279/posts/HgdeFDfRzNe">Ingo Molnar, a famous Linux kernel developer working for Red Hat made similar remarks</a>. He even <a href="https://plus.google.com/109922199462633401279/posts/VSdDJnscewS">proposed some technical solutions</a>.</p> <p>Other solutions are already available. For example, for OCaml specific software, <a href="http://opam.ocamlpro.com/">OPAM, an OCaml specific package system, seems very interesting</a> to work around the freshness issue of OCaml Debian packages.</p> <p>I'm not sure Ingo's answers or OPAM are THE answers, but they at least open interesting perspectives. Handling of security and licensing issues are very difficult and not yet solved. Distributions are making an heavy work of integration that is currently not done by anybody else.</p> <p>It is nonetheless refreshing to see people thinking at those issues and proposing new solutions. I find Ingo's proposal of sandboxing, flat dependencing and not forcing people to upgrade very interesting. If you read French, you can also read this <a href="https://linuxfr.org/news/distribuer-sans-distributions">LinuxFR article that makes a small review of current proposals</a>.</p><a onclick="switchContent('post10','post9')" class="btn" href="#9ca4013e6aed3d4f965269dbc57682c0">Hide</a></div></span>
<a name="3b74babbbc976c1616a64a231c8ad729"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2013.05.28.html"> Caml Weekly News, 28 May 2013</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">28 May 2013</span></span><span class="rss-description">French study on security and functional languages / OPAM: installing batteries pa_strings. / Other Caml News</span>
<script type="text/javascript">function switchContent(id1,id2) {
     // Get the DOM reference
     var contentId1 = document.getElementById(id1);
     var contentId2 = document.getElementById(id2);
     // Toggle
     contentId1.style.display = "none";
     contentId2.style.display = "block";
     }</script></div>

  
    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>

    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-37808023-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

    </script>

</body></html>
