<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: OCaml Planet</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contrinutors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="OCaml Planet" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it in your browser</a></li>
    <li><a href="../taste.html">A Hundred Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who is using it?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development tools</a></li>
    <li><a href="../documentation.html">Manuals and Cheat Sheets</a></li>
    <li><a href="../tutorials/#advanced">Advanced tutorials &amp; Papers</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">Github</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing lists</a></li>
    <li><a href="../planet/">OCaml Planet (blogs)</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml-lang.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>OCaml Planet
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

    <h1>OCaml Planet</h1>

    <p>The OCaml Planet aggregates various blogs from the OCaml
    community.  It is kindly provided
    by <a href="http://www.ocamlcore.com/">OCamlCore</a>.  If you
    would like to be added, read
    the <a href="http://www.ocamlcore.org/planet/">Planet
    subscription HOWTO</a>.</p>

    <br/>
    <div style="float: right; margin-right: 0; margin-top: 0" class="span2 planet-subscriptions"><em>Subscriptions</em>
      <ul><li><a href="http://alexleighton.tumblr.com/tagged/ocaml/rss">Alex Leighton</a></li><li><a href="http://blog.mestan.fr/feed/?cat=16">Alp Mestan</a></li><li><a href="http://andreiformiga.com/blog/?cat=5&feed=rss2">Andrei Formiga</a></li><li><a href="http://math.andrej.com/feed/">Andrej Bauer</a></li><li><a href="http://anil.recoil.org/feeds/atom.xml">Anil Madhavapeddy</a></li><li><a href="http://unnali.com/tag/ocaml/feed/">Arlen Cuss</a></li><li><a href="http://ashishagarwal.org/tag/ocaml/feed/">Ashish Agarwal</a></li><li><a href="http://www.blogger.com/feeds/7617521785419311079/posts/default">Cameleon news</a></li><li><a href="http://caml.inria.fr/news.en.rss">Caml INRIA</a></li><li><a href="http://camlspotter.blogspot.com/feeds/posts/default?alt=rss">Caml Spotting</a></li><li><a href="http://alan.petitepomme.net/cwn/cwn.rss">Caml Weekly News</a></li><li><a href="http://procrastiblog.com/category/ocaml/feed/">Christopher Conway</a></li><li><a href="http://coherentpdf.com/blog/?tag=ocaml&feed=rss">Coherent Graphics</a></li><li><a href="http://coq.inria.fr/news/feed">Coq</a></li><li><a href="http://erratique.ch/feeds/news.atom">Daniel Bünzli</a></li><li><a href="http://blog.dbpatterson.com/rss">Daniel Patterson</a></li><li><a href="http://nleyten.com/atom.aspx">Dario Teixeira</a></li><li><a href="http://www.blogger.com/feeds/17133288/posts/default/-/ocaml">David Baelde</a></li><li><a href="http://bentobako.org/david/blog/index.php?feed/tag/ocaml/atom">David Mentré</a></li><li><a href="http://dutherenverseauborddelatable.wordpress.com/category/ocaml/feed/">David Teller</a></li><li><a href="http://www.examachine.net/blog/?feed=rss2&cat=4">Eray Özkural</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/CodeHacking/Ocaml/index.rss20">Erik de Castro Lopo</a></li><li><a href="http://blog.emillon.org/feeds/ocaml.xml">Etienne Millon</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/FP-Syd/index.rss20">FP-Sydney</a></li><li><a href="http://www.blogger.com/feeds/8964007124326996693/posts/default/-/ocaml">Fayssal Martani</a></li><li><a href="http://frama-c.com/rss.xml">Frama-C</a></li><li><a href="http://functionaljobs.com/jobs/search/?q=ocaml&format=rss">Functional Jobs</a></li><li><a href="http://gallium.inria.fr/~scherer/gagallium/index.rss">GaGallium</a></li><li><a href="http://gaiustech.wordpress.com/category/ocaml/feed/">Gaius Hammond</a></li><li><a href="http://blog.camlcity.org/blog/rss">Gerd Stolpmann</a></li><li><a href="http://www.wisdomandwonder.com/tag/OCaml/feed">Grant Rettke</a></li><li><a href="http://blog.incubaid.com/tag/ocaml/feed/">Incubaid Research</a></li><li><a href="http://ambassadortothecomputers.blogspot.com/feeds/posts/default?alt=rss">Jake Donham</a></li><li><a href="http://scattered-thoughts.net/rss?tag=ocaml">Jamie Brandon</a></li><li><a href="http://ocaml.janestcapital.com/?q=rss.xml">Jane Street</a></li><li><a href="http://www.lexifi.com/blogs/ocaml/feed">LexiFi</a></li><li><a href="http://savonet.sourceforge.net/liquidsoap.rss">Liquidsoap</a></li><li><a href="http://syntaxexclamation.wordpress.com/tag/ocaml/feed/">Matthias Puech</a></li><li><a href="http://www.blogger.com/feeds/5888658295182480819/posts/default">Matías Giovannini</a></li><li><a href="http://eigenclass.org/R2/feeds/rss2/all">Mauricio Fernandez</a></li><li><a href="http://www.elehack.net/michael/blog/tags/ocaml?format=rss">Michael Ekstrand</a></li><li><a href="http://www.rktmb.org:82/feed/category/work/ocaml/atom">Mihamina Rakotomandimby</a></li><li><a href="http://nyc-ocaml.posterous.com/rss.xml">NYC OCaml</a></li><li><a href="http://ocamlhackers.ning.com/profiles/blog/feed?tag=ocaml&xn_auth=no">OCaml Hackers</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfnews.php">OCamlCore Forge News</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfprojects.php">OCamlCore Forge Projects</a></li><li><a href="http://www.ocamlcore.com/wp/?feed=rss2&amp;language=en&#038;language=en">OCamlCore.com</a></li><li><a href="http://www.ocamlpro.com/feed/atom.xml">OCamlPro</a></li><li><a href="http://odns.tuxfamily.org/feed/">ODNS project</a></li><li><a href="http://ox.tuxfamily.org/feed/">Ocaml XMPP project</a></li><li><a href="http://ocsigen.org/news.atom">Ocsigen project</a></li><li><a href="http://www.blogger.com/feeds/2073503406800427577/posts/default">Opa</a></li><li><a href="http://www.openmirage.org/blog/atom.xml">Open Mirage</a></li><li><a href="http://www.donadeo.net/facets/programming-languages/objective-caml/feed/">Paolo Donadeo</a></li><li><a href="https://mancoosi.org/~abate/taxonomy/term/5/0/feed">Pietro Abate</a></li><li><a href="http://redlizards.com/blog/feed/?tag=ocaml">Red Lizard Software</a></li><li><a href="http://rwmj.wordpress.com/tag/ocaml/feed/">Richard Jones</a></li><li><a href="http://blog.rastageeks.org/spip.php?page=rss&id_mot=2">Romain Beauxis</a></li><li><a href="http://seb.mondet.org/blog/feed/ocaml.rss">Sebastien Mondet</a></li><li><a href="http://upsilon.cc/~zack/tags/ocaml/index.rss">Stefano Zacchiroli</a></li><li><a href="http://le-gall.net/sylvain+violaine/blog/index.php?feed/tag/ocaml/atom">Sylvain Le Gall</a></li><li><a href="http://caml.inria.fr/hump.rss">The Caml Humps</a></li><li><a href="http://www.blogger.com/feeds/6115529230232389198/posts/default">Till Varoquaux</a></li><li><a href="http://www.nicollet.net/toroidal/ocaml/feed/">Victor Nicollet</a></li><li><a href="http://y-node.com/blog/feeds/tag/ocaml/">y-node</a></li></ul>

      <a href="http://planet.ocaml.org/rss20.xml"><img src=".././img/rss20.png"/></a>
      <a href="http://planet.ocaml.org/opml.xml"><img src=".././img/opml.png"/></a>
    </div>
    <div class="planet"><a name="e672efd955ba77a031ef9e8392474060"></a><span class="rss-header"><span class="rss-title"><a href="http://math.andrej.com/2012/12/25/free-variables-are-not-implicitly-universally-quantified/"> Free variables are not “implicitly universally quantified”!</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Andrej Bauer</span>, <span class="rss-date">25 Dec 2012</span></span><span class="rss-description"><div id="post1"><p>Mathematicians are often confused about the meaning of variables. I hear them say “a free variable is implicitly universally quantified”, by which they mean that it is ok to equate a formula $\phi$ with a free variable $x$ with its universal closure $\forall x \,.\, \phi$. I am addressing this post to those who share this opinion.</p>
<p><span id="more-1387"></span></p>
<p>I will give several reasons, which are all essentially the same, why “there is no difference between $\phi$ and $\forall x \,.\, \phi$” is a really bad opinion to have.</p>
<h3>Reason 1: you wouldn’t equate a function with its definite integral</h3>
<p>You would not claim that a real-valued function $f : \mathbb{R} \to \mathbb{R}$ is “the same thing” as its definite integral $\int_{\mathbb{R}} f(x) \, d x$, would you? One is a real function, the other is a real number. Likewise, $\phi$ is a truth &lt;emph&gt;function&lt;/emph&gt; and $\forall x \,.\, \phi(x)$ is a truth &lt;emph&gt;value&lt;/emph&gt;.</p>
<h3>Reason 2: functions are not their own values</h3>
<a onclick="switchContent('post1','post2')" class="btn" href="#e672efd955ba77a031ef9e8392474060">Read more...</a></div><div id="post2" style="display: none"><p>Mathematicians are often confused about the meaning of variables. I hear them say “a free variable is implicitly universally quantified”, by which they mean that it is ok to equate a formula $\phi$ with a free variable $x$ with its universal closure $\forall x \,.\, \phi$. I am addressing this post to those who share this opinion.</p>
<p><span id="more-1387"></span></p>
<p>I will give several reasons, which are all essentially the same, why “there is no difference between $\phi$ and $\forall x \,.\, \phi$” is a really bad opinion to have.</p>
<h3>Reason 1: you wouldn’t equate a function with its definite integral</h3>
<p>You would not claim that a real-valued function $f : \mathbb{R} \to \mathbb{R}$ is “the same thing” as its definite integral $\int_{\mathbb{R}} f(x) \, d x$, would you? One is a real function, the other is a real number. Likewise, $\phi$ is a truth &lt;emph&gt;function&lt;/emph&gt; and $\forall x \,.\, \phi(x)$ is a truth &lt;emph&gt;value&lt;/emph&gt;.</p>
<h3>Reason 2: functions are not their own values</h3>
<p>To be quite precise, the expression $\phi$ by itself is not a function, just like the expression $x + \sin x$ is not a function. To make it into a function we must first &lt;emph&gt;abstract&lt;/emph&gt; the variable $x$, which is usually written as $x \mapsto x + \sin x$, or $\lambda x \,.\, x + \sin x$, or <code>fun x -&gt; x +. sin x</code>. In logic we indicate the fact that $\phi$ is a function by putting it in a &lt;emph&gt;context&lt;/emph&gt;, so we write something like $x : \mathbb{R} \vdash \phi$.</p>
<p>Why is all this nit-picking necessary? Try answering these questions with “yes” and “no” consistently:</p>
<ol>
<li>Is $x + \sin x$ a function in variable $x$?</li>
<li>Is $x + \sin x$ a function in variables $x$ and $y$?</li>
<li>Is $y – y + x + \sin x$ a function in variables $x$ and $y$?</li>
<li>Is $x + \sin x = y – y + x + \sin x$?</li>
</ol>
<p>A similar sort of mistake happens in algebra where people think that polynomials are functions. They are not. They are elements of a certain freely generated ring.</p>
<h3>Reason 3: They are not logically equivalent</h3>
<p>It is absurd to claim that $\phi$ and $\forall x \in \mathbb{R} \,.\, \phi$ are logically equivalent statements. Suppose $\forall x \in \mathbb{R} \,.\, x &gt; 2$ were equivalent to $x &gt; 2$. Then I could replace one by the other in any formula I wish. So I choose the formula $\exists x \in \mathbb{R} \,.\, x &gt; 2$. It must be equivalent to $\exists x \in \mathbb{R} \,.\, \forall x \in \mathbb{R} \,.\, x &gt; 2$, but since $\forall x \in \mathbb{R} \,.\, x &gt; 2$ is false, we get $\exists x \in \mathbb{R} \,.\, \bot$, which is false. We proved that there is no number larger than 2.</p>
<h3>Reason 4: They are not inter-derivable</h3>
<p>If you can tell the difference between an implication and logical entailment, perhaps you might try to counter reason 3 by pointing out that $\phi$ and $\forall x \,.\, \phi$ are either both derivable, or both not derivable. That is to say, we can prove one if, and only if, we can prove the other. But again, this is not the case. We can prove $\forall x \in \emptyset \,.\, \bot$ but we cannot prove $\bot$.</p>
<h3>Reason 5: Bound variables can be renamed but free variables cannot</h3>
<p>The formula $x &gt; 2$ is obviously not the same thing as the formula $y &gt; 2$. But the formula $\forall x \in \mathbb{R} . x &gt; 2$ is actually the same as $\forall y \in \mathbb{R} . y &gt; 2$. If you find this confusing it is because you were never taught properly how to handle <a href="http://en.wikipedia.org/wiki/Free_variables_and_bound_variables">free and bound variables</a>.</p>
<h3>Reason 6: You cannot prove $\forall x \,.\, \phi$ without allowing $x$ to become free</h3>
<p>Perhaps we can just forbid free variables altogether and &lt;emph&gt;stipulate&lt;/emph&gt; that all variables must always be quantified. But how are you then going to prove $\forall x \in \mathbb{R} \,.\, \phi$? The usual way</p>
<blockquote><p>
“Consider any $x \in \mathbb{R}$. Then bla bla bla, therefore $\phi$.”
</p></blockquote>
<p>is now forbidden because the first sentence introduces $x$ as a free variable.</p>
<p>We can abolish variables altogether if we wish, by resorting to combinators, but it makes no sense to keep variables and make them all bound all the time.</p>
<h3>Epilogue: so in what sense are they the same?</h3>
<p>There is a theorem in model theory:</p>
<blockquote><p>
Let $\phi$ be a formula in context $x_1, \ldots, x_n$ and $M$ a structure in which we can interpret $\phi$. The following are equivalent:</p>
<ol>
<li>the universal closure $\forall x_1, \ldots, x_n \,.\, \phi$ is valid in $M$,</li>
<li>for every valuation $\nu : \lbrace x_1, \ldots, x_n \rbrace \to M$, $\phi[\nu]$ is valid in $M$.</li>
</ol>
</blockquote>
<p>This is sometimes abbreviated (quite inaccurately) as “a formula and its universal closure are semantically equivalent”. This theorem is causing a lot of harm because mathematicians interpret it as “free variables are implicitly universally bound”. But the theorem itself clearly distinguishes a formula from its universal closure. It has a limited range of applications in model theory. It is not a general reasoning principle that would allow you to dispose of thinking about free variables.</p>
<p>You are in good company. Philosophers have thought about free variables for millennia, although they phrase the problem in the language of <a href="http://en.wikipedia.org/wiki/Universal_(metaphysics)">universals</a> and <a href="http://en.wikipedia.org/wiki/Particular">particulars</a>. They wonder whether “dog” is the same thing as the set of all dogs, or perhaps there is an ideal dog which is “pure dogness”, but then do we need two ideal dogs to make ideal pups, etc. The answer is simple: a free variable is a projection from a cartesian product.</p><a onclick="switchContent('post2','post1')" class="btn" href="#e672efd955ba77a031ef9e8392474060">Hide</a></div></span>
<a name="2f9fc6a8ae811c870e3859f2689319a7"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/tptp/"> tptp</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">21 Dec 2012</span></span><span class="rss-description">Library for parsing FOF and CNF formulas from TPTP format. Depends on: zarith.</span>
<a name="7848ce5e403469fa5a3757e71a0f8191"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=817"> Xtmpl 0.5</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">19 Dec 2012</span></span><span class="rss-description">Xtmpl is a small XML templating library for OCaml.</span>
<a name="7ff089ca4b443c810138d4a7c8e8b486"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=818"> Stog 0.5</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">19 Dec 2012</span></span><span class="rss-description">Stog is a kind of Jekyll in OCaml: It is a static web site generator, able to handle blog posts as well as regular pages.</span>
<a name="3aeebe7a5873af158331e6566e6c7b25"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/cryptodbm/"> Cryptodbm: Encrypted dbm</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">18 Dec 2012</span></span><span class="rss-description">Library for creating and reading encrypted databases (serverless, encrypted key-value databases).</span>
<a name="ebe2a7c57571bc1eb87b0df1ac92c1c5"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2012.12.18.html"> Caml Weekly News, 18 Dec 2012</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">18 Dec 2012</span></span><span class="rss-description">new OPAM command-line interface / RTT (Run-time types) online toplevel for trying / Other Caml News</span>
<a name="cbef3ca3cfb05f18395bdae71d4ad36b"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/~scherer/gagallium/we-need-a-representative-benchmark-suite"> OCaml compiler optimizations: we need a representative benchmark suite</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">18 Dec 2012</span></span><span class="rss-description"><div id="post3"><p>This is a call to arms: to improve the OCaml compiler, we
sorely need a suite of representative benchmarks. If you have ever
written performance-sensitive programs in OCaml, you can
contribute.</p>




<p>PS: When I originally started to write this blog post, it was about
a small experiment on optimizing a small program for float
unboxing. Writing a general introduction on the few joys and numerous
pitfalls of compiler optimizations suddenly turned it into a totally
different post. Oh well.</p>

<h2>Having a simple compiler is a valid design choice</h2>

<p>The OCaml native compiler is well-known for its simple and robust
behavior. Thanks to efficient choices of value representation and
a sophisticated garbage collector (GC), it is able to make good OCaml
programs run fast. But it doesn't actually optimize in clever way:
efficient code will give an efficient program, but little is done to
make inefficient code efficient.</p>

<a onclick="switchContent('post3','post4')" class="btn" href="#cbef3ca3cfb05f18395bdae71d4ad36b">Read more...</a></div><div id="post4" style="display: none"><p>This is a call to arms: to improve the OCaml compiler, we
sorely need a suite of representative benchmarks. If you have ever
written performance-sensitive programs in OCaml, you can
contribute.</p>




<p>PS: When I originally started to write this blog post, it was about
a small experiment on optimizing a small program for float
unboxing. Writing a general introduction on the few joys and numerous
pitfalls of compiler optimizations suddenly turned it into a totally
different post. Oh well.</p>

<h2>Having a simple compiler is a valid design choice</h2>

<p>The OCaml native compiler is well-known for its simple and robust
behavior. Thanks to efficient choices of value representation and
a sophisticated garbage collector (GC), it is able to make good OCaml
programs run fast. But it doesn't actually optimize in clever way:
efficient code will give an efficient program, but little is done to
make inefficient code efficient.</p>

<p>This approach has some nice advantages. On the user side, it makes for
a predictable compiler (no hope of the killer optimization kicking in
when it actually doesn't due to a small change). On the developer
side we have a well-written and rather simple post-frontend that is
easy to understand and maintain. Compilation times are also usually
very small: with the additional good support for separate compilation,
compilation times is rarely a problem in OCaml as it can be in some
other compiled languages (<em>cough</em> C++ <em>cough</em>).</p>

<p>Yet this also comes with drawbacks. For example, "inefficient" code is
rarely written by OCaml programmers (smart men and women), of
course :), but is easy to obtain when you're doing automatic code
generation; you may have to be a bit careful if you produce OCaml
programs to not spit out stupid code, while a general whole-program
optimizer could have taken care of this for you.</p>

<p>Another problem is that some abstractions are more costly that we
would like them to be. It's hard to write monadic code, for example,
without generating a lot of (often unnecessary) closures. While the
cost of the additional closure allocations and function calls are
often drowned by the overall monadic logic (for example thread
scheduling in monadic cooperative threading libraries such as Lwt and
Async), fine-grained monad style can still have a sensible overhead.</p>

<p>For example, Arnaud Spiwak
<a href="https://sympa.inria.fr/sympa/arc/coq-club/2012-10/msg00013.html">reported</a>
that switching the Coq internal tactics to a pervasive monadic style
incurred sensible overhead (~15% slowdown on the whole Coq archive,
with some individual tactics getting several times slower). Using
Coq's inlining engine to maximally reduce monadic closures, he was
able to get a 10% performance gain over what "idiomatic monadic OCaml
code" produces through the OCaml compiler. (Remark that inlining is
easier to do in Coq thanks to a pure (including total) programming
language with sensible strong reduction semantics.)</p>

<p>Finally, not every programming style and application domain is equal
in the face of OCaml compilation choices. Memory allocation, tail
calls, exceptions and pattern matching on algebraic datatypes are
extremely fast, and code using lot of them (typically: a compiler,
a proof assistant, symbolic computations in general) will have you
extremely satisfied. But this sometimes required compromises that have
downsides for other language features, and the sophistication effort
that went there didn't necessarily find itself reproduced in other
parts of the language features that were of less interest at the time
of the compiler's inception.</p>

<p>As a concrete example, OCaml does not shine at number crunching: its
integers are tagged to make the GC life easier, and its
(double-precision) floating points are boxed to keep a uniform value
representation. The compiler is well aware of these facts and tries to
suppress this overhead when it is easy to do so, but those
optimization are relatively simple and have room for improvement.</p>

<p>This doesn't mean that OCaml should not be used when a problem domain
involves some number crunching: the benefit you can gain from
expressive language features and a reasonable type system may very
well outweigh, in terms of productivity and final code efficiency, the
approximate halving of performance (when compared to C) on numeric
benchmarks. A large number of people pay a sensibly higher performance
price to use less-efficient language everyday, for example Javascript
(even on today's highly-optimized runtimes, that took exponentially
more effort to develop than the OCaml native compiler).</p>

<h2>Compiler optimization is an ungrateful business</h2>

<p>Just above I've mentioned a few fronts (function inlining, local
unboxing or untagging) on which the OCaml compiler could possibly help
with more aggressive optimizations. There are other specific areas
where compilation choices could be improved. The problem with compiler
optimizations is that there is a large disconnect between what we,
compiler programmers and language geeks, find satisfying to work on,
and the hard reality of actual program performances.</p>

<p>It is easy to spend some months implementing and debugging, say,
a state-of-the-art register allocator, only to find out that it makes
practically no performance difference on the programs you have at
hand. Why then would the maintainer accept a large code change that
certainly introduces bug and doesn't provably improves over the naive
but simple and debugged-by-time current implementation?</p>

<p>If advertising for a change in a compiler with the argument that "the
generated code is much nicer", you're doing it wrong. It is
surprisingly often the case that while the generated code looks much
nicer to the naked eye, it is not actually faster on today's
overly-complicated processors. More importantly, it is generally the
case that said nicer code never actually appears in the hot section of
your program, and therefore produces no observable performance
change. Again, "if it ain't broke, don't fix it", it would be
unreasonable to accept a change that cannot demonstrate a real
improvement on a real program -- while it's generally easy to craft
micro-benchmark that demonstrate impressive improvements.</p>

<p>I have personally experienced this problem in <a href="http://caml.inria.fr/mantis/view.php?id=4800">the work on
PR#4800</a>. Currently,
OCaml optimizes tupled assignments such as <code>let (x,y,z) = (foo, bar, baz)</code>
to remove the tuple construction and destruction that would
happen per the naive pattern-matching semantics. However this only
works if the right-hand-side is syntactically a tuple, and would fail
for example on <code>let (x,y) = if foo then (bar, baz) else (foobar, foobaz)</code>.</p>

<p>Alain Frisch proposed a patch to optimize this (and some other)
situation, to make this multi-binding style more convenient to
use. I've spent some time reviewing the patch and proposing an
alternative implementation, but we've both been unable to find an
actual real-world example where adding this optimization made
a significant difference.</p>

<p>This is a delicate point because those optimizations are here to make
new abstractions available that were previously avoided. If we don't
observe any difference, maybe it is because OCaml programmers have
avoided that idiom so far, but would make convenient use of it if it
was cost-free. However, if we can't demonstrate a real example where
this optimization is important, it's probably not a good idea to
include it upstream.</p>

<h2>We really need a benchmark suite, and you can help</h2>

<p>What we really need is a benchmark suite that would contain
representative examples of real-world OCaml code. There is a handful
of benchmarks distributed with the compiler but they don't cover
much. Likewise, the programs in <a href="http://benchmarksgame.alioth.debian.org/u64q/ocaml.php">the
Shootout</a> are
too small to be representative of actual uses of OCaml.</p>

<p>This is why we currently use "big software" in OCaml to evaluate
performance changes (eg. bootstrap the OCaml compiler itself, or
compile Coq). Some big OCaml users have internal performance
testsuites (for example Pascal Cuoq, which works on Frama-C,
infrequently contributes performance-improving changes to the
OCaml compiler), but we severely lack an easily-available, informative
benchmark suite to evaluate performance changes.</p>

<p>This is a losing situation because optimization-related changes cannot
be reliably assessed in absence of representative code, and specific
problem domains that we can't measure against will not be improved.</p>

<p>The good thing with benchmark needs is that it's a problem the
community at large can efficiently solve in parallel. If everyone
contributed a piece of code that comes from real-world OCaml software
and is representative of its performance-critical part, we would have
a complete benchmark suite by now.</p>

<p>Feel free to <strong>contribute</strong> by providing, either here in the blog
comments or by mail (gabriel dot scherer at inria, or at gmail), your
benchmark program(s). Code that has few external dependencies and that
comes with a simple interface to parametrize running time is highly
preferred. Of course, an open source license is required (say MIT/BSD
or LGPL with linking exception).</p>

<p>What is a representative benchmark? A benchmark is representative when
performance changes observed in the benchmark will reliably be
reproducible against (some use cases of) the whole software it was
extracted or inspired from. The changes must be comparable in
magnitude: if a 80% performance change (improvement or degradation) in
the benchmark code results in a 0.5% performance change in the actual
software, it's difficult to rely on benchmark results to make design
compromises.</p><a onclick="switchContent('post4','post3')" class="btn" href="#cbef3ca3cfb05f18395bdae71d4ad36b">Hide</a></div></span>
<a name="a0653bd809a506d026a0c34a935de78d"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2012.12.11.html"> Caml Weekly News, 11 Dec 2012</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">11 Dec 2012</span></span><span class="rss-description">otags reloaded 4.00.1 for OCaml 4.00 / ocaml.org infrastructure list available / Js_of_ocaml 1.3 / GODI imports OASIS / Documenting the compiler / Ocsigen: Eliom 3 / Creating fresh OPAM repository / Other Caml News</span>
<a name="621e599503238029afb486f7f9bfd0b7"></a><span class="rss-header"><span class="rss-title"><a href="http://ocsigen.org/"> Ocsigen Eliom 3.0 released</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Ocsigen project</span>, <span class="rss-date">10 Dec 2012</span></span><span class="rss-description"><div id="post5"><p>
we are celebrating Ada's birthday by bringing out a major update of
Eliom - the advanced framework for client/server web applications in
OCaml - and some minor updates for Ocsigenserver and Tyxml.
</p>
<p>
Here is a list of major new features (and short code snippets can be
found at the end of this email):
</p>

<ul>
<li>The tightest integration of client value within the server code
   ever made possible in a major statically typed programming
   language [1]
   </li><li>
 Easy access to top-level server values - and (Lwt-)functions -
   from within the client code [2]
   </li><li>
 Access to other users' states of Eliom references
   </li><li>
 Improved support of Eliom's source files in the compilation tools
   eliom{c,opt,dep}
   </li><li>
 A new tool, eliom-destillery, for creating basic projects fast &amp;
   easy
 </li>
</ul>

<p>
The manual, a cheat-sheet, a comprehensive tutorial, and the
API-documentation of the various Ocsigen projects are available on
<a href="http://ocsigen.org">http://ocsigen.org</a>.
</p>
<a onclick="switchContent('post5','post6')" class="btn" href="#621e599503238029afb486f7f9bfd0b7">Read more...</a></div><div id="post6" style="display: none"><p>
we are celebrating Ada's birthday by bringing out a major update of
Eliom - the advanced framework for client/server web applications in
OCaml - and some minor updates for Ocsigenserver and Tyxml.
</p>
<p>
Here is a list of major new features (and short code snippets can be
found at the end of this email):
</p>

<ul>
<li>The tightest integration of client value within the server code
   ever made possible in a major statically typed programming
   language [1]
   </li><li>
 Easy access to top-level server values - and (Lwt-)functions -
   from within the client code [2]
   </li><li>
 Access to other users' states of Eliom references
   </li><li>
 Improved support of Eliom's source files in the compilation tools
   eliom{c,opt,dep}
   </li><li>
 A new tool, eliom-destillery, for creating basic projects fast &amp;
   easy
 </li>
</ul>

<p>
The manual, a cheat-sheet, a comprehensive tutorial, and the
API-documentation of the various Ocsigen projects are available on
<a href="http://ocsigen.org">http://ocsigen.org</a>.
</p>
<p>
The probably simplest and most generic way to install Eliom is by
using OPAM. But also Debian packages are already available (in
experimental, thanks Stéphane!), Gentoo-ebuilds are on their way, the
Ocsigen-bundle is still at hand, and the archives can be found at
<a href="http://ocsigen.org/eliom/install">http://ocsigen.org/eliom/install</a>.
</p>
<p>
And maybe you may want to become social with us on
</p>
<ul>
<li>
<a href="https://twitter.com/ocsigen">Twitter</a>
</li>
<li>
<a href="https://plus.google.com/u/0/105890612060116987398/posts">Google +</a>
</li>
<li>
<a href="https://www.facebook.com/pages/Ocsigen/289974521051526">Facebook</a>
</li>
</ul>

<p>
Enjoy!
</p>
<p>
-- The Ocsigen-team
</p>

<pre>[1]
{server{ (* This marks server-side code *)
  let value_history_on_client =
    {ref string{ ref [] }} (* A client value within the server code *)
  let _ = My_app.register_service ~path ~get_params
    (fun value () -&gt;
      (* Push the GET parameter to the client's history a side effect *)
      ignore {unit{
        %value_history_on_client := %value :: ! %value_history_on_client
      }};
      Lwt.return html)
}}

[2]
{server{
  let f = server_function Json.t&lt;string&gt;
    (fun x -&gt; Printf.eprintf "Client says: %s\n%!" x; Lwt.return ())
}}
{client{ (* This marks client-side code *)
  (* %f makes the server's value f, a client-ready server function,
     available in the client code *)
  ... %f "hello!" ...
}}
</pre><a onclick="switchContent('post6','post5')" class="btn" href="#621e599503238029afb486f7f9bfd0b7">Hide</a></div></span>
<a name="e93970411baf98fb039a1ccbbf0b5954"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/~scherer/gagallium/verifying-a-parser-for-a-c-compiler-2"> Verifying a parser for a C compiler (continued)</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">07 Dec 2012</span></span><span class="rss-description"><div id="post7"><p>In
  my <a href="http://gallium.inria.fr/~scherer/gagallium/verifying-a-parser-for-a-c-compiler/">last
  post</a>, I explained my work on verifying a parser for
  Compcert. I was mainly explaining the solutions I found to my
  performances problems. Here, I will discuss an other interesting
  problem I have, concerning the context sensitivity of the C99
  grammar.</p>



<h2>An alternative to the lexer hack</h2>

<p>The &lt;emph&gt;lexer hack&lt;/emph&gt; is the typical solution to the problem
  of context sensitivity of the C grammar outlined in
  the <a href="http://gallium.inria.fr/~scherer/gagallium/verifying-a-parser-for-a-c-compiler/">previous
  blog article</a> and explained more in depth
  in <a href="http://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-c%E2%80%99s-grammar-revisited/">this
  external blog article</a>. It cannot be implemented in our parser,
  because it uses some side effect in the semantic actions of the
  grammar in order to give some information to the lexer, and, as you
  might know, side effects are forbidden in Coq.</p>

<a onclick="switchContent('post7','post8')" class="btn" href="#e93970411baf98fb039a1ccbbf0b5954">Read more...</a></div><div id="post8" style="display: none"><p>In
  my <a href="http://gallium.inria.fr/~scherer/gagallium/verifying-a-parser-for-a-c-compiler/">last
  post</a>, I explained my work on verifying a parser for
  Compcert. I was mainly explaining the solutions I found to my
  performances problems. Here, I will discuss an other interesting
  problem I have, concerning the context sensitivity of the C99
  grammar.</p>



<h2>An alternative to the lexer hack</h2>

<p>The &lt;emph&gt;lexer hack&lt;/emph&gt; is the typical solution to the problem
  of context sensitivity of the C grammar outlined in
  the <a href="http://gallium.inria.fr/~scherer/gagallium/verifying-a-parser-for-a-c-compiler/">previous
  blog article</a> and explained more in depth
  in <a href="http://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-c%E2%80%99s-grammar-revisited/">this
  external blog article</a>. It cannot be implemented in our parser,
  because it uses some side effect in the semantic actions of the
  grammar in order to give some information to the lexer, and, as you
  might know, side effects are forbidden in Coq.</p>

<p>Any Haskell programmer would say that the solution is to use a
  state monad, but both the semantic actions described in the grammar
  and the lexer would need to compute in this monad, in order to
  communicate with each other. Then, it becomes very hard to specify
  what is a valid semantic value for a token sequence, because one has
  to specify how the lexer and the parser semantic actions
  interleaves. This becomes a real nightmare when you allow the parser
  to ask the lexer for a lookahead token before deciding to call some
  semantic action...</p>

<p>So it is necessary to find another approach. After some thoughts,
  I remembered the parsing approach of &lt;emph&gt;mixfix operators&lt;/emph&gt;
  in the Agda programming language, advertized in Gallium by our own
  Agda expert <a href="http://nicolaspouillard.fr/">Nicolas
  Pouillard</a>. Mixfix operators are syntactic constructions that can
  be created dynamically: this is comparable to
  the <code>Notation</code> command of Coq. The way they are handled
  in Agda is described
  in <a href="http://www.cse.chalmers.se/~nad/publications/danielsson-norell-mixfix.pdf">this
  paper</a>. Roughly, the parser only analyzes the main structure of
  the file. The expressions are not analyzed at this point: they are
  left at the state of list of tokens. At a later stage of processing,
  an other module uses the extra context information it knows (notably
  the mixfix operators available) to parse expressions. This new
  information is obtained from the first parsing phase, which brings
  enough structure to go on.</p>

<p>Here, the situation is very similar: we need some more context
  information (whether a given identifier is a type or a variable
  name) in order to parse expressions and declarations. We can use a
  similar technique: if the parser is not able to parse those,
  then it should store them as a list of tokens in the abstract syntax
  tree. A second pass in then necessary to parse those "chunks"
  correctly. Recursively, this second pass can delay parsing for
  smaller chunks, and so on.</p>

<p>Obviously, I have omitted some details here. First, it requires
  some serious engineering on the C99 grammar in order to separate it
  into a "safe" part, where the extra information given by the context
  is not needed, and a "dangerous" part, where the parser needs that
  the two different flavors of identifiers (type names and variable
  names) are represented by two different tokens. Second, recognizing
  the end of these chunks without actually parsing them requires
  recognizing some patterns, typically like matching parentheses.</p>

<h2>Avoiding polluting the AST with chunks</h2>

<p>Storing chunks in the abstract syntax tree has a major drawback: it
  requires adding some constructors in its types for those chunks,
  which do not have any real sense in the language. The solution I use
  instead is to make all my semantic actions compute in a state
  monad, which passes the contextual environment information: while
  parsing, the semantic actions build the syntax tree in the form of
  a tree of closures. Once something has been parsed, the caller gives
  the initial environment as a parameter to the head closure, and the
  environment information propagates along the tree.</p>

<p>When there is a chunk in some node of the AST, the corresponding
  semantic action first uses the environment information to convert
  identifier tokens to their right flavor, then recursively parses the
  chunk, and finally gives the current environment to the returned
  semantic value, so that it can itself evaluate.</p>

<p>This monad is a bit more complicated than a simple state monad,
  because it also handles error (nested parsing can fail), and open
  recursion (the parser has to call itself, when it is not already
  defined).</p>

<h2>Conclusion</h2>

<p><a href="http://gallium.inria.fr/~scherer/gagallium/Parser.vy.html">Here</a> is a working version of the
  parser, using those ideas. A bit surprisingly, using all this monad
  machinery and delaying parsing does not decrease the performances
  too much. I have still some troubles proving it, and I'm looking
  forward to ideas to state all the invariants in a not-too-verbose
  way.</p>

<p>This work is still in progress, so I would be happy if you could
  give me your comments or ideas. But, in any case, I am now
  convinced that it is really possible to have a formalization of a
  parser for the C language, and particularly for the lexer hack. And
  this is a good thing, because, as its name suggest, the lexer hack
  is a hack, whose correctness is far from clear.</p>

<p>I have to say that, even if this work of proving a parser for
  a C compiler is sometimes quite tiresome, it allowed me to learn
  things in many different domains, from designing powerful automaton
  tactics in Coq to OCaml code optimization and LR(1)
  hackery: it's been a very challenging and rewarding experience.</p>

<p>If I wanted to work on that again in the future, there is still
  many things one would want to prove: does the parser terminates on
  all inputs? Are we sure it does not ask for a lookahead token after
  the end of the stream (that could be a problem in interactive
  languages, because it could block the input)?</p><a onclick="switchContent('post8','post7')" class="btn" href="#e93970411baf98fb039a1ccbbf0b5954">Hide</a></div></span>
<script type="text/javascript">function switchContent(id1,id2) {
     // Get the DOM reference
     var contentId1 = document.getElementById(id1);
     var contentId2 = document.getElementById(id2);
     // Toggle
     contentId1.style.display = "none";
     contentId2.style.display = "block";
     }</script></div>

  
    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
</body></html>
