<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: OCaml Planet</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contrinutors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="OCaml Planet" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it Online</a></li>
    <li><a href="../taste.html">100 Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who Is Using It?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a>
        <a href="http://langref.org/ocaml">langref.org</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../releases.html">Releases</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development Tools</a></li>
    <li><a href="../documentation.html">Manuals and Cheat Sheets</a></li>
    <li><a href="../tutorials/#advanced">Advanced Tutorials and Papers</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API Search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">Github</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing Lists</a></li>
    <li><a href="../planet/">Blogs</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml-lang.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>OCaml Planet
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

    <h1>OCaml Planet</h1>

    <p>The OCaml Planet aggregates various blogs from the OCaml
    community.  It is kindly provided
    by <a href="http://www.ocamlcore.com/">OCamlCore</a>.  If you
    would like to be added, read
    the <a href="http://www.ocamlcore.org/planet/">Planet
    subscription HOWTO</a>.</p>

    <br/>
    <div style="float: right; margin-right: 0; margin-top: 0" class="span2 planet-subscriptions"><em>Subscriptions</em>
      <ul><li><a href="http://alexleighton.tumblr.com/tagged/ocaml/rss">Alex Leighton</a></li><li><a href="http://blog.mestan.fr/feed/?cat=16">Alp Mestan</a></li><li><a href="http://andreiformiga.com/blog/?cat=5&feed=rss2">Andrei Formiga</a></li><li><a href="http://math.andrej.com/feed/">Andrej Bauer</a></li><li><a href="http://anil.recoil.org/feeds/atom.xml">Anil Madhavapeddy</a></li><li><a href="http://unnali.com/tag/ocaml/feed/">Arlen Cuss</a></li><li><a href="http://ashishagarwal.org/tag/ocaml/feed/">Ashish Agarwal</a></li><li><a href="http://www.blogger.com/feeds/7617521785419311079/posts/default">Cameleon news</a></li><li><a href="http://caml.inria.fr/news.en.rss">Caml INRIA</a></li><li><a href="http://camlspotter.blogspot.com/feeds/posts/default?alt=rss">Caml Spotting</a></li><li><a href="http://alan.petitepomme.net/cwn/cwn.rss">Caml Weekly News</a></li><li><a href="http://procrastiblog.com/category/ocaml/feed/">Christopher Conway</a></li><li><a href="http://coherentpdf.com/blog/?tag=ocaml&feed=rss">Coherent Graphics</a></li><li><a href="http://coq.inria.fr/news/feed">Coq</a></li><li><a href="http://erratique.ch/feeds/news.atom">Daniel Bünzli</a></li><li><a href="http://blog.dbpatterson.com/rss">Daniel Patterson</a></li><li><a href="http://nleyten.com/atom.aspx">Dario Teixeira</a></li><li><a href="http://www.blogger.com/feeds/17133288/posts/default/-/ocaml">David Baelde</a></li><li><a href="http://bentobako.org/david/blog/index.php?feed/tag/ocaml/atom">David Mentré</a></li><li><a href="http://dutherenverseauborddelatable.wordpress.com/category/ocaml/feed/">David Teller</a></li><li><a href="http://www.examachine.net/blog/?feed=rss2&cat=4">Eray Özkural</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/CodeHacking/Ocaml/index.rss20">Erik de Castro Lopo</a></li><li><a href="http://blog.emillon.org/feeds/ocaml.xml">Etienne Millon</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/FP-Syd/index.rss20">FP-Sydney</a></li><li><a href="http://www.blogger.com/feeds/8964007124326996693/posts/default/-/ocaml">Fayssal Martani</a></li><li><a href="http://frama-c.com/rss.xml">Frama-C</a></li><li><a href="http://functionaljobs.com/jobs/search/?q=ocaml&format=rss">Functional Jobs</a></li><li><a href="http://gallium.inria.fr/~scherer/gagallium/index.rss">GaGallium</a></li><li><a href="http://gaiustech.wordpress.com/category/ocaml/feed/">Gaius Hammond</a></li><li><a href="http://blog.camlcity.org/blog/rss">Gerd Stolpmann</a></li><li><a href="http://www.wisdomandwonder.com/tag/OCaml/feed">Grant Rettke</a></li><li><a href="http://blog.incubaid.com/tag/ocaml/feed/">Incubaid Research</a></li><li><a href="http://ambassadortothecomputers.blogspot.com/feeds/posts/default?alt=rss">Jake Donham</a></li><li><a href="http://scattered-thoughts.net/rss?tag=ocaml">Jamie Brandon</a></li><li><a href="http://ocaml.janestcapital.com/?q=rss.xml">Jane Street</a></li><li><a href="http://www.lexifi.com/blogs/ocaml/feed">LexiFi</a></li><li><a href="http://savonet.sourceforge.net/liquidsoap.rss">Liquidsoap</a></li><li><a href="http://syntaxexclamation.wordpress.com/tag/ocaml/feed/">Matthias Puech</a></li><li><a href="http://www.blogger.com/feeds/5888658295182480819/posts/default">Matías Giovannini</a></li><li><a href="http://eigenclass.org/R2/feeds/rss2/all">Mauricio Fernandez</a></li><li><a href="http://www.elehack.net/michael/blog/tags/ocaml?format=rss">Michael Ekstrand</a></li><li><a href="http://www.rktmb.org:82/feed/category/work/ocaml/atom">Mihamina Rakotomandimby</a></li><li><a href="http://nyc-ocaml.posterous.com/rss.xml">NYC OCaml</a></li><li><a href="http://ocamlhackers.ning.com/profiles/blog/feed?tag=ocaml&xn_auth=no">OCaml Hackers</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfnews.php">OCamlCore Forge News</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfprojects.php">OCamlCore Forge Projects</a></li><li><a href="http://www.ocamlcore.com/wp/?feed=rss2&amp;language=en&#038;language=en">OCamlCore.com</a></li><li><a href="http://www.ocamlpro.com/feed/atom.xml">OCamlPro</a></li><li><a href="http://odns.tuxfamily.org/feed/">ODNS project</a></li><li><a href="http://ox.tuxfamily.org/feed/">Ocaml XMPP project</a></li><li><a href="http://ocsigen.org/news.atom">Ocsigen project</a></li><li><a href="http://www.blogger.com/feeds/2073503406800427577/posts/default">Opa</a></li><li><a href="http://www.openmirage.org/blog/atom.xml">Open Mirage</a></li><li><a href="http://www.donadeo.net/facets/programming-languages/objective-caml/feed/">Paolo Donadeo</a></li><li><a href="https://mancoosi.org/~abate/taxonomy/term/5/0/feed">Pietro Abate</a></li><li><a href="http://redlizards.com/blog/feed/?tag=ocaml">Red Lizard Software</a></li><li><a href="http://rwmj.wordpress.com/tag/ocaml/feed/">Richard Jones</a></li><li><a href="http://blog.rastageeks.org/spip.php?page=rss&id_mot=2">Romain Beauxis</a></li><li><a href="http://seb.mondet.org/blog/feed/ocaml.rss">Sebastien Mondet</a></li><li><a href="http://upsilon.cc/~zack/tags/ocaml/index.rss">Stefano Zacchiroli</a></li><li><a href="http://le-gall.net/sylvain+violaine/blog/index.php?feed/tag/ocaml/atom">Sylvain Le Gall</a></li><li><a href="http://caml.inria.fr/hump.rss">The Caml Humps</a></li><li><a href="http://www.blogger.com/feeds/6115529230232389198/posts/default">Till Varoquaux</a></li><li><a href="http://www.nicollet.net/toroidal/ocaml/feed/">Victor Nicollet</a></li><li><a href="http://y-node.com/blog/feeds/tag/ocaml/">y-node</a></li></ul>

      <a href="http://planet.ocaml.org/rss20.xml"><img src=".././img/rss20.png"/></a>
      <a href="http://planet.ocaml.org/opml.xml"><img src=".././img/opml.png"/></a>
    </div>
    <div class="planet"><a name="4253f74339fd819282cbe40f9ebd13b2"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/~scherer/gagallium/singleton-types-for-code-inference-2"> Singleton types for code inference, continued</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">30 Dec 2012</span></span><span class="rss-description"><div id="post1"><p>In this post you can find out what was cut from the <a href="http://gallium.inria.fr/~scherer/gagallium/site-url/&amp;gt;singleton-types-for-code-inference">previous post on
singleton
types</a>. These are
more technical considerations that may require some familiarity with
type theory. In particular, I'll discuss linear and dependent types in
the context of describing more and more singletons.</p>




<p>In <a href="http://gallium.inria.fr/~scherer/gagallium/site-url/&amp;gt;singleton-types-for-code-inference">the previous
post</a>,
I discussed a code inference construction <code>(Γ |- ? : σ)</code> that would be
replaced, after type-checking, by the unique term <code>t</code> of type <code>σ</code>
(modulo program equivalence) in the environment Γ, or fail if no term
or several distinct terms exist at type σ.</p>

<h2>More singletons</h2>

<a onclick="switchContent('post1','post2')" class="btn" href="#4253f74339fd819282cbe40f9ebd13b2">Read more...</a></div><div id="post2" style="display: none"><p>In this post you can find out what was cut from the <a href="http://gallium.inria.fr/~scherer/gagallium/site-url/&amp;gt;singleton-types-for-code-inference">previous post on
singleton
types</a>. These are
more technical considerations that may require some familiarity with
type theory. In particular, I'll discuss linear and dependent types in
the context of describing more and more singletons.</p>




<p>In <a href="http://gallium.inria.fr/~scherer/gagallium/site-url/&amp;gt;singleton-types-for-code-inference">the previous
post</a>,
I discussed a code inference construction <code>(Γ |- ? : σ)</code> that would be
replaced, after type-checking, by the unique term <code>t</code> of type <code>σ</code>
(modulo program equivalence) in the environment Γ, or fail if no term
or several distinct terms exist at type σ.</p>

<h2>More singletons</h2>

<p>I have argued that the terms we will look for should live in
a different term language than the host language in which we would
consider using code-inference, to restrict ourselves to well-behaved,
pure terms. Any term language is fine as long as it can be embedded
into the host language, and can reasonably be shown to the user: you
may want to keep the <code>?</code> in the source code, but also sometimes show
the inferred term to the user, to help program understanding, or
because finding the term was the point as in my example of "I forgot
the argument order".</p>

<p>Another point of variability in the type system: we can in fact pick
any type system we want: in the most explicit form where the user
would write <code>(Γ |- ? : σ)</code> in the source, the type <code>σ</code> could live in
the type system for code inference, and not be a type expressions in
the host language. We only need to be able to translate the inferred
<em>terms</em> back into the host term language (and then we can verify
that they are type-correct if we don't trust the term
inference engine).</p>

<p>The embedding of the host type system to the type system for code
inference could be partial: maybe we won't be able to handle some of
the types inferred by the host system when using the simple <code>?</code>
construction, and those cases would fail with an error. The more
interesting aspect is that we can also have <em>finer types</em> in the
type system for code inference. For example, we can have linear
types.</p>

<p>For example, <code>∀α. (α → α → α) → α → α</code> is not a singleton type: it is
inhabited by <code>fun f x -&gt; x</code>, but also <code>fun f x -&gt; f x x</code>, <code>fun f x -&gt;
f x (f x x)</code>, etc. However, <code>∀α. (α → α → α) → α ⊸ α</code>, where the last
arrow is the linear arrow <code>⊸</code> (<code>-o</code> in glorious ASCII) which means "use
my argument exactly once", is a singleton type.</p>

<p>This suggests some experiment with finer type systems. For example,
<code>(β→γ) → (α*β*α) → (α*γ*α)</code> is not a singleton type:
the first and third components of the input tuple, of the same
type α, could be swapped in the output. But there are some type
systems (some of which my coworker Julien is working on) that are
somehow stricter than linear type systems in that they request not
only each input to be consumed exactly once, but its structure to be
preserved (no swapping of pair elements, etc.). Consider for example
a language of subtyping coercions: if you have a coercion of type
<code>β ≤ γ</code> in context, then there is only one coercion of type
<code>(α * β * α) ≤ (α * γ * α)</code>, and if seen as a function it does not
swap the tuple components.</p>

<p>We can observe the difference between the usual arrow <code>→</code>, the
linear arrow <code>⊸</code> and a notion of structure-preserving arrow
sketched above, that I would write <code>⇒</code>, on the type of <code>List.map</code>:</p>

<ul>
<li><p><code>∀αβ. (α → β) → (List α → List β)</code> is inhabited by any function
that applies its function argument to the elements of its list
argument, but may drop or reorder some of them. For example,
always returning the empty list is ok.</p></li>
<li><p>the inhabitants <code>∀αβ. (α ⊸ β) → (List α ⊸ List β)</code> are not
allowed to drop elements from the input list anymore, but may
still reorder them. <code>[x1,x2] ↦ [f x2, f x1]</code> is ok</p></li>
<li><p>the inhabitants of <code>∀αβ. (α ⇒ β) → (List α ⇒ List β)</code> must
preserve the structure of the input list, neither reordering nor
dropping elements; it is a singleton type. I think of it as the
coercion <code>(α ≤ β) |- List α ≤ List β</code> turned into a term.</p></li>
</ul>

<p>(You may be unsure what the <code>→</code> arrow between the function argument
and rest means in the two latter example. I am as well.)</p>

<h2>Towards dependent types</h2>

<p>Of course, another obvious direction to refine the type system is to
introduce dependent types (and refinement types, etc.). Consider the
type of List.fold_right: <code>∀αβ. (α → β → β) → (List α → β → β)</code>: in
this case, using linear or structure-preserving arrows does not get
us a singleton type, because there is no structure in the return
type <code>β</code> to be preserved. However, a dependent type for <code>fold_right</code>
on lists (with arguments reordered for readability) is a singleton:</p>

<pre><code>∀α ∀(P : List α → ★).
  P nil →
  (∀(x : α) (xs : List α). P xs → P (cons x xs)) → 
  ∀(li : List α). P li
</code></pre>

<p>Of course, you may notice that writing this type is in no way easier
than writing the corresponding term:</p>

<pre><code>let rec fold init f = function
  | nil -&gt; init
  | cons x xs -&gt; f x xs (fold init xs)
</code></pre>

<p>If you move to sophisticated enough type systems, the idea that
"types help you infer code" becomes a bit of cheating as writing the
types themselves is just as much work as writing the terms. The idea of
using singleton types for code inference is not a magic wand that
will have you suddenly write order of magnitudes less <em>stuff</em>,
rather one principled way to move between term implementation and
type specification, type and code inference, and to study the
practical aspects under different points of view. The study of
singleton types in sufficiently sophisticated type systems may turn
out to be of theoretical rather than practical interest, but it's
enough for me, because it looks <em>fun</em>.</p>

<h3>Singleton types?</h3>

<p>The concept of singleton types already exists in the literature in
a quite different form: for any term <code>M</code>, we can consider the type
<code>(= M)</code> which classifies the set of programs... equal to <code>M</code>. This has
been found quite useful by the people working on module systems to
capture just the level of dependent types needed to express public
type declarations in a module signature (they're used one level up:
singleton <em>kinds</em> that publish equalities with a <em>type</em>; but the
term/type level is more convenient for explanations).</p>

<p>Of course, the type <code>(= M)</code> is clearly a singleton type, and if you
determine that a type σ has a unique inhabitant <code>t</code>, this should be
equivalent to saying that you've discovered an equality between <code>σ</code>
and the singleton type <code>(= t)</code>. For example, if <code>∀αβ.(α*β)→(β*α)</code> is
"a singleton type" then it is the same type as
<code>(= λ(x,y).(y,x))</code>. This means that you could do everything of
interest by adding this notion of singleton types <code>(= M)</code> in your
language, and proving type equalities between regular types and this
explicit form of singletons.</p>

<p>However that only works if the <em>host</em> language and the <em>search</em>
language are the same. If I use singleton types to infer code in OCaml
or Haskell, I'll want to infer stuff from <code>∀αβ.(α*β)→(β*α)</code> while this
type is not equal to <code>(= λ(x,y).(y,x))</code> in the host language. I'd
rather keep the two different notions of singleton types separate, to
emphasize that my focus here is on code inference, not equality
reasoning (which, again, may not hold in the host language).</p>

<h2>Singleton types as "proof search"</h2>

<p>There is a nice interplay with Curry-Howard (already explicitly
employed in the previous works of Wells and Yakobowski): if we see
terms as proofs, we are interested in properties that have a <em>unique</em>
proof. I am not aware of logicians having worked on this question
(probably ignorance on my side), but to be fair mathematicians tend to
be interested in <em>existence</em> of proofs (the question of
type inhabitation) more than unicity. A good thing however is that
a large part of the literature on proof search is concerned with
finding <em>canonical</em> proofs, to avoid "redundancy" between proof
terms. Proof nets, uniform proofs, focusing are all somehow concerned
about this aspect (because proving meta-theorems about your proof
system is easier when proof objects are strongly structured). And it
turns out that the work to have more "canonical" proofs consists
exactly in finding representations where less different proofs are
equivalent as programs. This is an excellent excuse to learn more
about the proof search literature, to see if we can find ideas inside
that are helpful to determine singleton types.</p>

<p>As a form of proof search, there is also a clear relation with
<em>tactics</em> (or maybe even more with this fascinating Emacs gadget
that Agda users have, that allows them to interactively refine proof
goals with "obvious" steps according to the shape of the goal). <code>?</code>
is a specific kind of tactics that is interested not only in finding
some proof term, but in the details of its dynamic semantics. Are
there other "tactics" that are also useful for programming rather
than proving?</p>

<h2>A closing remark and a quote</h2>

<p>Some readers will have recognized some example of types I gave here as
examples of reasoning on parametricity. The fact that <code>∀α.α→α</code> is only
inhabited by the identity function is, for example, often argued by
invoking the kind of results of "Theorems for free!". But a simple
algorithm to find singletons will simply prove that there is only one
correct βη-normal form of this type: first you have to use a Λαλ(x:α)
by η-expanding, and then you have nothing to use as a function body in
your context other than (x:α).</p>

<p>I'll remark that the link between parametricity and singleton types is
maybe weaker than it could seem, as a practical algorithm to determine
that types are singleton will rather work by trying to exhaust the
search space for terms, than reasoning on semantic relations derived
from the type -- but who knows. Let's say, at least, that I understand
term search better than I understand parametricity, a topic on which
I suspect we have still a lot to find out.</p>

<p>Let me conclude with
a nice 2011 quote from Conor McBride <a href="http://www.quora.com/Why-do-programming-languages-use-type-systems">on
Quora</a>
(no idea why he put it there). </p>

<blockquote>
  <p>Whilst I don't want to gainsay the importance of types as a source
of corrective raspberry-blowing, I would like to offer the prospect
that types might have an active role to play, structuring the
process of program inference. Overloading allows you to get rid of
boring lumps of code if it can be figured out from
types. Datatype-generic programming uses representations of the
structure of types to calculate specific instances of
algorithm-schemes. Dependent type systems often allow
run-time-relevant values to be inferred silently from type
information.</p>

<p>Crucially, also, types structure the search for programs in useful
ways, provided your editing environment offers you type information
and makes it easy to select type-appropriate choices. Sometimes it's
easier to search for good programs in the space of well typed
programs, rather than in the space of ascii turds.</p>

<p>This position constitutes a change of viewpoint in the purpose of
types. If programs worked just the same with the types rubbed out,
then types would represent a form of piety often inadequate with
respect to testing. It's when types contribute information to
algorithm selection, design statements which program definitions
need merely refine, that they constitute a significant win.</p>

<p>To be fair, even in last century's typed languages, types had
a beneficial organisational effect on programmers. This century,
it's just possible types will have a comparable effect on
programs. Types are concepts and now mechanisms supporting
program-discovery as well as error-discovery. I think that's more
than just gravy.</p>
</blockquote><a onclick="switchContent('post2','post1')" class="btn" href="#4253f74339fd819282cbe40f9ebd13b2">Hide</a></div></span>
<a name="c2fcb8b4aa00ad4abb174274b6a1d45f"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/~scherer/gagallium/singleton-types-for-code-inference"> Singleton types for code inference</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">29 Dec 2012</span></span><span class="rss-description"><div id="post3"><p>Could the compiler <em>guess</em> a part of the program I am
currently writing? It's impossible in general, but it may be possible,
and hopefully interesting, in special cases. For a start, I am
interested in a situation where there is <em>only one possibility</em>: at
the expected type, there is only one possible program -- modulo
(an approximation of) program equivalence.</p>

<p>In a fixed environment, a type is a <em>singleton type</em> if it has only
one inhabitant. How widespread are those? Would a language feature to
infer their inhabitants be useful? Can we have more interesting
singleton types by enriching the type system?</p>

<p>Don't expect a structured story with a happy ending: this is only
a writing-ideas-down session for something I have been thinking about
lately.</p>




<p>PS: See <a href="http://gallium.inria.fr/~scherer/gagallium/site-url/&amp;gt;singleton-types-for-code-inference-2">the next
post</a> for more
details on the idea.</p>

<h2>From erasable coercions to singleton types</h2>

<a onclick="switchContent('post3','post4')" class="btn" href="#c2fcb8b4aa00ad4abb174274b6a1d45f">Read more...</a></div><div id="post4" style="display: none"><p>Could the compiler <em>guess</em> a part of the program I am
currently writing? It's impossible in general, but it may be possible,
and hopefully interesting, in special cases. For a start, I am
interested in a situation where there is <em>only one possibility</em>: at
the expected type, there is only one possible program -- modulo
(an approximation of) program equivalence.</p>

<p>In a fixed environment, a type is a <em>singleton type</em> if it has only
one inhabitant. How widespread are those? Would a language feature to
infer their inhabitants be useful? Can we have more interesting
singleton types by enriching the type system?</p>

<p>Don't expect a structured story with a happy ending: this is only
a writing-ideas-down session for something I have been thinking about
lately.</p>




<p>PS: See <a href="http://gallium.inria.fr/~scherer/gagallium/site-url/&amp;gt;singleton-types-for-code-inference-2">the next
post</a> for more
details on the idea.</p>

<h2>From erasable coercions to singleton types</h2>

<p>I started to think about this kind of singleton types seriously when
discussing with one of our fellow students at Gallium, <a href="http://gallium.inria.fr/~jcretin/">Julien
Cretin</a>. Julien has been working on
coercions for long enough that, if you listen to him, basically
anything in a type system is a coercion in disguise. But for the most
part he has worked on <em>erasable coercions</em>, that are terms from a type
<code>A</code> to a type <code>B</code> that are just the identity function (once you erase
the type annotations that make them useful).</p>

<p>One example in System F is the coercion</p>

<pre><code>λ(f:A→∀α.B). Λα.λ(x:A). f x α
</code></pre>

<p>from <code>A→∀α.B</code> to <code>∀α.(A→B)</code>. Note that if you erase all the type
annotations (including type abstractions and applications), this
becomes just <code>λfλx. f x</code>, which is an η-expansion of the identity
function. Those identities are "erasable" in the sense that, after the
type-checking phase, you can just drop them from your program and you
will never notice: they do not affect the runtime semantics of the
program.</p>

<p>Erasable coercions are fairly interesting as a way to structure and
explain type systems. For example, they allow to understand various
variants of System F (System Fη, Fsub, and MLF) as instances of
a general version of System F enhanced with abstraction on coercions,
whose formal study is surprisingly challenging. You can learn about
this in <a href="http://gallium.inria.fr/~remy/coercions/Cretin-Remy:coercions@popl2012.pdf">Julien's 2012 paper with Didier
Rémy</a>
(<a href="http://hal.inria.fr/docs/00/60/85/66/PDF/full.pdf">long version</a>).</p>

<p>But what would be a notion of <em>non-erasable</em> coercion? My suggestion
was to consider terms that may not exactly be the identity, but that
are unique at their type. This is actually a fairly different concept:
some coercions (for example <code>int → int</code>) are not unique in their
types, and some unique inhabitants (for example in <code>∀αβ.(α*β)→(β*α)</code>)
have a runtime behavior that is fairly different from the identity.</p>

<h2>Singleton types in practice</h2>

<p>As a thought experiment, imagine adding the keyword <code>?</code> in the
syntactic class of expressions of your programming language. The
semantics of <code>?</code> is as follows: at typing time, it can take absolutely
any type and will never raise a type error. After the program has been
verified to be type-correct, we look at each occurrence of <code>?</code> and its
inferred type. If the type is a singleton (assume we know how to
check this), we replace <code>?</code> with the unique inhabitant, otherwise we
fail with an error.</p>

<p>That's an inference-centered point of view. In languages with less
robust type inference than ML languages, we could have a more robust
feature with a construction <code>(? : σ)</code> that is given a precise type,
which should later turn out to be a singleton. A simple <code>?</code> is then
explained as <code>(? : _)</code>, where <code>_</code> means "infer me" at the type level.</p>

<p>Consider for example those lines of OCaml or Haskell code found in
the wild (in fact in the OCaml type-checker and in GHC):</p>

<pre><code>(List.map (fun (name, smty, smodl) -&gt; (name, smty))

zipWith3M f xs ys zs =
  zipWithM (\x -&gt; \(y,z) -&gt; (f x y z)) xs (zip ys zs)
</code></pre>

<p>The functions passed to <code>List.map</code> and <code>zipWithM</code> here are the
typical kind of boilerplate that is boring to write. Provided that
"the types are distinct enough", they are also singleton types: <code>fun
(x,y,z) -&gt; (x,y)</code> is a singleton type as long as the types for <code>x</code>,
<code>y</code> and <code>z</code> are distinct (in this example I checked and they are),
likewise in the second example. Wouldn't it be nice to be able to write:</p>

<pre><code>(List.map ?)

zipWith3M f xs ys ys = zipWithM (? f) xs (zip ys zs)
</code></pre>

<p>The hope is that some of the case where you think "This is dumb,
I should not have to write it" may turn out to be, when looking at
them the right way, inferrable through singleton types.</p>

<h2>Singleton types precisely</h2>

<p>What does it mean for a type to be a singleton type? We have to make
a choice on four aspects:</p>

<ul>
<li><p>The type system we consider (the static semantics). Are we looking
for singleton types in ML, in System F, in a dependently typed
calculus? All those choices have merit, but for the purpose of the
demonstration I will mostly use examples in System F.</p></li>
<li><p>The language of the terms we infer (the dynamic semantics). If we
consider the full term language of OCaml (or Haskell) as the space
of our search, no interesting type is a singleton because of
non-terminating terms inhabiting any type. We want to restrict
ourselves to a pure (including total) lambda-calculus. For a start,
just the obvious explicitly typed thing with variables, lambdas and
applications will be fine.</p></li>
<li><p>Our notion of program equivalence: if we consider <code>t</code> and <code>(λx.x) t</code>
as two different programs, we will have trouble finding unique
inhabitants. On the other end, observational equivalence is often
undecidable for realistic languages, so we may have to pick
reasonable restrictions. I will just imagine I can perfectly decide
observational equivalence for now.</p></li>
<li><p>The typing context where inhabitants live: I am asking whether a type
<code>σ</code> has a unique inhabitant <code>t : σ</code>. To consider this properly
I need to pick a typing context <code>Γ</code> and ask about <code>Γ ⊢ ? : σ</code>. We
could imagine giving the user some freedom to specify the context in
which the search should take place. A good starting choice is to
consider the super-empty context: a context with no variables, but
also <em>no constants</em>: forget about <code>0, 1, 2, true, false</code>, etc., to
get even more singleton types (<code>bool → int → bool</code>,
for example). Other reasonable choices include the empty context
with constants, the current context of the program, or a restriction
of the current context with only the variables that have been marked
"implicit" of sorts.</p></li>
</ul>

<p>The restriction to an empty context is why I wrote <code>(? f)</code> in the
previous example:</p>

<pre><code>zipWithM3 f xs ys zs = zipWithM (? f) xs (zip ys zs)
</code></pre>

<p>If I just write <code>zipWithM ? xs ..</code>, this tries to infer code at the
type <code>(a → (b, c) → m d)</code>, which is not inhabited in an empty
context. On the contrary, the <code>?</code> in <code>(? f)</code> has type
<code>(a → b → c → m d) → (a → (b, c) → m d)</code>, which is a singleton
type. This shows that this construct can actually be used for
<em>partial</em> term inference, just add the hints as parameters to
<code>?</code>. (Another possibility would be to add syntax to specify
a context by hand, eg. <code>(f,g |- ? : σ)</code>.)</p>

<p>Similarly, it can also be used for plumbing: if you cannot remember
which of <code>x</code> or <code>y</code> comes first as a parameter to <code>f</code>, and they have
different types, <code>(? f x y)</code> can do the job. (If they don't have
different types there is a potential for non-statically-catchable
error and that's bad. OCaml's <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual006.html#toc35">labeled
arguments</a>
are very nice when used to fight this, but it's orthogonal to the
present considerations.)</p>

<h2>Related Work</h2>

<p>I know of surprisingly little work on the topic of "code inference"
(looking for this search string on Google Scholar for example brings
up very little hits), and would welcome pertinent pointers. There is
a paper at PLDI last year, <a href="http://research.microsoft.com/en-us/um/people/sumitg/pubs/pldi12.pdf">Type-Directed Completion of Partial
Expressions</a>
by Daniel Perelman, Sumit Gulwani, Thomas Ball and Dan Grossman, but
it is much more practically oriented: "let's look for completions
using typing hints and see how often we were right in ranking highly
a suggestion to the user". In the limit, you get something fuzzy and
interactive and machine-learning-based, where type-correctness is just
one ranking criterion among others, as you can find in <a href="http://research.microsoft.com/en-us/people/smcdirm/">Sean
McDirmid</a>'s work
on touch-based programming or calls to <a href="http://www.cs.rutgers.edu/~ccshan/rational/pcr.pdf">Programming as collaborative
reference</a>, but
that is not where I want to go now. The idea here more to study the
mathematical structure of singleton types, which is quite a different
subject.</p>

<p>Of course, "singleton types" is just a special case: it could also be
interesting for code inference to determine which types have only two
inhabitants; the compiler then wouldn't choose automatically
(that would break principality) but instead give the choice to the
user. Joe B. Wells has a paper with Boris Yakobowski (which is,
incidentally, a former <a href="http://gallium.inria.fr/~yakobows/">Gallium PhD
student</a>), <a href="http://www.macs.hw.ac.uk/~jbw/papers/#Wel+Yak:LOPSTR-2004-informal">Graph-based proof
counting and enumeration with applications for program fragment
synthesis</a>,
that does exactly this: count the number of inhabitants of types in an
intuitionistic type theory, and devise a term enumeration algorithm
out of it. It is the most pertinent previous work that I know of, and
was done with program synthesis in mind.</p>

<h2>Singleton types and programming experience</h2>

<p>I've mentioned that singleton types is only one specific case in the
wider setting of "please find me the inhabitants of this
type". I think however that focusing on singleton types is maybe not
as ad-hoc at is looks like: if a type has a finite number of
inhabitants, it can probably be decomposed as a sum of singleton
types. Maybe we could tell to the user of our <code>?</code> construction that
"you're not a singleton yet, you have to make a choice between this
type and this type", and let him add just enough information to
determine which situation she's interested in. That would be
potentially even more useful than enumerating the full terms and
letting the user choose one, as <code>?</code> may be more robust in the face of
code maintenance than system-spewed boilerplate.</p>

<p>More robust, or more fragile: being a singleton is not stable by
instantiation. The type <code>∀αβ. α*β → β*α</code> is a singleton, but
instantiating <code>α:=int, β:=int</code> breaks this property. (Note that it
is interesting in practice only if the type is inferred,
because it is just as long as the term.). People are
surprised/dismayed by this aspect when I give them examples of
singleton types, but I think it's fine: we are checking singletons
<em>after</em> type inference, where type abstractions and applications
have been fully determined. Yet I don't know how robust those <code>?</code>
would be in practice. I think the idea of doing all this <em>after</em>
type inference is a sane protection: I have this intuition that we
probably don't want a system that tries to infer <em>simultaneously</em>
the types of some part of our program, and the terms of another.</p>

<p>Note that it is possible to see the work on type classes as a specific
instance of the idea of singleton types. Using an operation of a type
class would add a <code>?</code> to synthesize the expected dictionary. Instance
declarations are function declarations (instance dependencies being
function arrows) that populate the context of search. The coherence
relations that reduce ambiguities in Haskell are a way to ensure
unicity of inhabitants. Finally, inference of class predicates
(the way <code>Eq a =&gt;</code> gets added to an inferred function type if you use
<code>(==)</code> inside the body of the function) is a way to ensure that there
is always an inhabitant.</p>

<p>This is not a realization of the highest importance, because it
actually tells us little new about type classes; singletons are
a rather general way to look at everything that involves some form of
"guessing code" that is a bit principled (and doesn't just produce
code at random); this recasting should work for other features that
can be expressed as code inference. It tells us, however, that some
particular forms in the design space for putting singleton types in
practice have already found themselves useful enough for
programmers. I think that justifies looking at the concept at a wide
angle.</p>

<h2>A temporary ending -- or delay</h2>

<p>This post is getting quite long, so I'll temporarily conclude
here. Stay tuned for another blog post with even more ramblings about
singleton types !</p>

<p>PS: <a href="http://gallium.inria.fr/~scherer/gagallium/site-url/&amp;gt;singleton-types-for-code-inference-2">The next
post</a> is now out.</p><a onclick="switchContent('post4','post3')" class="btn" href="#c2fcb8b4aa00ad4abb174274b6a1d45f">Hide</a></div></span>
<a name="442a8cf9808ce87d6f90546225bcb702"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/forum/forum.php?forum_id=867"> Macaque 0.6.1</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge News</span>, <span class="rss-date">26 Dec 2012</span></span><span class="rss-description"><pre class="rss-text">This is mostly a bugfix release: Jacques-Pascal Deplaix has spotted a bug in the way Macaque handles PostgreSQL rather baroque string escaping convention (you don't want to know the details), and after some head scratching we have a reasonable fix.

In addition, Petter Urkedal has contributed support for the 'bytea' and 'int32_array' datatypes; for now, there is no literal syntax to describe them in the syntax extension, so one should build values on the OCaml side, through Sql.Value.bytea and Sql.Value.int32_array.</pre></span>
<a name="e6c5dd3a656929c1664b08fc37901245"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2012.12.25.html"> Caml Weekly News, 25 Dec 2012</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">25 Dec 2012</span></span><span class="rss-description">new ocaml.org website / OCaml wiki / OCaml search into libraries for ocaml.org / Post-doc/Software Engineer at OCamlPro / Other Caml News</span>
<a name="e672efd955ba77a031ef9e8392474060"></a><span class="rss-header"><span class="rss-title"><a href="http://math.andrej.com/2012/12/25/free-variables-are-not-implicitly-universally-quantified/"> Free variables are not “implicitly universally quantified”!</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Andrej Bauer</span>, <span class="rss-date">25 Dec 2012</span></span><span class="rss-description"><div id="post5"><p>Mathematicians are often confused about the meaning of variables. I hear them say “a free variable is implicitly universally quantified”, by which they mean that it is ok to equate a formula $\phi$ with a free variable $x$ with its universal closure $\forall x \,.\, \phi$. I am addressing this post to those who share this opinion.</p>
<p><span id="more-1387"></span></p>
<p>I will give several reasons, which are all essentially the same, why “there is no difference between $\phi$ and $\forall x \,.\, \phi$” is a really bad opinion to have.</p>
<h3>Reason 1: you wouldn’t equate a function with its definite integral</h3>
<p>You would not claim that a real-valued function $f : \mathbb{R} \to \mathbb{R}$ is “the same thing” as its definite integral $\int_{\mathbb{R}} f(x) \, d x$, would you? One is a real function, the other is a real number. Likewise, $\phi$ is a truth &lt;emph&gt;function&lt;/emph&gt; and $\forall x \,.\, \phi(x)$ is a truth &lt;emph&gt;value&lt;/emph&gt;.</p>
<h3>Reason 2: functions are not their own values</h3>
<a onclick="switchContent('post5','post6')" class="btn" href="#e672efd955ba77a031ef9e8392474060">Read more...</a></div><div id="post6" style="display: none"><p>Mathematicians are often confused about the meaning of variables. I hear them say “a free variable is implicitly universally quantified”, by which they mean that it is ok to equate a formula $\phi$ with a free variable $x$ with its universal closure $\forall x \,.\, \phi$. I am addressing this post to those who share this opinion.</p>
<p><span id="more-1387"></span></p>
<p>I will give several reasons, which are all essentially the same, why “there is no difference between $\phi$ and $\forall x \,.\, \phi$” is a really bad opinion to have.</p>
<h3>Reason 1: you wouldn’t equate a function with its definite integral</h3>
<p>You would not claim that a real-valued function $f : \mathbb{R} \to \mathbb{R}$ is “the same thing” as its definite integral $\int_{\mathbb{R}} f(x) \, d x$, would you? One is a real function, the other is a real number. Likewise, $\phi$ is a truth &lt;emph&gt;function&lt;/emph&gt; and $\forall x \,.\, \phi(x)$ is a truth &lt;emph&gt;value&lt;/emph&gt;.</p>
<h3>Reason 2: functions are not their own values</h3>
<p>To be quite precise, the expression $\phi$ by itself is not a function, just like the expression $x + \sin x$ is not a function. To make it into a function we must first &lt;emph&gt;abstract&lt;/emph&gt; the variable $x$, which is usually written as $x \mapsto x + \sin x$, or $\lambda x \,.\, x + \sin x$, or <code>fun x -&gt; x +. sin x</code>. In logic we indicate the fact that $\phi$ is a function by putting it in a &lt;emph&gt;context&lt;/emph&gt;, so we write something like $x : \mathbb{R} \vdash \phi$.</p>
<p>Why is all this nit-picking necessary? Try answering these questions with “yes” and “no” consistently:</p>
<ol>
<li>Is $x + \sin x$ a function in variable $x$?</li>
<li>Is $x + \sin x$ a function in variables $x$ and $y$?</li>
<li>Is $y – y + x + \sin x$ a function in variables $x$ and $y$?</li>
<li>Is $x + \sin x = y – y + x + \sin x$?</li>
</ol>
<p>A similar sort of mistake happens in algebra where people think that polynomials are functions. They are not. They are elements of a certain freely generated ring.</p>
<h3>Reason 3: They are not logically equivalent</h3>
<p>It is absurd to claim that $\phi$ and $\forall x \in \mathbb{R} \,.\, \phi$ are logically equivalent statements. Suppose $\forall x \in \mathbb{R} \,.\, x &gt; 2$ were equivalent to $x &gt; 2$. Then I could replace one by the other in any formula I wish. So I choose the formula $\exists x \in \mathbb{R} \,.\, x &gt; 2$. It must be equivalent to $\exists x \in \mathbb{R} \,.\, \forall x \in \mathbb{R} \,.\, x &gt; 2$, but since $\forall x \in \mathbb{R} \,.\, x &gt; 2$ is false, we get $\exists x \in \mathbb{R} \,.\, \bot$, which is false. We proved that there is no number larger than 2.</p>
<h3>Reason 4: They are not inter-derivable</h3>
<p>If you can tell the difference between an implication and logical entailment, perhaps you might try to counter reason 3 by pointing out that $\phi$ and $\forall x \,.\, \phi$ are either both derivable, or both not derivable. That is to say, we can prove one if, and only if, we can prove the other. But again, this is not the case. We can prove $\forall x \in \emptyset \,.\, \bot$ but we cannot prove $\bot$.</p>
<h3>Reason 5: Bound variables can be renamed but free variables cannot</h3>
<p>The formula $x &gt; 2$ is obviously not the same thing as the formula $y &gt; 2$. But the formula $\forall x \in \mathbb{R} . x &gt; 2$ is actually the same as $\forall y \in \mathbb{R} . y &gt; 2$. If you find this confusing it is because you were never taught properly how to handle <a href="http://en.wikipedia.org/wiki/Free_variables_and_bound_variables">free and bound variables</a>.</p>
<h3>Reason 6: You cannot prove $\forall x \,.\, \phi$ without allowing $x$ to become free</h3>
<p>Perhaps we can just forbid free variables altogether and &lt;emph&gt;stipulate&lt;/emph&gt; that all variables must always be quantified. But how are you then going to prove $\forall x \in \mathbb{R} \,.\, \phi$? The usual way</p>
<blockquote><p>
“Consider any $x \in \mathbb{R}$. Then bla bla bla, therefore $\phi$.”
</p></blockquote>
<p>is now forbidden because the first sentence introduces $x$ as a free variable.</p>
<p>We can abolish variables altogether if we wish, by resorting to combinators, but it makes no sense to keep variables and make them all bound all the time.</p>
<h3>Epilogue: so in what sense are they the same?</h3>
<p>There is a theorem in model theory:</p>
<blockquote><p>
Let $\phi$ be a formula in context $x_1, \ldots, x_n$ and $M$ a structure in which we can interpret $\phi$. The following are equivalent:</p>
<ol>
<li>the universal closure $\forall x_1, \ldots, x_n \,.\, \phi$ is valid in $M$,</li>
<li>for every valuation $\nu : \lbrace x_1, \ldots, x_n \rbrace \to M$, $\phi[\nu]$ is valid in $M$.</li>
</ol>
</blockquote>
<p>This is sometimes abbreviated (quite inaccurately) as “a formula and its universal closure are semantically equivalent”. This theorem is causing a lot of harm because mathematicians interpret it as “free variables are implicitly universally bound”. But the theorem itself clearly distinguishes a formula from its universal closure. It has a limited range of applications in model theory. It is not a general reasoning principle that would allow you to dispose of thinking about free variables.</p>
<p>You are in good company. Philosophers have thought about free variables for millennia, although they phrase the problem in the language of <a href="http://en.wikipedia.org/wiki/Universal_(metaphysics)">universals</a> and <a href="http://en.wikipedia.org/wiki/Particular">particulars</a>. They wonder whether “dog” is the same thing as the set of all dogs, or perhaps there is an ideal dog which is “pure dogness”, but then do we need two ideal dogs to make ideal pups, etc. The answer is simple: a free variable is a projection from a cartesian product.</p><a onclick="switchContent('post6','post5')" class="btn" href="#e672efd955ba77a031ef9e8392474060">Hide</a></div></span>
<a name="2f9fc6a8ae811c870e3859f2689319a7"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/tptp/"> tptp</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">21 Dec 2012</span></span><span class="rss-description">Library for parsing FOF and CNF formulas from TPTP format. Depends on: zarith.</span>
<a name="7848ce5e403469fa5a3757e71a0f8191"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=817"> Xtmpl 0.5</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">19 Dec 2012</span></span><span class="rss-description">Xtmpl is a small XML templating library for OCaml.</span>
<a name="7ff089ca4b443c810138d4a7c8e8b486"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=818"> Stog 0.5</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">19 Dec 2012</span></span><span class="rss-description">Stog is a kind of Jekyll in OCaml: It is a static web site generator, able to handle blog posts as well as regular pages.</span>
<a name="3aeebe7a5873af158331e6566e6c7b25"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/cryptodbm/"> Cryptodbm: Encrypted dbm</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">18 Dec 2012</span></span><span class="rss-description">Library for creating and reading encrypted databases (serverless, encrypted key-value databases).</span>
<a name="ebe2a7c57571bc1eb87b0df1ac92c1c5"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2012.12.18.html"> Caml Weekly News, 18 Dec 2012</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">18 Dec 2012</span></span><span class="rss-description">new OPAM command-line interface / RTT (Run-time types) online toplevel for trying / Other Caml News</span>
<script type="text/javascript">function switchContent(id1,id2) {
     // Get the DOM reference
     var contentId1 = document.getElementById(id1);
     var contentId2 = document.getElementById(id2);
     // Toggle
     contentId1.style.display = "none";
     contentId2.style.display = "block";
     }</script></div>

  
    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
</body></html>
