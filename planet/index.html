<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: OCaml Planet</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contrinutors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="OCaml Planet" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it in your browser</a></li>
    <li><a href="../taste.html">A Hundred Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who is using it?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development tools</a></li>
    <li><a href="../documentation.html">Manuals and Cheat Sheets</a></li>
    <li><a href="../tutorials/#advanced">Advanced tutorials &amp; Papers</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">Github</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing lists</a></li>
    <li><a href="../planet/">OCaml Planet (blogs)</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml-lang.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>OCaml Planet
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

    <h1>OCaml Planet</h1>

    <p>The OCaml Planet aggregates various blogs from the OCaml
    community.  It is kindly provided
    by <a href="http://www.ocamlcore.com/">OCamlCore</a>.  If you
    would like to be added, read
    the <a href="http://www.ocamlcore.org/planet/">Planet
    subscription HOWTO</a>.</p>

    <br/>
    <div style="float: right; margin-right: 0; margin-top: 0" class="span2 planet-subscriptions"><em>Subscriptions</em>
      <ul><li><a href="http://alexleighton.tumblr.com/tagged/ocaml/rss">Alex Leighton</a></li><li><a href="http://blog.mestan.fr/feed/?cat=16">Alp Mestan</a></li><li><a href="http://andreiformiga.com/blog/?cat=5&feed=rss2">Andrei Formiga</a></li><li><a href="http://math.andrej.com/feed/">Andrej Bauer</a></li><li><a href="http://anil.recoil.org/feeds/atom.xml">Anil Madhavapeddy</a></li><li><a href="http://unnali.com/tag/ocaml/feed/">Arlen Cuss</a></li><li><a href="http://ashishagarwal.org/tag/ocaml/feed/">Ashish Agarwal</a></li><li><a href="http://www.blogger.com/feeds/7617521785419311079/posts/default">Cameleon news</a></li><li><a href="http://caml.inria.fr/news.en.rss">Caml INRIA</a></li><li><a href="http://camlspotter.blogspot.com/feeds/posts/default?alt=rss">Caml Spotting</a></li><li><a href="http://alan.petitepomme.net/cwn/cwn.rss">Caml Weekly News</a></li><li><a href="http://procrastiblog.com/category/ocaml/feed/">Christopher Conway</a></li><li><a href="http://coherentpdf.com/blog/?tag=ocaml&feed=rss">Coherent Graphics</a></li><li><a href="http://coq.inria.fr/news/feed">Coq</a></li><li><a href="http://erratique.ch/feeds/news.atom">Daniel Bünzli</a></li><li><a href="http://blog.dbpatterson.com/rss">Daniel Patterson</a></li><li><a href="http://nleyten.com/atom.aspx">Dario Teixeira</a></li><li><a href="http://www.blogger.com/feeds/17133288/posts/default/-/ocaml">David Baelde</a></li><li><a href="http://bentobako.org/david/blog/index.php?feed/tag/ocaml/atom">David Mentré</a></li><li><a href="http://dutherenverseauborddelatable.wordpress.com/category/ocaml/feed/">David Teller</a></li><li><a href="http://www.examachine.net/blog/?feed=rss2&cat=4">Eray Özkural</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/CodeHacking/Ocaml/index.rss20">Erik de Castro Lopo</a></li><li><a href="http://blog.emillon.org/feeds/ocaml.xml">Etienne Millon</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/FP-Syd/index.rss20">FP-Sydney</a></li><li><a href="http://www.blogger.com/feeds/8964007124326996693/posts/default/-/ocaml">Fayssal Martani</a></li><li><a href="http://frama-c.com/rss.xml">Frama-C</a></li><li><a href="http://functionaljobs.com/jobs/search/?q=ocaml&format=rss">Functional Jobs</a></li><li><a href="http://gallium.inria.fr/~scherer/gagallium/index.rss">GaGallium</a></li><li><a href="http://gaiustech.wordpress.com/category/ocaml/feed/">Gaius Hammond</a></li><li><a href="http://blog.camlcity.org/blog/rss">Gerd Stolpmann</a></li><li><a href="http://www.wisdomandwonder.com/tag/OCaml/feed">Grant Rettke</a></li><li><a href="http://blog.incubaid.com/tag/ocaml/feed/">Incubaid Research</a></li><li><a href="http://ambassadortothecomputers.blogspot.com/feeds/posts/default?alt=rss">Jake Donham</a></li><li><a href="http://scattered-thoughts.net/rss?tag=ocaml">Jamie Brandon</a></li><li><a href="http://ocaml.janestcapital.com/?q=rss.xml">Jane Street</a></li><li><a href="http://www.lexifi.com/blogs/ocaml/feed">LexiFi</a></li><li><a href="http://savonet.sourceforge.net/liquidsoap.rss">Liquidsoap</a></li><li><a href="http://syntaxexclamation.wordpress.com/tag/ocaml/feed/">Matthias Puech</a></li><li><a href="http://www.blogger.com/feeds/5888658295182480819/posts/default">Matías Giovannini</a></li><li><a href="http://eigenclass.org/R2/feeds/rss2/all">Mauricio Fernandez</a></li><li><a href="http://www.elehack.net/michael/blog/tags/ocaml?format=rss">Michael Ekstrand</a></li><li><a href="http://www.rktmb.org:82/feed/category/work/ocaml/atom">Mihamina Rakotomandimby</a></li><li><a href="http://nyc-ocaml.posterous.com/rss.xml">NYC OCaml</a></li><li><a href="http://ocamlhackers.ning.com/profiles/blog/feed?tag=ocaml&xn_auth=no">OCaml Hackers</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfnews.php">OCamlCore Forge News</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfprojects.php">OCamlCore Forge Projects</a></li><li><a href="http://www.ocamlcore.com/wp/?feed=rss2&amp;language=en&#038;language=en">OCamlCore.com</a></li><li><a href="http://www.ocamlpro.com/feed/atom.xml">OCamlPro</a></li><li><a href="http://odns.tuxfamily.org/feed/">ODNS project</a></li><li><a href="http://ox.tuxfamily.org/feed/">Ocaml XMPP project</a></li><li><a href="http://ocsigen.org/news.atom">Ocsigen project</a></li><li><a href="http://www.blogger.com/feeds/2073503406800427577/posts/default">Opa</a></li><li><a href="http://www.openmirage.org/blog/atom.xml">Open Mirage</a></li><li><a href="http://www.donadeo.net/facets/programming-languages/objective-caml/feed/">Paolo Donadeo</a></li><li><a href="https://mancoosi.org/~abate/taxonomy/term/5/0/feed">Pietro Abate</a></li><li><a href="http://redlizards.com/blog/feed/?tag=ocaml">Red Lizard Software</a></li><li><a href="http://rwmj.wordpress.com/tag/ocaml/feed/">Richard Jones</a></li><li><a href="http://blog.rastageeks.org/spip.php?page=rss&id_mot=2">Romain Beauxis</a></li><li><a href="http://seb.mondet.org/blog/feed/ocaml.rss">Sebastien Mondet</a></li><li><a href="http://upsilon.cc/~zack/tags/ocaml/index.rss">Stefano Zacchiroli</a></li><li><a href="http://le-gall.net/sylvain+violaine/blog/index.php?feed/tag/ocaml/atom">Sylvain Le Gall</a></li><li><a href="http://caml.inria.fr/hump.rss">The Caml Humps</a></li><li><a href="http://www.blogger.com/feeds/6115529230232389198/posts/default">Till Varoquaux</a></li><li><a href="http://www.nicollet.net/toroidal/ocaml/feed/">Victor Nicollet</a></li><li><a href="http://y-node.com/blog/feeds/tag/ocaml/">y-node</a></li></ul>

      <a href="http://planet.ocaml.org/rss20.xml"><img src=".././img/rss20.png"/></a>
      <a href="http://planet.ocaml.org/opml.xml"><img src=".././img/opml.png"/></a>
    </div>
    <div class="planet"><a name="3aeebe7a5873af158331e6566e6c7b25"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/cryptodbm/"> Cryptodbm: Encrypted dbm</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">18 Dec 2012</span></span><span class="rss-description">Library for creating and reading encrypted databases (serverless, encrypted key-value databases).</span>
<a name="ebe2a7c57571bc1eb87b0df1ac92c1c5"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2012.12.18.html"> Caml Weekly News, 18 Dec 2012</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">18 Dec 2012</span></span><span class="rss-description">new OPAM command-line interface / RTT (Run-time types) online toplevel for trying / Other Caml News</span>
<a name="e54acddb53f86b28cf68b31b0c1e9abe"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=840"> RTT 0.4</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">17 Dec 2012</span></span><span class="rss-description">RTT is a prototype implementation of run-time typing in OCaml. It allows programmers to use functions such as to_string: 'a -&gt; string (for all 'a). The present solution focuses on being fully automatic, and providing the actual run-time type of values (including when it is more precise than the static type, because of polymorphism). On the other side, types are represented in an untyped way (no GADTs) and we only provide a minimal library for the purpose of the demonstration.</span>
<a name="e0ca9978210bd9433c604be02ebe358d"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=806"> Eliom 3.0</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">17 Dec 2012</span></span><span class="rss-description">With Eliom, you can implement client-server Web applications fully in OCaml. 
Client parts, delimited by a syntax extension, are automatically extracted 
from the application source code and compiled to Javascript using the 
Js_of_ocaml compiler.

Eliom also provides very powerful tools to implement classical Web sites, and 
makes it possible to mix usual Web interactions with advanced client side 
features.</span>
<a name="5b1590d3bf1ff54b87bf52ade842ac66"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/canswer/"> Canswer</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">11 Dec 2012</span></span><span class="rss-description">Canswer is an OCaml library allowing one to do certain rewriting. It is a support tool for the CQA (Certain Query Answering) research.</span>
<a name="a0653bd809a506d026a0c34a935de78d"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2012.12.11.html"> Caml Weekly News, 11 Dec 2012</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">11 Dec 2012</span></span><span class="rss-description">otags reloaded 4.00.1 for OCaml 4.00 / ocaml.org infrastructure list available / Js_of_ocaml 1.3 / GODI imports OASIS / Documenting the compiler / Ocsigen: Eliom 3 / Creating fresh OPAM repository / Other Caml News</span>
<a name="621e599503238029afb486f7f9bfd0b7"></a><span class="rss-header"><span class="rss-title"><a href="http://ocsigen.org/"> Ocsigen Eliom 3.0 released</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Ocsigen project</span>, <span class="rss-date">10 Dec 2012</span></span><span class="rss-description"><div id="post1"><p>
we are celebrating Ada's birthday by bringing out a major update of
Eliom - the advanced framework for client/server web applications in
OCaml - and some minor updates for Ocsigenserver and Tyxml.
</p>
<p>
Here is a list of major new features (and short code snippets can be
found at the end of this email):
</p>

<ul>
<li>The tightest integration of client value within the server code
   ever made possible in a major statically typed programming
   language [1]
   </li><li>
 Easy access to top-level server values - and (Lwt-)functions -
   from within the client code [2]
   </li><li>
 Access to other users' states of Eliom references
   </li><li>
 Improved support of Eliom's source files in the compilation tools
   eliom{c,opt,dep}
   </li><li>
 A new tool, eliom-destillery, for creating basic projects fast &amp;
   easy
 </li>
</ul>

<p>
The manual, a cheat-sheet, a comprehensive tutorial, and the
API-documentation of the various Ocsigen projects are available on
<a href="http://ocsigen.org">http://ocsigen.org</a>.
</p>
<a onclick="switchContent('post1','post2')" class="btn" href="#621e599503238029afb486f7f9bfd0b7">Read more...</a></div><div id="post2" style="display: none"><p>
we are celebrating Ada's birthday by bringing out a major update of
Eliom - the advanced framework for client/server web applications in
OCaml - and some minor updates for Ocsigenserver and Tyxml.
</p>
<p>
Here is a list of major new features (and short code snippets can be
found at the end of this email):
</p>

<ul>
<li>The tightest integration of client value within the server code
   ever made possible in a major statically typed programming
   language [1]
   </li><li>
 Easy access to top-level server values - and (Lwt-)functions -
   from within the client code [2]
   </li><li>
 Access to other users' states of Eliom references
   </li><li>
 Improved support of Eliom's source files in the compilation tools
   eliom{c,opt,dep}
   </li><li>
 A new tool, eliom-destillery, for creating basic projects fast &amp;
   easy
 </li>
</ul>

<p>
The manual, a cheat-sheet, a comprehensive tutorial, and the
API-documentation of the various Ocsigen projects are available on
<a href="http://ocsigen.org">http://ocsigen.org</a>.
</p>
<p>
The probably simplest and most generic way to install Eliom is by
using OPAM. But also Debian packages are already available (in
experimental, thanks Stéphane!), Gentoo-ebuilds are on their way, the
Ocsigen-bundle is still at hand, and the archives can be found at
<a href="http://ocsigen.org/eliom/install">http://ocsigen.org/eliom/install</a>.
</p>
<p>
And maybe you may want to become social with us on
</p>
<ul>
<li>
<a href="https://twitter.com/ocsigen">Twitter</a>
</li>
<li>
<a href="https://plus.google.com/u/0/105890612060116987398/posts">Google +</a>
</li>
<li>
<a href="https://www.facebook.com/pages/Ocsigen/289974521051526">Facebook</a>
</li>
</ul>

<p>
Enjoy!
</p>
<p>
-- The Ocsigen-team
</p>

<pre>[1]
{server{ (* This marks server-side code *)
  let value_history_on_client =
    {ref string{ ref [] }} (* A client value within the server code *)
  let _ = My_app.register_service ~path ~get_params
    (fun value () -&gt;
      (* Push the GET parameter to the client's history a side effect *)
      ignore {unit{
        %value_history_on_client := %value :: ! %value_history_on_client
      }};
      Lwt.return html)
}}

[2]
{server{
  let f = server_function Json.t&lt;string&gt;
    (fun x -&gt; Printf.eprintf "Client says: %s\n%!" x; Lwt.return ())
}}
{client{ (* This marks client-side code *)
  (* %f makes the server's value f, a client-ready server function,
     available in the client code *)
  ... %f "hello!" ...
}}
</pre><a onclick="switchContent('post2','post1')" class="btn" href="#621e599503238029afb486f7f9bfd0b7">Hide</a></div></span>
<a name="e93970411baf98fb039a1ccbbf0b5954"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/~scherer/gagallium/verifying-a-parser-for-a-c-compiler-2"> Verifying a parser for a C compiler (continued)</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">07 Dec 2012</span></span><span class="rss-description"><div id="post3"><p>In
  my <a href="http://gallium.inria.fr/~scherer/gagallium/verifying-a-parser-for-a-c-compiler/">last
  post</a>, I explained my work on verifying a parser for
  Compcert. I was mainly explaining the solutions I found to my
  performances problems. Here, I will discuss an other interesting
  problem I have, concerning the context sensitivity of the C99
  grammar.</p>



<h2>An alternative to the lexer hack</h2>

<p>The &lt;emph&gt;lexer hack&lt;/emph&gt; is the typical solution to the problem
  of context sensitivity of the C grammar outlined in
  the <a href="http://gallium.inria.fr/~scherer/gagallium/verifying-a-parser-for-a-c-compiler/">previous
  blog article</a> and explained more in depth
  in <a href="http://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-c%E2%80%99s-grammar-revisited/">this
  external blog article</a>. It cannot be implemented in our parser,
  because it uses some side effect in the semantic actions of the
  grammar in order to give some information to the lexer, and, as you
  might know, side effects are forbidden in Coq.</p>

<a onclick="switchContent('post3','post4')" class="btn" href="#e93970411baf98fb039a1ccbbf0b5954">Read more...</a></div><div id="post4" style="display: none"><p>In
  my <a href="http://gallium.inria.fr/~scherer/gagallium/verifying-a-parser-for-a-c-compiler/">last
  post</a>, I explained my work on verifying a parser for
  Compcert. I was mainly explaining the solutions I found to my
  performances problems. Here, I will discuss an other interesting
  problem I have, concerning the context sensitivity of the C99
  grammar.</p>



<h2>An alternative to the lexer hack</h2>

<p>The &lt;emph&gt;lexer hack&lt;/emph&gt; is the typical solution to the problem
  of context sensitivity of the C grammar outlined in
  the <a href="http://gallium.inria.fr/~scherer/gagallium/verifying-a-parser-for-a-c-compiler/">previous
  blog article</a> and explained more in depth
  in <a href="http://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-c%E2%80%99s-grammar-revisited/">this
  external blog article</a>. It cannot be implemented in our parser,
  because it uses some side effect in the semantic actions of the
  grammar in order to give some information to the lexer, and, as you
  might know, side effects are forbidden in Coq.</p>

<p>Any Haskell programmer would say that the solution is to use a
  state monad, but both the semantic actions described in the grammar
  and the lexer would need to compute in this monad, in order to
  communicate with each other. Then, it becomes very hard to specify
  what is a valid semantic value for a token sequence, because one has
  to specify how the lexer and the parser semantic actions
  interleaves. This becomes a real nightmare when you allow the parser
  to ask the lexer for a lookahead token before deciding to call some
  semantic action...</p>

<p>So it is necessary to find another approach. After some thoughts,
  I remembered the parsing approach of &lt;emph&gt;mixfix operators&lt;/emph&gt;
  in the Agda programming language, advertized in Gallium by our own
  Agda expert <a href="http://nicolaspouillard.fr/">Nicolas
  Pouillard</a>. Mixfix operators are syntactic constructions that can
  be created dynamically: this is comparable to
  the <code>Notation</code> command of Coq. The way they are handled
  in Agda is described
  in <a href="http://www.cse.chalmers.se/~nad/publications/danielsson-norell-mixfix.pdf">this
  paper</a>. Roughly, the parser only analyzes the main structure of
  the file. The expressions are not analyzed at this point: they are
  left at the state of list of tokens. At a later stage of processing,
  an other module uses the extra context information it knows (notably
  the mixfix operators available) to parse expressions. This new
  information is obtained from the first parsing phase, which brings
  enough structure to go on.</p>

<p>Here, the situation is very similar: we need some more context
  information (whether a given identifier is a type or a variable
  name) in order to parse expressions and declarations. We can use a
  similar technique: if the parser is not able to parse those,
  then it should store them as a list of tokens in the abstract syntax
  tree. A second pass in then necessary to parse those "chunks"
  correctly. Recursively, this second pass can delay parsing for
  smaller chunks, and so on.</p>

<p>Obviously, I have omitted some details here. First, it requires
  some serious engineering on the C99 grammar in order to separate it
  into a "safe" part, where the extra information given by the context
  is not needed, and a "dangerous" part, where the parser needs that
  the two different flavors of identifiers (type names and variable
  names) are represented by two different tokens. Second, recognizing
  the end of these chunks without actually parsing them requires
  recognizing some patterns, typically like matching parentheses.</p>

<h2>Avoiding polluting the AST with chunks</h2>

<p>Storing chunks in the abstract syntax tree has a major drawback: it
  requires adding some constructors in its types for those chunks,
  which do not have any real sense in the language. The solution I use
  instead is to make all my semantic actions compute in a state
  monad, which passes the contextual environment information: while
  parsing, the semantic actions build the syntax tree in the form of
  a tree of closures. Once something has been parsed, the caller gives
  the initial environment as a parameter to the head closure, and the
  environment information propagates along the tree.</p>

<p>When there is a chunk in some node of the AST, the corresponding
  semantic action first uses the environment information to convert
  identifier tokens to their right flavor, then recursively parses the
  chunk, and finally gives the current environment to the returned
  semantic value, so that it can itself evaluate.</p>

<p>This monad is a bit more complicated than a simple state monad,
  because it also handles error (nested parsing can fail), and open
  recursion (the parser has to call itself, when it is not already
  defined).</p>

<h2>Conclusion</h2>

<p><a href="http://gallium.inria.fr/~scherer/gagallium/Parser.vy.html">Here</a> is a working version of the
  parser, using those ideas. A bit surprisingly, using all this monad
  machinery and delaying parsing does not decrease the performances
  too much. I have still some troubles proving it, and I'm looking
  forward to ideas to state all the invariants in a not-too-verbose
  way.</p>

<p>This work is still in progress, so I would be happy if you could
  give me your comments or ideas. But, in any case, I am now
  convinced that it is really possible to have a formalization of a
  parser for the C language, and particularly for the lexer hack. And
  this is a good thing, because, as its name suggest, the lexer hack
  is a hack, whose correctness is far from clear.</p>

<p>I have to say that, even if this work of proving a parser for
  a C compiler is sometimes quite tiresome, it allowed me to learn
  things in many different domains, from designing powerful automaton
  tactics in Coq to OCaml code optimization and LR(1)
  hackery: it's been a very challenging and rewarding experience.</p>

<p>If I wanted to work on that again in the future, there is still
  many things one would want to prove: does the parser terminates on
  all inputs? Are we sure it does not ask for a lookahead token after
  the end of the stream (that could be a problem in interactive
  languages, because it could block the input)?</p><a onclick="switchContent('post4','post3')" class="btn" href="#e93970411baf98fb039a1ccbbf0b5954">Hide</a></div></span>
<a name="3736a0b8afed70ff31acacf3b9c5fa8e"></a><span class="rss-header"><span class="rss-title"><a href="http://ocsigen.org/"> Ocsigen Js_of_ocaml 1.3 released</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Ocsigen project</span>, <span class="rss-date">06 Dec 2012</span></span><span class="rss-description"><div id="post5"><p>I'm happy to announce release 1.3 of Js_of_ocaml, a compiler from
OCaml bytecode to Javascript. This release is compatible with OCaml
4.x. It adds WebSocket bindings and fixes a number of bugs.
</p>

<h2>Links</h2>

<ul>
<li><a href="http://ocsigen.org/js_of_ocaml/">Project home page</a>
</li><li><a href="http://ocsigen.org/download/js_of_ocaml-1.3.1.tar.gz">Download</a>
</li><li>Get source code: <code>darcs get http://ocsigen.org/darcs/js_of_ocaml/</code>
</li><li><a href="http://ocsigen.org/js_of_ocaml/manual/">Documentation</a>
</li>
</ul>

<h2>Changes</h2>

<h3>Features/Changes</h3>
<ul>
<li>Runtime and toplevel updates to support OCaml 4.0
</li><li>Add WebSocket bindings
</li><li>Added -debuginfo option to output source code location information
    (patch by Kensuke Matsuzaki)
</li><li>Dom_html: added change, input and hashChange event bindings
</li>
</ul>

<h3>Bugfixes</h3>
<a onclick="switchContent('post5','post6')" class="btn" href="#3736a0b8afed70ff31acacf3b9c5fa8e">Read more...</a></div><div id="post6" style="display: none"><p>I'm happy to announce release 1.3 of Js_of_ocaml, a compiler from
OCaml bytecode to Javascript. This release is compatible with OCaml
4.x. It adds WebSocket bindings and fixes a number of bugs.
</p>

<h2>Links</h2>

<ul>
<li><a href="http://ocsigen.org/js_of_ocaml/">Project home page</a>
</li><li><a href="http://ocsigen.org/download/js_of_ocaml-1.3.1.tar.gz">Download</a>
</li><li>Get source code: <code>darcs get http://ocsigen.org/darcs/js_of_ocaml/</code>
</li><li><a href="http://ocsigen.org/js_of_ocaml/manual/">Documentation</a>
</li>
</ul>

<h2>Changes</h2>

<h3>Features/Changes</h3>
<ul>
<li>Runtime and toplevel updates to support OCaml 4.0
</li><li>Add WebSocket bindings
</li><li>Added -debuginfo option to output source code location information
    (patch by Kensuke Matsuzaki)
</li><li>Dom_html: added change, input and hashChange event bindings
</li>
</ul>

<h3>Bugfixes</h3>
<ul>
<li>Fix array and string blitting with overlapping regions
</li><li>Url module: fix encoding of '+'
</li><li>Library: use 'this' instead of 'window' for better portability
</li><li>Dom_html: fix creation of elements with type or name attribute
    under IE 9
</li><li>Compiler: small fix to bytecode parsing that could result in
    incorrect generated code
</li><li>Dom_html: fix mouse wheel event bindings
</li><li>Dom: fix the type of item methods
</li><li>Deriving_json: tail-recursive serialisation of lists (by Hugo Heuzard)
</li><li>Deriving_json: fix parsing of float arrays and polymorphic variants
    (by Hugo Heuzard)
</li>
</ul>
<p>
-- Jérôme Vouillon
</p>
<p>
To get more frequent annoucements about Ocsigen, follow us on 
<a href="https://twitter.com/ocsigen">Twitter</a>,
<a href="https://plus.google.com/u/0/105890612060116987398/posts">Google+</a>, or
<a href="https://www.facebook.com/pages/Ocsigen/289974521051526">Facebook</a>.</p><a onclick="switchContent('post6','post5')" class="btn" href="#3736a0b8afed70ff31acacf3b9c5fa8e">Hide</a></div></span>
<a name="91a7e575dadea383e3e05bf91d65d03b"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/~scherer/gagallium/your-first-coq-plugin"> Emancipate yourself from LTac: Your first Coq plugin</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">05 Dec 2012</span></span><span class="rss-description"><div id="post7"><p>I recently started a post-doc in the Gallium team, and it is past
due-time for my first blog post. I will not start with a research
oriented blog right now (but stay tuned!); and I will rather talk
about one of my hobbies: writing Coq plugins in OCaml to build new
tactics. I reckon that this deviates a bit from standard practice, so
I will try to make things clear.</p>




<p>First, a Coq proof script is usually a program written in
<em>LTac</em>. Executing a proof script builds incrementally a
<em>proof-term</em>. The tactics themselves are not trusted: at <code>Qed</code> time, Coq
checks that the proof term that was built is well-typed and that its
type is the same as the statement of the theorem. One must remember
that LTac tactics can always be understood in terms of manipulations
of partial proof terms; and it is often instructive to get an idea of
the proof term that is being built, using the <code>Show Proof</code> vernacular
command.</p>

<a onclick="switchContent('post7','post8')" class="btn" href="#91a7e575dadea383e3e05bf91d65d03b">Read more...</a></div><div id="post8" style="display: none"><p>I recently started a post-doc in the Gallium team, and it is past
due-time for my first blog post. I will not start with a research
oriented blog right now (but stay tuned!); and I will rather talk
about one of my hobbies: writing Coq plugins in OCaml to build new
tactics. I reckon that this deviates a bit from standard practice, so
I will try to make things clear.</p>




<p>First, a Coq proof script is usually a program written in
<em>LTac</em>. Executing a proof script builds incrementally a
<em>proof-term</em>. The tactics themselves are not trusted: at <code>Qed</code> time, Coq
checks that the proof term that was built is well-typed and that its
type is the same as the statement of the theorem. One must remember
that LTac tactics can always be understood in terms of manipulations
of partial proof terms; and it is often instructive to get an idea of
the proof term that is being built, using the <code>Show Proof</code> vernacular
command.</p>

<p>Usually, one build new tactics in LTac. LTac is a powerful
domain-specific language with some interesting programming constructs,
and it is possible to build powerful new tactics using a few
combinators and leveraging the existing automation (builtin tactics,
decision procedures and so on). I have read that LTac is vindicated as
one of the <a href="http://adam.chlipala.net/cpdt/html/Intro.html">strong points of
Coq</a>, and part of me agree with that statement: there is a lot of
use cases in which LTac is a good tool.  Yet, writing a LTac tactic
is often tedious, the code that needs to be written is hard to debug,
and it may be quite inefficient.</p>

<p>The alternative is to write custom tactics in OCaml, the meta-language
that is used to implement Coq (and all the primitive tactics). In the
following, I will demonstrate how to write such a tactic, and give you
a handful of the necessary entry points into Coq's code.</p>

<p>The tactic that we are going to code is the following one, shamefully
stolen from Compcert's code.</p>

<pre class="code-"><span class="hl kwd">Lemma</span> modusponens<span class="hl opt">:</span> forall <span class="hl opt">(</span><span class="hl kwd">P Q</span><span class="hl opt">:</span> <span class="hl kwd">Prop</span><span class="hl opt">),</span> <span class="hl kwd">P</span> <span class="hl opt">-&gt; (</span><span class="hl kwd">P</span> <span class="hl opt">-&gt;</span> <span class="hl kwd">Q</span><span class="hl opt">) -&gt;</span> <span class="hl kwc">Q</span><span class="hl opt">.</span>
<span class="hl kwc">Proof</span><span class="hl opt">.</span> auto<span class="hl opt">.</span> <span class="hl kwc">Qed</span><span class="hl opt">.</span>

<span class="hl kwd">Ltac</span> exploit x <span class="hl opt">:=</span>
   refine <span class="hl opt">(</span>modusponens _ _ <span class="hl opt">(</span>x _ _ _ _ _ _ _ _ _ _ _<span class="hl opt">)</span> _<span class="hl opt">)</span>
|| refine <span class="hl opt">(</span>modusponens _ _ <span class="hl opt">(</span>x _ _ _ _ _ _ _ _ _ _<span class="hl opt">)</span> _<span class="hl opt">)</span>
<span class="hl com">(* Lots of lines elided.  The actual code handle cases upto </span>
<span class="hl com">  35 arguments *)</span>
|| refine <span class="hl opt">(</span>modusponens _ _ <span class="hl opt">(</span>x _ _ _<span class="hl opt">)</span> _<span class="hl opt">)</span>
|| refine <span class="hl opt">(</span>modusponens _ _ <span class="hl opt">(</span>x _ _<span class="hl opt">)</span> _<span class="hl opt">)</span>
|| refine <span class="hl opt">(</span>modusponens _ _ <span class="hl opt">(</span>x _<span class="hl opt">)</span> _<span class="hl opt">).</span>
</pre>

<p>What does <code>exploit</code> do ? Well, the best thing is to give an
example. In the following context, </p>

<pre class="code-"><span class="hl kwd">A</span><span class="hl opt">,</span> <span class="hl kwd">B</span><span class="hl opt">,</span> <span class="hl kwd">C</span><span class="hl opt">,</span> <span class="hl kwd">D</span><span class="hl opt">,</span> <span class="hl kwd">G</span> <span class="hl opt">:</span> <span class="hl kwd">Prop</span>
<span class="hl kwd">H</span> <span class="hl opt">:</span> <span class="hl kwd">A</span> <span class="hl opt">-&gt;</span> <span class="hl kwd">B</span> <span class="hl opt">-&gt;</span> <span class="hl kwd">C</span> <span class="hl opt">-&gt;</span> <span class="hl kwd">D</span>
<span class="hl opt">============================</span>
<span class="hl kwd">G</span>
</pre>

<p><code>exploit H</code> will produce four sub-goals in which the user needs to
prove <code>A</code>, <code>B</code>, <code>C</code>, and <code>D -&gt; G</code>. That is, the <code>exploit</code>
tactic is a generalized version of the modus-ponens.</p>

<p>This tactic has two drawbacks. First, it is a bit inefficient: it
tries to apply the <code>modusponens</code> theorem to <code>x</code> applied to a
decreasing number of arguments (obviously we do not want to get two
subgoals <code>A</code> and <code>(B -&gt; C -&gt; D) -&gt; G</code>). Yet, this is a pity, because
most of the time, the right application has a low number of arguments,
and the execution of <code>exploit</code> must go through twenty-something
failures before reaching a successful of <code>refine</code>. The second drawback
is that one has to repeat by hand the same pattern (<code>x</code> followed by a
given number of holes), to handle all reasonable use-cases of the
tactic. </p>

<p>Now, we probably could imagine other (LTac) implementations of exploit,
but it is not the point of this article, and you should definitely not
try to do that at home! What we will do is implement this tactic as 9
lines long tactic in an OCaml plugin, way shorter than the LTac implementation.</p>

<p>Here we go. </p>

<pre class="code-ocaml"> 
<span class="hl kwa">let</span> exploit <span class="hl opt">(</span>c<span class="hl opt">:</span> <span class="hl kwd">Term</span><span class="hl opt">.</span>constr<span class="hl opt">) =</span> <span class="hl kwa">fun</span> gl <span class="hl opt">-&gt;</span>  
<span class="hl com">(* the type of [c] is [ty] *)</span>
<span class="hl kwa">let</span> ty <span class="hl opt">=</span> <span class="hl kwd">Tacmach</span><span class="hl opt">.</span>pf_type_of gl c <span class="hl kwa">in</span> 

<span class="hl com">(* In the general case, [ty] can be written as [forall (x1:t1)</span>
<span class="hl com">... (xn:tn), t]. We decompose this arity in two parts: [ctx] which</span>
<span class="hl com">is [(xn, tn); ...; (x1,t1)] and the conclusion [t] *)</span>
<span class="hl kwa">let</span> ctx<span class="hl opt">,</span> t <span class="hl opt">=</span> <span class="hl kwd">Term</span><span class="hl opt">.</span>decompose_prod_assum ty <span class="hl kwa">in</span>

<span class="hl com">(* We will also need the type of the conclusion of the goal *)</span>
<span class="hl kwa">let</span> concl <span class="hl opt">=</span> <span class="hl kwd">Tacmach</span><span class="hl opt">.</span>pf_concl gl <span class="hl kwa">in</span> 
</pre>

<p>We encounter functions from two modules here:</p>

<ul>
<li><p><code>coq-v8.4/kernel/term.ml</code> contains the definition of Coq terms, the
<code>constr</code> data-type, and various operations on it. For instance,
<code>decompose_prod_assum</code> takes as arguments a <code>constr</code> and decomposes
it into two parts: a telescope of products (that is, a context
<code>cxt</code>), and the final type <code>t</code>. At this point, it is crucial to note
that this manipulation of terms is very syntactic: the term <code>t</code> may
contain de Bruijn indices that refers to variables bound in the
context. Therefore, we shall manipulate <code>t</code> with some care and not
forget to, e.g., lift it when needed.</p></li>
<li><p><code>coq-v8.4/proofs/tacmach.ml</code> contains the API that I use most often
to interact with the proof machinery. For instance, <code>pf_type_of</code>
takes as argument the current proof environment (that is, the goal,
the typing context, and so on) and a <code>constr</code>, and returns its coq
type. The function <code>pf_concl</code> returns the conclusion of the current
goal.</p></li>
</ul>

<p>All in all, the above snippet is quite straightforward: get the type of
the argument of the tactic, and the conclusion of the current
goal. Nothing fancy, but here comes the meaty stuff. </p>

<p>Recall that a tactic builds a partial proof-term, which is a regular
Coq term. Here, the proof-term that we want to generate is </p>

<pre class="code-"><span class="hl opt">(</span><span class="hl kwa">fun</span> <span class="hl opt">(</span>x1<span class="hl opt">:</span>t1<span class="hl opt">) ... (</span>xn<span class="hl opt">:</span>tn<span class="hl opt">) (</span>m <span class="hl opt">:</span> t <span class="hl opt">-&gt;</span> concl<span class="hl opt">) =&gt;</span> m <span class="hl opt">(</span>c x1 <span class="hl opt">...</span> xn<span class="hl opt">))</span> 
</pre>

<p>(intuitively, if we were to <code>apply</code> this term in Coq, we would get a
sub-goal for each of the arguments of the function)</p>

<pre class="code-ocaml"><span class="hl kwa">let</span> pf_body <span class="hl opt">=</span>
  <span class="hl kwd">Term</span><span class="hl opt">.</span>mkApp <span class="hl opt">(</span><span class="hl kwd">Term</span><span class="hl opt">.</span>mkRel <span class="hl num">1</span><span class="hl opt">,</span>
              <span class="hl opt">[</span>| <span class="hl kwd">Term</span><span class="hl opt">.</span>mkApp <span class="hl opt">(</span>c<span class="hl opt">,</span> <span class="hl kwd">Termops</span><span class="hl opt">.</span>extended_rel_vect <span class="hl num">1</span> ctx<span class="hl opt">)</span> |<span class="hl opt">])</span>
</pre>

<p>The term <code>pf_body</code> corresponds to the internal representation of the
above <code>m (c x1 ... xn)</code>.  As should be obvious with their names, the
function <code>Term.mkApp</code> builds an application, and <code>Term.mkRel</code> builds a
term that is a de Bruijn index that points to the nearest binder. The
function <code>Termops.extended_rel_vect</code> is slightly more complicated: it
builds a vector of de Bruijn indices, lifted by 1. </p>

<p>Now, we need to build the <code>fun</code> part. We build exactly one <code>lambda</code>
for each product that occurred in the type of the term <code>c</code>, plus one
for the parameter of type <code>t -&gt; concl</code>. To do so, we simply extend the
former context with a new definition.  (Note here that the type <code>t</code>
may depend on the context <code>ctx</code>. Yet, there is no need to lift <code>t</code>,
because it is used in the exact same context as before; and <code>concl</code>
should be a closed term.)</p>

<pre class="code-ocaml"><span class="hl kwa">let</span> ctx <span class="hl opt">= (</span><span class="hl kwd">Names</span><span class="hl opt">.</span><span class="hl kwd">Anonymous</span><span class="hl opt">,</span><span class="hl kwd">None</span><span class="hl opt">,</span> <span class="hl kwd">Term</span><span class="hl opt">.</span>mkArrow t concl <span class="hl opt">) ::</span> ctx <span class="hl kwa">in</span> 
<span class="hl kwa">let</span> pf_term <span class="hl opt">=</span> <span class="hl kwd">Term</span><span class="hl opt">.</span>it_mkLambda_or_LetIn pf_body ctx <span class="hl kwa">in</span>
</pre>

<p>The function <code>Term.it_mkLambda_or_LetIn</code> iterates the function that
creates a lambda, for each of the elements of the context
<code>ctx</code>. Finally, we can call the built-in <code>apply</code> tactics to finish the
job. </p>

<pre class="code-ocaml"><span class="hl kwd">Tactics</span><span class="hl opt">.</span>apply pf_term gl
</pre>

<p>There is one wrinkle here: with my version of Coq, the sub-goals that
are generated are not in the same order as with the LTac version
(which is a problem if we have to deal with backward compatibility of
proof-scripts). More precisely, the proof obligation that corresponds
to <code>t -&amp;gt; concl</code> comes first. In order to avoid this problem, we will
rely on a slightly more arcane piece of code.</p>

<pre class="code-ocaml"><span class="hl kwd">Tactics</span><span class="hl opt">.</span>apply_term
  pf_term <span class="hl opt">(</span><span class="hl kwd">List</span><span class="hl opt">.</span>map <span class="hl opt">(</span><span class="hl kwa">fun</span> _ <span class="hl opt">-&gt;</span> <span class="hl kwd">Evarutil</span><span class="hl opt">.</span>mk_new_meta <span class="hl opt">())</span> ctx<span class="hl opt">)</span> gl
</pre>

<p>The function <code>apply_term</code> seems to be a variant of apply to which we
give a term, and a list of arguments to which the term is
applied. Here, we provide as arguments a bunch of <code>_</code> (in the same
fashion as we would have done for <code>refine</code>). For a reason that I do
not fully grasp, this gives us exactly the same sub-goals as the above
LTac <code>exploit</code>.</p>

<p>The last line of our OCaml plugin enrichs Coq's tactic environments
with our new tactic. This declaration is made of three parts: a unique
identifier <code>foobar</code> (that is used internally by Coq), the syntax
extension, and the actual OCaml code of the tactic (here, we simply
wrap a call to <code>exploit</code>):</p>

<pre class="code-ocaml"><span class="hl kwd">TACTIC EXTEND</span> foobar
  | <span class="hl opt">[</span><span class="hl str">"exploit"</span> constr<span class="hl opt">(</span>c<span class="hl opt">)] -&gt; [</span>exploit c<span class="hl opt">]</span>
<span class="hl kwd">END</span><span class="hl opt">;;</span>
</pre>

<p>And that's it: mission accomplished. </p>

<p>There is one extra benefit to our brand new implementation of
<code>exploit</code>: the former version was not working properly if it was given
a theorem of type, e.g., <code>A -&gt; B -&gt; ~C</code>. Let <code>D</code> be the goal, the
sub-goals that were generated were <code>A</code>, <code>B</code>, <code>C</code> and <code>False -&gt; D</code>.
This short-coming is solved with our new implementation.  </p>

<p>In the end, our new tactic is 9 lines long, compared to 20 something
repetitions of the same pattern in the LTac implementation. (To be
honest, we omit on this 9 lines count a few lines of boilerplate that
must be written for each new OCaml tactic, like the makefile
that is needed to compile the plugin.)</p>

<p>Moving to OCaml, we lost the safety-belt that is provided by LTac: for
instance, it is possible to get the de Bruijn indices wrong by one
when we build a proof-term. But it gives us the full power of the best
programming language ever ;) to build our new tactics. </p>

<p>The plugin that was build in this tutorial is available from the
public GitHub repository <a href="https://github.com/braibant/exploit-plugin">here</a>. From the
root of the repository</p>

<pre class="code-txt">make
make -f Makefile.coq install
</pre>

<p>should install the plugin in your Coq plugins directory. Then, it
suffices to use the vernacular 
&lt;coq&gt;
Require Exploit.
&lt;/coq&gt;
to be able to use the <code>exploit</code> tactic, from any coq development. </p><a onclick="switchContent('post8','post7')" class="btn" href="#91a7e575dadea383e3e05bf91d65d03b">Hide</a></div></span>
<script type="text/javascript">function switchContent(id1,id2) {
     // Get the DOM reference
     var contentId1 = document.getElementById(id1);
     var contentId2 = document.getElementById(id2);
     // Toggle
     contentId1.style.display = "none";
     contentId2.style.display = "block";
     }</script></div>

  
    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
</body></html>
