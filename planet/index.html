<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: OCaml Planet</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contributors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="OCaml Planet" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it Online</a></li>
    <li><a href="../taste.html">100 Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who Is Using It?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a>
        <a href="http://langref.org/ocaml">langref.org</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
    <li><a href="../papers.html">Papers</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../releases/latest.html">Releases</a></li>
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development Tools</a></li>
    <li><a href="../books.html#manual">User Manual</a></li>
    <li><a href="../cheat_sheets.html">Cheat Sheets</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API Search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">GitHub</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing Lists</a></li>
    <li><a href="../planet/">Blogs</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>OCaml Planet
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

    <h1>OCaml Planet</h1>

    <p>The OCaml Planet aggregates various blogs from the OCaml
    community.  It is kindly provided
    by <a href="http://www.ocamlcore.com/">OCamlCore</a>.  If you
    would like to be added, read
    the <a href="http://www.ocamlcore.org/planet/">Planet
    subscription HOWTO</a>.</p>

    <br/>
    <div style="float: right; margin-right: 0; margin-top: 0" class="span2 planet-subscriptions"><em>Subscriptions</em>
      <ul><li><a href="http://alexleighton.tumblr.com/tagged/ocaml/rss">Alex Leighton</a></li><li><a href="http://blog.mestan.fr/feed/?cat=16">Alp Mestan</a></li><li><a href="http://andreiformiga.com/blog/?cat=5&feed=rss2">Andrei Formiga</a></li><li><a href="http://math.andrej.com/feed/">Andrej Bauer</a></li><li><a href="http://anil.recoil.org/feeds/atom.xml">Anil Madhavapeddy</a></li><li><a href="http://unnali.com/tag/ocaml/feed/">Arlen Cuss</a></li><li><a href="http://ashishagarwal.org/tag/ocaml/feed/">Ashish Agarwal</a></li><li><a href="http://www.blogger.com/feeds/7617521785419311079/posts/default">Cameleon news</a></li><li><a href="http://caml.inria.fr/news.en.rss">Caml INRIA</a></li><li><a href="http://camlspotter.blogspot.com/feeds/posts/default?alt=rss">Caml Spotting</a></li><li><a href="http://alan.petitepomme.net/cwn/cwn.rss">Caml Weekly News</a></li><li><a href="http://procrastiblog.com/category/ocaml/feed/">Christopher Conway</a></li><li><a href="http://coherentpdf.com/blog/?tag=ocaml&feed=rss">Coherent Graphics</a></li><li><a href="http://coq.inria.fr/news/feed">Coq</a></li><li><a href="http://erratique.ch/feeds/news.atom">Daniel Bünzli</a></li><li><a href="http://blog.dbpatterson.com/rss">Daniel Patterson</a></li><li><a href="http://nleyten.com/atom.aspx">Dario Teixeira</a></li><li><a href="http://www.blogger.com/feeds/17133288/posts/default/-/ocaml">David Baelde</a></li><li><a href="http://bentobako.org/david/blog/index.php?feed/tag/ocaml/atom">David Mentré</a></li><li><a href="http://dutherenverseauborddelatable.wordpress.com/category/ocaml/feed/">David Teller</a></li><li><a href="http://www.examachine.net/blog/?feed=rss2&cat=4">Eray Özkural</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/CodeHacking/Ocaml/index.rss20">Erik de Castro Lopo</a></li><li><a href="http://blog.emillon.org/feeds/ocaml.xml">Etienne Millon</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/FP-Syd/index.rss20">FP-Sydney</a></li><li><a href="http://www.blogger.com/feeds/8964007124326996693/posts/default/-/ocaml">Fayssal Martani</a></li><li><a href="http://frama-c.com/rss.xml">Frama-C</a></li><li><a href="http://functionaljobs.com/jobs/search/?q=ocaml&format=rss">Functional Jobs</a></li><li><a href="http://gallium.inria.fr/~scherer/gagallium/index.rss">GaGallium</a></li><li><a href="http://gaiustech.wordpress.com/category/ocaml/feed/">Gaius Hammond</a></li><li><a href="http://blog.camlcity.org/blog/rss">Gerd Stolpmann</a></li><li><a href="http://www.wisdomandwonder.com/tag/OCaml/feed">Grant Rettke</a></li><li><a href="http://blog.incubaid.com/tag/ocaml/feed/">Incubaid Research</a></li><li><a href="http://ambassadortothecomputers.blogspot.com/feeds/posts/default?alt=rss">Jake Donham</a></li><li><a href="http://scattered-thoughts.net/rss?tag=ocaml">Jamie Brandon</a></li><li><a href="http://ocaml.janestcapital.com/?q=rss.xml">Jane Street</a></li><li><a href="http://www.lexifi.com/blogs/ocaml/feed">LexiFi</a></li><li><a href="http://savonet.sourceforge.net/liquidsoap.rss">Liquidsoap</a></li><li><a href="http://syntaxexclamation.wordpress.com/tag/ocaml/feed/">Matthias Puech</a></li><li><a href="http://www.blogger.com/feeds/5888658295182480819/posts/default">Matías Giovannini</a></li><li><a href="http://eigenclass.org/R2/feeds/rss2/all">Mauricio Fernandez</a></li><li><a href="http://www.elehack.net/michael/blog/tags/ocaml?format=rss">Michael Ekstrand</a></li><li><a href="http://www.rktmb.org:82/feed/category/work/ocaml/atom">Mihamina Rakotomandimby</a></li><li><a href="http://mcclurmc.wordpress.com/feed/">Mike McClurg</a></li><li><a href="http://nyc-ocaml.posterous.com/rss.xml">NYC OCaml</a></li><li><a href="http://ocamlhackers.ning.com/profiles/blog/feed?tag=ocaml&xn_auth=no">OCaml Hackers</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfnews.php">OCamlCore Forge News</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfprojects.php">OCamlCore Forge Projects</a></li><li><a href="http://www.ocamlcore.com/wp/?feed=rss2&amp;language=en&#038;language=en">OCamlCore.com</a></li><li><a href="http://www.ocamlpro.com/feed/atom.xml">OCamlPro</a></li><li><a href="http://odns.tuxfamily.org/feed/">ODNS project</a></li><li><a href="http://ox.tuxfamily.org/feed/">Ocaml XMPP project</a></li><li><a href="http://ocsigen.org/news.atom">Ocsigen project</a></li><li><a href="http://www.blogger.com/feeds/2073503406800427577/posts/default">Opa</a></li><li><a href="http://www.openmirage.org/blog/atom.xml">Open Mirage</a></li><li><a href="http://functional-orbitz.blogspot.com/feeds/posts/default/-/planetocaml?alt=rss">Orbitz</a></li><li><a href="http://www.donadeo.net/facets/programming-languages/objective-caml/feed/">Paolo Donadeo</a></li><li><a href="https://mancoosi.org/~abate/taxonomy/term/5/0/feed">Pietro Abate</a></li><li><a href="http://redlizards.com/blog/feed/?tag=ocaml">Red Lizard Software</a></li><li><a href="http://rwmj.wordpress.com/tag/ocaml/feed/">Richard Jones</a></li><li><a href="http://blog.rastageeks.org/spip.php?page=rss&id_mot=2">Romain Beauxis</a></li><li><a href="http://seb.mondet.org/blog/feed/ocaml.rss">Sebastien Mondet</a></li><li><a href="http://upsilon.cc/~zack/tags/ocaml/index.rss">Stefano Zacchiroli</a></li><li><a href="http://le-gall.net/sylvain+violaine/blog/index.php?feed/tag/ocaml/atom">Sylvain Le Gall</a></li><li><a href="http://caml.inria.fr/hump.rss">The Caml Humps</a></li><li><a href="http://www.blogger.com/feeds/6115529230232389198/posts/default">Till Varoquaux</a></li><li><a href="http://www.nicollet.net/toroidal/ocaml/feed/">Victor Nicollet</a></li><li><a href="http://y-node.com/blog/feeds/tag/ocaml/">y-node</a></li></ul>

      <a href="http://planet.ocaml.org/rss20.xml"><img src=".././img/rss20.png"/></a>
      <a href="http://planet.ocaml.org/opml.xml"><img src=".././img/opml.png"/></a>
    </div>
    <div class="planet"><a name="3334b47d818f5851b16fb17012df1bd2"></a><span class="rss-header"><span class="rss-title"><a href="http://www.lexifi.com/blog/static-exceptions"> Static exceptions</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">LexiFi</span>, <span class="rss-date">11 Jan 2013</span></span><span class="rss-description"><div class="content-wide-padding white-bg light-grey-border">
<p>
  In this post, I propose Static Exceptions as a new language feature
  allowing programmers to express interesting control flows in a
  compact way.
</p></div><p><a href="http://www.lexifi.com/blog/static-exceptions" target="_blank">read more</a></p></span>
<a name="fefc7d1a5e469089727c2abf979df4b3"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/blog/introduction-to-mezzo"> Introduction to Mezzo</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">11 Jan 2013</span></span><span class="rss-description"><div id="post1"><p>Some of you may have heard about it already: this blog post is about a new programming language that's being designed right there at Gallium, codenamed <em><strong>Mezzo</strong></em>.</p>
<p>Designing a new programming language is nothing out of the extraordinary: many students in our research area do it for a living, and I'm no exception. I've been doing the traveling salesman, running presentations of Mezzo all over the place: Texas, New York, and going even as far as <em>Plateau de Saclay</em>. Now is the time for a blog post.</p>
<p><em><strong>Mezzo</strong></em> is a joint work between François Pottier, my advisor, and myself. Recently, Thibaut Balabonski joined our team as a post-doctoral researcher to work on the concurrent aspects of the language; we also had an undergrad intern, Henri Chataing, work on the compilation part of the project.</p>
<a onclick="switchContent('post1','post2')" class="btn" href="#fefc7d1a5e469089727c2abf979df4b3">Read more...</a></div><div id="post2" style="display: none"><p>Some of you may have heard about it already: this blog post is about a new programming language that's being designed right there at Gallium, codenamed <em><strong>Mezzo</strong></em>.</p>
<p>Designing a new programming language is nothing out of the extraordinary: many students in our research area do it for a living, and I'm no exception. I've been doing the traveling salesman, running presentations of Mezzo all over the place: Texas, New York, and going even as far as <em>Plateau de Saclay</em>. Now is the time for a blog post.</p>
<p><em><strong>Mezzo</strong></em> is a joint work between François Pottier, my advisor, and myself. Recently, Thibaut Balabonski joined our team as a post-doctoral researcher to work on the concurrent aspects of the language; we also had an undergrad intern, Henri Chataing, work on the compilation part of the project.</p>
<p><em><strong>Mezzo</strong></em> draws inspiration from many other research projects; I don't want to bother the reader with a long introduction -- this is not a research paper: I will provide an extended comparison of our work with other material in a later blog post. For the moment, let me just mention that we blend ideas from affine type systems, separation logic, and systems based on regions and capabilities.</p>
<p><em><strong>Mezzo</strong></em> is still in a preliminary stage, but I feel like it is time to start the revolution, and introduce this almighty language to a wider audience. Behold!</p>




<h3 id="what-is-mezzo">What is <em><strong>Mezzo</strong></em>?</h3>
<p><em><strong>Mezzo</strong></em><sup><a href="http://gallium.inria.fr/~scherer/gagallium/index.rss#fn1" id="fnref1" class="footnoteRef">1</a></sup> draws most of its inspiration from ML. Therefore, a big chunk of the language reads and feels just like ML (keywords: strict evaluation, functional, impure). However, there's a reason we're designing a new language: we want to go further than ML.</p>
<ul>
<li>We want to reject some programs previously accepted by ML; in a sense, we want to forbid patterns we consider dangerous.</li>
<li>Conversely, we want to accept some programs previously deemed unsafe by an ML type-checker: we want to make more programming patterns possible.</li>
</ul>
<p>Most of these improvements come at a cost, naturally. The design that I'm about to introduce is still very much in flux, and time will tell whether the cognitive cost of our new system is worth the benefits.</p>
<p>However, we deliberately tried to cut down the complexity of the system: in a sense, we don't want to end up doing proofs within the type system. Therefore, the mechanisms that I'm about to introduce may seem low-tech compared to recent research works, but we believe that's what makes it possible to explain the language to a (seasoned) ML programmer, and also what makes writing a type-checker relatively doable, without requiring a huge burden of annotations from the programmer.</p>
<h3 id="permissions">Permissions</h3>
<p>This blog post assumes that the reader is familiar with ML; in particular, the reader is expected to know what references are, what a boxed value is, and how only things in the heap may be mutable.</p>
<p>One of the goals for <em><strong>Mezzo</strong></em> is to offer better control of <em>aliasing</em> and <em>ownership</em> of mutable data. In order to make this possible, <em><strong>Mezzo</strong></em> replaces the traditional concept of "type" with that of "permission".</p>
<p>In essence, one can view a permission as a conceptual access token to a part of the heap, that is, a heaplet. A permission both describes the shape of the heaplet, and grants its owner the right to <em>access</em> this heaplet. Permissions are an artefact of the type system: they do not exist at runtime.</p>
<p>Consider the following piece of code:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> x = (2, <span class="st">"foo"</span>) <span class="kw">in</span>
...</code></pre>
<p>Right after this line of code, a new permission is made available to the programmer, namely <code>x @ (int, string)</code>. This permission basically tells the programmer that <code>x</code> points to a block in the heap, with two fields. The first one contains an integer, and the second one contains a pointer to a string. Moreover, the permission grants its owner the right to access this portion of the heap.</p>
<p>At any given point in the program, a set of permissions is available. They determine the fragment of the heap that we can access at this point of the program.</p>
<p>In the example above, several permissions may be available along <code>x @ (int, string)</code>; we chose to focus on the small subset of permissions we are interested in. In general, there is more than just one permission available in a given scope; for instance, we may have <code>x @ (int, string) ∗ y @ float</code>, that is, both <code>x @ (int, string)</code> and <code>y @ float</code> at the same time: <code>∗</code> denotes the conjunction of two permissions<sup><a href="http://gallium.inria.fr/~scherer/gagallium/index.rss#fn2" id="fnref2" class="footnoteRef">2</a></sup>.</p>
<h4 id="what-are-permissions-useful-for">What are permissions useful for?</h4>
<h5 id="a-simple-example-the-length-function">A simple example: the <code>length</code> function</h5>
<p>So far, there's nothing new here. Let us stay low-tech for a moment and consider the signature of the <code>length</code> function that, as the name suggests, computes the length of a <code>list</code>.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">val</span> length: [a] (x: <span class="dt">list</span> a) -&gt; <span class="dt">int</span></code></pre>
<p><code>[a]</code> denotes universal quantification, that is, <code>length</code> is valid for any type <code>a</code>, and <code>x</code> is a binder, that is, it gives us a way to talk about the argument of <code>length</code>.</p>
<p>The <code>length</code> function, in order to perform its job, requires that the <em>caller</em> passes it the "right" to read the list at address <code>x</code>. We say that this function needs the permission <code>x @ list a</code> to run: indeed, it needs to iterate over the elements of the list in order to compute its length, and the aforementioned permission enables it to do just that.</p>
<p>We understand this function to <em>return to its caller</em> the permission <code>x @ list a</code>, along with a value of type <code>int</code>. In other words, if comments denote the permissions available at a given program point:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* empty *)</span>
<span class="kw">let</span> x = ... <span class="kw">in</span>
<span class="co">(* x @ list a *)</span>
<span class="kw">let</span> l = length x <span class="kw">in</span>
<span class="co">(* l @ int ∗ x @ list a *)</span></code></pre>
<p>The permission <code>x @ list a</code> is temporarily taken from the caller's context, conceptually passed to the <code>length</code> function for the duration of its execution, then returned to the caller once <code>length</code> terminates.</p>
<h5 id="a-more-sophisticated-example-the-mswap-function">A more sophisticated example: the <code>mswap</code> function</h5>
<p>We are now ready to move on to a more sophisticated example that will demonstrate the power of <em><strong>Mezzo</strong></em>! We now consider <em>mutable</em> pairs of elements, which we write as <code>mpair a b</code> (think <code>('a, 'b) mpair</code><sup><a href="http://gallium.inria.fr/~scherer/gagallium/index.rss#fn3" id="fnref3" class="footnoteRef">3</a></sup>). We wish to write a function that will swap, <em>in place</em>, the two components of a pair. That is, without allocating a fresh pair.</p>
<p>What is the type for this function?</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">val</span> mswap: [a, b] (consumes x: mpair a b) -&gt; (| x @ mpair b a)</code></pre>
<p>Let us review this fairly complex type. There are several elements at play here.</p>
<ul>
<li>Unlike the <code>length</code> example, the argument <code>x</code> is <em>consumed</em>, that is, when the caller passes the <code>x @ mpair a b</code> permission to <code>mswap</code>, it <em>loses it</em>.</li>
<li>However, <code>mswap</code> will return to the caller a different permission saying that <code>x</code>, after <code>mswap</code> has run, has a different type, namely <code>x @ mpair b a</code>.</li>
<li>The <code>(|p)</code> syntax indicates that the function returns a permission <code>p</code>, but no value<sup><a href="http://gallium.inria.fr/~scherer/gagallium/index.rss#fn4" id="fnref4" class="footnoteRef">4</a></sup></li>
</ul>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* empty *)</span>
<span class="kw">let</span> x = ... <span class="kw">in</span>
<span class="co">(* x @ mpair a b *)</span>
mswap x;
<span class="co">(* x @ mpair b a *)</span></code></pre>
<p>This is a function that we cannot write in ML. Indeed, in order for this function to be sound, we must make sure that no one else can ever hold an <em>outdated</em> copy of <code>x @ mpair a b</code>. Therefore, <code>mswap</code> must have an <em>exclusive</em> access to its argument. <em><strong>Mezzo</strong></em> provides such a guarantee: <em>mutable portions of the heap are guaranteed to have a unique owner</em>; therefore, <code>mswap</code> <em>does</em> have an exclusive access to its argument: <code>x @ mpair a b</code> is an exclusive permission, and the system guarantees that it has an unique owner. In particular, as soon as <code>mswap</code> runs, the caller has lost its permission on <code>x</code>.</p>
<h4 id="different-flavors-of-permissions">Different flavors of permissions</h4>
<p>Getting back to our very first example, the fragment of the heap that the permission <code>x @ (int, string)</code> describes is immutable; therefore, it is safe to share this knowledge with others. In other words, <em>this permission can be freely copied</em>, and passed to other parts of the programs (think about threads, for instance). This permission is said to be <em>duplicable</em>.</p>
<p>As we just saw, not all permissions are duplicable. Because <em><strong>Mezzo</strong></em> aims to control aliasing to mutable data, we make sure that only one person at a time can "see" a mutable fragment of the heap: this is of utmost importance when it comes to concurrency. The way we enforce this is by forbidding duplication of such a permission. For instance, <code>x @ mpair a b</code> is said to be <em>exclusive</em>, and <em>cannot</em> be copied.</p>
<p>Therefore, having two copies of a permission is not necessarily the same as having just one copy.</p>
<h5 id="the-mode-system">The mode system</h5>
<p>Some functions can only be type-checked if they know that their argument is duplicable. The <code>find</code> function, because it returns a pointer to an element in the list, must require that the type of the elements in the list be duplicable: indeed, because a pointer to the element is returned to the caller <em>and</em> remains in the list at the same time, there are two people pointing to it, so it better be duplicable.</p>
<p>We express this fact using a mode constraint:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">val</span> find: [a] duplicable a =&gt; (a -&gt; <span class="dt">bool</span>, <span class="dt">list</span> a) -&gt; <span class="dt">option</span> a</code></pre>
<h4 id="accounting-for-aliasing-relationships">Accounting for aliasing relationships</h4>
<p>So far, we've seen that <em><strong>Mezzo</strong></em> provides a better control of ownership by making sure a mutable part of the heap has a unique owner; <em><strong>Mezzo</strong></em> also describes effects in a more accurate manner compared to traditional ML, by leveraging permissions to give finer-grained types to functions.</p>
<p><em><strong>Mezzo</strong></em> is able to talk about aliasing as well, through the use of <em>singleton types</em>. A singleton type basically means "same as", as is written <code>=t</code>. For instance, if a variable <code>x</code> "has type" <code>=y</code>, this means that <code>x</code> and <code>y</code> are aliases for each other. We write <code>x @ =y</code> or, more concisely, <code>x = y</code>.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> x = ... <span class="kw">in</span>
<span class="co">(* x @ τ *)</span>
<span class="kw">let</span> y = x <span class="kw">in</span>
<span class="co">(* x @ τ ∗ y = x *)</span>
...</code></pre>
<p>The important point here is that we <em>did not duplicate</em> the permission <code>x @ τ</code>, which would be illegal, since we know nothing about <code>τ</code>. We merely added a new permission that accounts for the aliasing relationship.</p>
<p>Similarly, if we hold <code>x @ mpair a b</code>, we know that <code>x</code> points to a block in the heap with two slots, the first one having type <code>a</code> and the second one having type <code>b</code>. This amounts to the following drawing:</p>
<pre><code>
                                            (l)
                                   ,-----,     
           ,---------------------&gt; |  a  |     
(x)       /                        `-----`     
   ,-----/------------,                        
   |    /   |         |                     (r)
   |  left  |  right  |            ,-----,     
   |        |     \   |       ,--&gt; |  b  |     
   `---------------\--`      /     `-----`     
                    \       /                  
                     `-----`                   
</code></pre>
<p><em><strong>Mezzo</strong></em> is able to accurately reflect this aliasing pattern through the permission system. Let us consider the definition (finally!) of the <code>mpair</code> type.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">mutable</span> data mpair a b =
  <span class="dt">MPair</span> { left: a; right: b }</code></pre>
<p>In <em><strong>Mezzo</strong></em>, sum type and record types are fused together. <em><strong>Mezzo</strong></em> is able to automatically transform:</p>
<pre><code>x @ mpair a b</code></pre>
<p>into</p>
<pre><code>x @ MPair { left: a; right: b }</code></pre>
<p>thus reflecting the fact that <code>x</code> is a block with two fields, named left and right. However, just like I've given names to the two anonymous blocks with types <code>a</code> and <code>b</code>, <em><strong>Mezzo</strong></em> will introduce names for these components and say that this permission is also equivalent to the following conjunction:</p>
<pre><code>x @ MPair { left: = l; right: = r } ∗ l @ a ∗ r @ b</code></pre>
<p>We write this more concisely as:</p>
<pre><code>x @ MPair { left = l; right = r } ∗ l @ a ∗ r @ b</code></pre>
<p>(note the <code>left = l</code> shorthand without a colon).</p>
<h4 id="a-final-example">A final example</h4>
<p>Here is an example that puts all these mechanisms together: the implementation of the <code>mswap</code> function. As usual, comments indicate the set of available permissions.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">val</span> mswap [a, b] (consumes x: mpair a b): (| x @ mpair b a) =
  <span class="co">(* We start off with:</span>
<span class="co">     x @ mpair a b</span>
<span class="co">   which the type-checker automatically converts into:</span>
<span class="co">     x @ MPair { left = l; right = r } ∗ l @ a ∗ r @ b *)</span>
  <span class="kw">let</span> t = x.left <span class="kw">in</span>
  <span class="co">(* x @ MPair { left = l; right = r } ∗ l @ a ∗ r @ b ∗ t = l *)</span>
  x.left &lt;- x.right;
  <span class="co">(* x @ MPair { left = r; right = r } ∗ l @ a ∗ r @ b ∗ t = l *)</span>
  x.right &lt;- t
  <span class="co">(* We end up with:</span>
<span class="co">     x @ MPair { left = r; right = t } ∗ l @ a ∗ r @ b ∗ t = l</span>
<span class="co">   which the type-checker automatically converts into:</span>
<span class="co">     x @ mpair a b</span>
<span class="co">   in order to satisfy the return type of the function. *)</span></code></pre>
<p>At the end of the function, the type-checker, in order to satisfy the return type of the function, must check that the final expression "has type" <code>()</code>, that is, the unit type: it is the case. It must also check that the new permission <code>x @ mpair b a</code> is available: by recombining the final set of permissions, we can indeed trade it for <code>x @ mpair b a</code>: the return condition of the function is satisfied, and the example above will type-check<sup><a href="http://gallium.inria.fr/~scherer/gagallium/index.rss#fn5" id="fnref5" class="footnoteRef">5</a></sup>:</p>
<p>The expressive power of <em><strong>Mezzo</strong></em> allows it to accurately reflect the aliasing and points-to relationships in the type system. This is what makes this example type-check, since we need a very precise reasoning in order to justify its soundness. In a sense, the permission system is close, in this example, to symbolic execution, or abstract interpretation.</p>
<h3 id="an-incomplete-presentation-of-mezzo">An incomplete presentation of Mezzo</h3>
<p>The permission mechanism is very good at describing local relationships between identifiers, but this very precise description cannot scale to larger<sup><a href="http://gallium.inria.fr/~scherer/gagallium/index.rss#fn6" id="fnref6" class="footnoteRef">6</a></sup>, more complex structures such as doubly-linked lists. Indeed, there are some patterns that the permission system cannot express at this stage: if a list contains the same exclusive element twice, for instance, the permission system will never accept such a list: there would be two ways of reaching the exclusive element, which means that one could gain two permissions for it: this is something that the system explicitly disallows.</p>
<p>In a second blog post, I will detail the main contribution that we bring with <em><strong>Mezzo</strong></em>, namely, a powerful adoption and abandon mechanism that provides a way to express these examples using permissions, at the expense of having dynamic checks.</p>
<h3 id="some-bonus-examples">Some bonus examples</h3>
<p>In case you are still skeptical about the benefits of such a sophisticated (if not complex) type system, here are some examples slightly more motivating than the <code>mswap</code> example which, I admit, will rarely pop up "in the real world".</p>
<p>These examples are taken from the test suite of our prototype type-checker. I'll give a brief overview of the current state of our type-checker in a subsequent post.</p>
<h4 id="tail-recursive-listconcat-without-obj.magic">Tail-recursive <code>list::concat</code> without <code>Obj.magic</code></h4>
<p>This function is written in destination-passing-style; that is, the <code>concat1</code> function keeps a pointer to the previous cell. Cells are mutable: they represent an "unfinished" list cell; once their <code>tail</code> field has been mutated, <code>cell</code>s can be "frozen" into a regular list cell, thus enabling tail-recursion.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml">data <span class="dt">list</span> a =
  | <span class="dt">Cons</span> { head: a; tail: <span class="dt">list</span> a }
  | <span class="dt">Nil</span>

<span class="kw">mutable</span> data cell a =
  | <span class="dt">Cell</span> { head: a; tail: () }

<span class="kw">val</span> <span class="kw">rec</span> concat1 [a] (
   consumes dst: cell a,
   consumes xs: <span class="dt">list</span> a,
   consumes ys: <span class="dt">list</span> a): (| dst @ <span class="dt">list</span> a)
  =
  <span class="kw">match</span> explain xs <span class="kw">with</span>
  | <span class="dt">Nil</span> -&gt;
      dst.tail &lt;- ys;
      tag <span class="kw">of</span> dst &lt;- <span class="dt">Cons</span>
  | <span class="dt">Cons</span> { head; tail } -&gt;
      <span class="kw">let</span> dst' = <span class="dt">Cell</span> {
        head = head; tail = ()
      } <span class="kw">in</span>
      dst.tail &lt;- dst';
      tag <span class="kw">of</span> dst &lt;- <span class="dt">Cons;</span>
      concat1 (dst', tail, ys)
  end

<span class="kw">val</span> concat [a] (
   consumes xs: <span class="dt">list</span> a,
   consumes ys: <span class="dt">list</span> a): <span class="dt">list</span> a
  =
  <span class="kw">match</span> xs <span class="kw">with</span>
  | <span class="dt">Nil</span> -&gt;
      ys
  | <span class="dt">Cons</span> { head; tail } -&gt;
      <span class="kw">let</span> dst = <span class="dt">Cell</span> {
        head = head; tail = ()
      } <span class="kw">in</span>
      concat1 (dst, tail, ys);
      dst
  end</code></pre>
<p>We also have a tail-recursive version of <code>map</code> that uses the exact same trick.</p>
<h4 id="computing-the-size-of-a-tree">Computing the size of a tree</h4>
<p>The following function:</p>
<ul>
<li>computes the size of a tree,</li>
<li>while annotating all sub-trees with their sizes,</li>
<li>accepts a tree that was previously annotated with any kind of data.</li>
</ul>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">mutable</span> data tree a = 
  | <span class="dt">Node</span> { left: tree a; right: tree a; size: a }
  | <span class="dt">Leaf</span>

<span class="kw">val</span> <span class="kw">rec</span> tree_size (consumes x: tree unknown): (<span class="dt">int</span> | x @ tree <span class="dt">int</span>) =
  <span class="kw">match</span> x <span class="kw">with</span>
  | <span class="dt">Leaf</span> -&gt;
      1
  | <span class="dt">Node</span> { left; right } -&gt;
      <span class="kw">let</span> l = tree_size left <span class="kw">in</span>
      <span class="kw">let</span> r = tree_size right <span class="kw">in</span>
      <span class="kw">let</span> total = l + r + 1 <span class="kw">in</span>
      x.size &lt;- total;
      total
  end</code></pre>
<div class="footnotes">
<hr/>
<ol>
<li id="fn1"><p>Former names for this language include: "the language of the future" and "Ha<strong>ML</strong>eT". My very own proposal of "Kre<strong>ML</strong>in" never really took off.<a href="http://gallium.inria.fr/~scherer/gagallium/index.rss#fnref1">↩</a></p></li>
<li id="fn2"><p>A man of the trade will undoubtedly feel an immediate familiary with separation logic. Indeed, our <code>*</code> conjunction acts as a separating conjunction on <em>exclusive</em> portions of the heap. On <em>duplicable</em> portions of the heap, it merely indicates that the set of permissions must be consistent with itself. More on that in the next section.<a href="http://gallium.inria.fr/~scherer/gagallium/index.rss#fnref2">↩</a></p></li>
<li id="fn3"><p>Unlike OCaml, type applications are done the same way as term applications, namely, left-to-right.<a href="http://gallium.inria.fr/~scherer/gagallium/index.rss#fnref3">↩</a></p></li>
<li id="fn4"><p>The <code>(t|p)</code> syntax allows one to bundle a type <code>t</code> along with a permission <code>p</code>. For the special case where <code>t</code> is equal to the unit type <code>()</code>, we write <code>(|p)</code>.<a href="http://gallium.inria.fr/~scherer/gagallium/index.rss#fnref4">↩</a></p></li>
<li id="fn5"><p>Function types are always annotated in <em><strong>Mezzo</strong></em>: we specify the type of the arguments as well as the return type of the function. If the function needs any extra permissions to run, these must be specified as well.<a href="http://gallium.inria.fr/~scherer/gagallium/index.rss#fnref5">↩</a></p></li>
<li id="fn6"><p>Precisely, the permission system we just saw cannot express structures of arbitrary length with sharing.<a href="http://gallium.inria.fr/~scherer/gagallium/index.rss#fnref6">↩</a></p></li>
</ol>
</div><a onclick="switchContent('post2','post1')" class="btn" href="#fefc7d1a5e469089727c2abf979df4b3">Hide</a></div></span>
<a name="fb9f676c7e10ca954d7a986fe12a25d9"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=828"> Uucd 0.9.2</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">09 Jan 2013</span></span><span class="rss-description">Uucd is an OCaml module to decode the data of the Unicode character database from its XML representation. It provides high-level (but not necessarily efficient) access to the data so that efficient representations can be extracted.</span>
<a name="528030196c33a8cbbbd79c7ff7e4e0df"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=827"> Uunf 0.9.1</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">09 Jan 2013</span></span><span class="rss-description">Uunf is an OCaml module for normalizing Unicode text. It supports all Unicode normalization forms and is independent from any IO mechanism or Unicode text data structure. Text can be processed without a complete in-memory representation.</span>
<a name="e16e96e9ee0d5ba98f1c72ea6340b0a5"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2013.01.08.html"> Caml Weekly News, 08 Jan 2013</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">08 Jan 2013</span></span><span class="rss-description">new OPAM command-line interface / Cmdliner / Uutf / Uunf / Uucd minor releases / Building a GADT from an untyped representation / ODT 2.3 released / Other Caml News</span>
<a name="fe4a9758a84119967b2ef7808523bb20"></a><span class="rss-header"><span class="rss-title"><a href="http://erratique.ch/software"> Winter distribution</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Daniel Bünzli</span>, <span class="rss-date">05 Jan 2013</span></span><span class="rss-description">Release of Cmdliner 0.9.3, Uutf 0.9.2, Uunf 0.9.1 and Uucd 0.9.2. Consult the individual release notes for details.</span>
<a name="35bc65a5fb94a57f1ad507d1edd0f509"></a><span class="rss-header"><span class="rss-title"><a href="http://functional-orbitz.blogspot.com/2013/01/experiences-using-resultt-vs-exceptions.html"> Experiences using Result.t vs Exceptions in Ocaml</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author"><span id="ocaml_1">Orbitz &#9001;noreply<abbr title="(at) &rarr; @">(at)</abbr>blogger.com (orbitz)&#9002;</span><script type="text/javascript"><!--;
local = "noreply";
h = "blogger.com (orbitz)";
document.getElementById("ocaml_1").innerHTML = '<a href="mailto:' + local + '@' + h + "\" >Orbitz<\/a>";
//--></script></span>, <span class="rss-date">04 Jan 2013</span></span><span class="rss-description"><div id="post3"><p><i>Disclaimer: I have not compiled any of the example code in this post.  Mostly because they are snippets meant to illustrate a point rather than be complete on their own.  If they have any errors then apologies.</i></p> <p>Previously I gave an <a href="http://functional-orbitz.blogspot.se/2013/01/introduction-to-resultt-vs-exceptions.html">introduction to return values vs exceptions</a> in Ocaml.  But a lot of ideas in software engineering sound good, how does this particular one work out in real software? </p> <p>I have used this style in two projects.  The first is a project that was originally written using exceptions and I have converted most of it to using return values.  The second is one that was written from the start using return values.  They can be found <a href="http://code.google.com/p/para-mugsy/">here</a> and <a href="https://github.com/orbitz/opass">here</a>.  <i>I make no guarantees about the quality of the code, in fact I believe some of it to be junk.  These are just my subjective opinions in writing software with a particular attribute</i>. </p> <h1>The Good</h1><h3>Expected Result</h3><a onclick="switchContent('post3','post4')" class="btn" href="#35bc65a5fb94a57f1ad507d1edd0f509">Read more...</a></div><div id="post4" style="display: none"><p><i>Disclaimer: I have not compiled any of the example code in this post.  Mostly because they are snippets meant to illustrate a point rather than be complete on their own.  If they have any errors then apologies.</i></p> <p>Previously I gave an <a href="http://functional-orbitz.blogspot.se/2013/01/introduction-to-resultt-vs-exceptions.html">introduction to return values vs exceptions</a> in Ocaml.  But a lot of ideas in software engineering sound good, how does this particular one work out in real software? </p> <p>I have used this style in two projects.  The first is a project that was originally written using exceptions and I have converted most of it to using return values.  The second is one that was written from the start using return values.  They can be found <a href="http://code.google.com/p/para-mugsy/">here</a> and <a href="https://github.com/orbitz/opass">here</a>.  <i>I make no guarantees about the quality of the code, in fact I believe some of it to be junk.  These are just my subjective opinions in writing software with a particular attribute</i>. </p> <h1>The Good</h1><h3>Expected Result</h3><p>The whole system worked as expected.  I get compile-time errors for all failure cases I do not handle.  This has helped me catch some failure cases I had forgotten about previously, some of which would require an unlikely chain of events to hit, which would have made finding in a test harder, but obviously not impossible.  In particular, ParaMugsy is (although the current rewrite does not cover this yet) meant to run in a distributed environment, which increases the cost of errors.  Both in debugging and reproducing.  In the case of opass, writing the DB is important to get right. Missing handling a failure here can mean the users database of passwords can be lost, a tragic event. </p> <h3>Not Cumbersome</h3><p>In the Introduction I showed that for a simple program, return-values are no more cumbersome than exceptions.  In these larger projects the same holds. This shouldn't really be a surprise though, as the monadic operators actually simulate the exact flow of exception code.  But the 'not cumbersome' is half of a lie, which is explained more below. </p> <h3>Refactoring Easier</h3><p>Ocaml is a great language when it comes to refactoring.  Simply make the change you want and iterate on compiler errors.  This style has made it even easier for me.  I can add new failures to my functions and work through the compiler errors to make sure the change is handled in every location. </p> <h3>Works No Matter The Concurrent Framework</h3><p>The original implementation of ParaMugsy used Lwt.  In the rewrite I decided to use Core's Async library.  Both are monadic.  And both handle exceptions quite differently.  Porting functions over that did return-values was much easier because they didn't rely on the framework to handle and propagate failures.  Exceptions are tricky in a concurrent framework and concurrency is purely library based in Ocaml rather than being part of the language, which means libraries can choose incompatible ways to handle them.  Return-values give one less thing to worry about when porting code or trying to get code to work in multiple frameworks. </p> <h1>The Bad</h1><h3>Prototyping Easier With Exceptions</h3><p>The whole idea is to make it hard to miss an error case.  But that can be annoying when you just want to get something running.  Often times we write software in such a way that the success path is the first thing we write and we handle the errors after that.  I don't think there is necessarily a good reason for this other than it's much more satisfying to see the results of the hard work sooner rather than later.  In this case, my solution is to relax the ban on exceptions temporarily.  Any place that I will return an <code>Error</code> I instead write <code>failwith "not yet implemented"</code>.  That way there is an easily grepable string to ensure I have replaced all exceptions with <code>Error</code>'s when I am done.  This is an annoyance but thankfully with a fairly simple solution. </p> <h3>Cannot Express All Invariants In Type System</h3><p>Sometimes there are sections of code where I know something is true, but it is not expressible in the type system.  For example, perhaps I have a data structure that updates multiple pieces of information together.  I know when I access one piece of information it will be in the other place.  Or perhaps I have a pattern match that I need to handle due to exhaustiveness but I know that it cannot happen given some invariants I have established earlier.  In the case where I am looking up data that I know will exist, I will use a lookup function that can throw an exception if it is easiest.  In the case where I have a pattern match that I know will never happen, I use <code>assert</code>.  But note, these are cases where I have metaphysical certitude that such events will not happen.  Not cases where I'm just pretty sure they work. </p> <h3>Many Useful Libraries Throw Exceptions</h3><p>Obviously a lot of libraries throw exceptions.  Luckily the primary library I use is Jane St's Core Suite, where they share roughly the same aversion of exceptions.  Some functions still do throw exceptions though, most notably <code>In_channel.with_file</code> and <code>Out_channel.with_file</code>.  This can be solved by wrapping those functions in return-value ones.  The problem comes in: what happens when the function being wrapped is poorly documented or at some point can throw more exceptional cases than when it was originally wrapped.  One option is to always catch <code>_</code> and turn it into a fairly generic variant type.  Or maybe a function only has a few logical failure conditions so collapsing them to a few variant types makes sense.  I'm not aware of any really good solution here. </p> <h1>A Few Examples</h1><p>There are a few transformations that come up often when converting exception code to return-value code.  Here are some in detail. </p> <h3>Building Things</h3><p>It's common to want to do some work and then construct a value from it.  In exception-land that is as simple, just something like <code>Constructor (thing_that_may_throw_exception ())</code>.  This doesn't work with return-values.  Instead we have to do what we did in the Introduction post.  Here is an example: </p> <pre><code><b></b></code></pre><font color="#0000FF">let</font> f <font color="#990000">()</font> <font color="#990000">=</font><br/>  <b><font color="#0000FF">let</font></b> <b><font color="#000080">open</font></b> <b><font color="#000080">Result</font></b><font color="#990000">.</font><font color="#009900">Monad_infix</font> <b><font color="#0000FF">in</font></b><br/>  thing_that_may_fail <font color="#990000">()</font> <font color="#990000">&gt;&gt;=</font> <b><font color="#0000FF">fun</font></b> v <font color="#990000">-&gt;</font><br/>  <font color="#009900">Ok</font> <font color="#990000">(</font><font color="#009900">Constructor</font> v<font color="#990000">)</font><br/> <h3>Looping</h3><p>Some loops cannot be written in their most obvious style.  Consider an implementation of <code>map</code> that expects the function passed to it to use <code>Result.t</code> to signal failures.  The very naive implementation of <code>map</code> is: </p> <pre><code><b></b></code></pre><font color="#0000FF">let</font> map f <font color="#990000">=</font> <b><font color="#0000FF">function</font></b><br/>  <font color="#990000">|</font> <font color="#990000">[]</font>    <font color="#990000">-&gt;</font> <font color="#990000">[]</font><br/>  <font color="#990000">|</font> x<font color="#990000">::</font>xs <font color="#990000">-&gt;</font> <font color="#990000">(</font>f x<font color="#990000">)::(</font>map xs<font color="#990000">)</font><br/> <p>There are two ways to write this.  The first requires two passes over the elements.  The first pass applies the function and the second one checks which value each function returned or the first error that was hit. </p> <pre><code><b></b></code></pre><font color="#0000FF">let</font> map f l <font color="#990000">=</font><br/>  <b><font color="#000080">Result</font></b><font color="#990000">.</font>all <font color="#990000">(</font><b><font color="#000080">List</font></b><font color="#990000">.</font>map f l<font color="#990000">)</font><br/> <p><code>Result.all</code> has the type <code>('a, 'b) Core.Std.Result.t list -&gt; ('a list, 'b) Core.Std.Result.t</code></p> <p>The above is simple but could be inefficient. The entire map is preformed regardless of failure and then walked again.  If the function being applied is expensive this could be a problem.  The other solution is a pretty standard pattern in Ocaml of using an accumulator and reversing it on output.  The monadic operator could be replaced by a <code>match</code> in this example, I just prefer the operator. </p> <pre><code><b></b></code></pre><font color="#0000FF">let</font> map f l <font color="#990000">=</font><br/>  <b><font color="#0000FF">let</font></b> <b><font color="#0000FF">rec</font></b> map' f acc <font color="#990000">=</font> <b><font color="#0000FF">function</font></b><br/>    <font color="#990000">|</font> <font color="#990000">[]</font>    <font color="#990000">-&gt;</font> <font color="#009900">Ok</font> <font color="#990000">(</font><b><font color="#000080">List</font></b><font color="#990000">.</font>rev acc<font color="#990000">)</font><br/>    <font color="#990000">|</font> x<font color="#990000">::</font>xs <font color="#990000">-&gt;</font> <b><font color="#0000FF">begin</font></b><br/>      <b><font color="#0000FF">let</font></b> <b><font color="#000080">open</font></b> <b><font color="#000080">Result</font></b><font color="#990000">.</font><font color="#009900">Monad_infix</font> <b><font color="#0000FF">in</font></b><br/>      f x <font color="#990000">&gt;&gt;=</font> <b><font color="#0000FF">fun</font></b> v <font color="#990000">-&gt;</font><br/>      map' f <font color="#990000">(</font>v<font color="#990000">::</font>acc<font color="#990000">)</font> xs<br/>    <b><font color="#0000FF">end</font></b><br/>  <b><font color="#0000FF">in</font></b><br/>  map' f <font color="#990000">[]</font> l<br/> <p>I'm sure someone cleverer in Ocaml probably has a superior solution but this has worked well for me. </p> <h3>try/with</h3><p>A lot of exception code looks like the following. </p> <pre><code><b></b></code></pre><font color="#0000FF">let</font> <font color="#990000">()</font> <font color="#990000">=</font><br/>  <b><font color="#0000FF">try</font></b><br/>    thing1 <font color="#990000">();</font><br/>    thing2 <font color="#990000">();</font><br/>    thing3 <font color="#990000">()</font><br/>  <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#009900">Error1</font> <font color="#990000">-&gt;</font> handle_error1 <font color="#990000">()</font><br/>    <font color="#990000">|</font> <font color="#009900">Error2</font> <font color="#990000">-&gt;</font> handle_error2 <font color="#990000">()</font><br/>    <font color="#990000">|</font> <font color="#009900">Error3</font> <font color="#990000">-&gt;</font> handle_error3 <font color="#990000">()</font><br/> <p>The scheme I use would break this into two functions.  The one inside the try and the one handling its result.  This might sound heavy but the syntax to define a new function in Ocaml is very light.  In my experience this hasn't been a problem. </p> <pre><code><b></b></code></pre><font color="#0000FF">let</font> do_things <font color="#990000">()</font> <font color="#990000">=</font><br/>  <b><font color="#0000FF">let</font></b> <b><font color="#000080">open</font></b> <b><font color="#000080">Result</font></b><font color="#990000">.</font><font color="#009900">Monad_infix</font> <b><font color="#0000FF">in</font></b><br/>  thing1 <font color="#990000">()</font> <font color="#990000">&gt;&gt;=</font> <b><font color="#0000FF">fun</font></b> <font color="#990000">()</font> <font color="#990000">-&gt;</font><br/>  thing2 <font color="#990000">()</font> <font color="#990000">&gt;&gt;=</font> <b><font color="#0000FF">fun</font></b> <font color="#990000">()</font> <font color="#990000">-&gt;</font><br/>  thing3<br/><br/><b><font color="#0000FF">let</font></b> <font color="#990000">()</font> <font color="#990000">=</font><br/>  <b><font color="#0000FF">match</font></b> do_things <font color="#990000">()</font> <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#009900">Ok</font> _ <font color="#990000">-&gt;</font> <font color="#990000">()</font><br/>    <font color="#990000">|</font> <font color="#009900">Error</font> <font color="#009900">Error1</font> <font color="#990000">-&gt;</font> handle_error1 <font color="#990000">()</font><br/>    <font color="#990000">|</font> <font color="#009900">Error</font> <font color="#009900">Error2</font> <font color="#990000">-&gt;</font> handle_error2 <font color="#990000">()</font><br/>    <font color="#990000">|</font> <font color="#009900">Error</font> <font color="#009900">Error3</font> <font color="#990000">-&gt;</font> handle_error3 <font color="#990000">()</font><br/> <h1>Conclusion</h1><p>Using return-values instead of exceptions in my Ocaml projects has had nearly the exact output I anticipated.  I have compile-time guarantees for handling failure cases and the cost to my code has been minimal.  Any difficulties I've run into have had straight forward solutions.  In some cases it's simply a matter of thinking about the problems from a new perspective and the solution is clear.  I plan on continuing to develop code with these principles and creating larger projects.  I believe that this style scales well in larger projects and actually becomes less cumbersome as the project increases since the guarantees can help make it easier to reason about the project. </p><a onclick="switchContent('post4','post3')" class="btn" href="#35bc65a5fb94a57f1ad507d1edd0f509">Hide</a></div></span>
<a name="bc1b8a06674f25766c2ef19b23b7d866"></a><span class="rss-header"><span class="rss-title"><a href="http://functional-orbitz.blogspot.com/2013/01/introduction-to-resultt-vs-exceptions.html"> Introduction to Result.t vs Exceptions in Ocaml</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author"><span id="ocaml_2">Orbitz &#9001;noreply<abbr title="(at) &rarr; @">(at)</abbr>blogger.com (orbitz)&#9002;</span><script type="text/javascript"><!--;
local = "noreply";
h = "blogger.com (orbitz)";
document.getElementById("ocaml_2").innerHTML = '<a href="mailto:' + local + '@' + h + "\" >Orbitz<\/a>";
//--></script></span>, <span class="rss-date">03 Jan 2013</span></span><span class="rss-description"><div id="post5"><p><i>This post uses Jane St's Core suite.  Specifically the <code>Result</code> module.  It assumes some basic knowledge of Ocaml.  Please check out <a href="http://ocaml.org">Ocaml.org</a> for more Ocaml reading material.</i></p> <p>There are several articles and blog posts out there arguing for or against return values over exceptions.  I'll add to the discussion with my reasons for using return values in the place of exceptions in Ocaml. </p> <h3>What's the difference?</h3><a onclick="switchContent('post5','post6')" class="btn" href="#bc1b8a06674f25766c2ef19b23b7d866">Read more...</a></div><div id="post6" style="display: none"><p><i>This post uses Jane St's Core suite.  Specifically the <code>Result</code> module.  It assumes some basic knowledge of Ocaml.  Please check out <a href="http://ocaml.org">Ocaml.org</a> for more Ocaml reading material.</i></p> <p>There are several articles and blog posts out there arguing for or against return values over exceptions.  I'll add to the discussion with my reasons for using return values in the place of exceptions in Ocaml. </p> <h3>What's the difference?</h3><p>Why does the debate even exist?  Because each side has decent arguments for why their preference is superior when it comes to writing reliable software.  Pro-return-value developers, for example, argue that their code is easier identify if the code is wrong simply by reading it (if it isn't handling a return value of a function, it's wrong), while exception based code requires understanding all of the functions called to determine if and how they will fail.  Pro-exception developers argue that it is much harder to get their program into an undefined state because an exception has to be handled or else the program fails, where in return based code one can simply forget to check a function's return value and the program continues on in an undefined state.  </p> <p>I believe that Ocaml has several features that make return values the preferable way to handle errors.  Specifically variants, polymorphic variants, exhaustive pattern matching, and a powerful static type system make return values attractive. </p> <p>This debate is only worth your time if you are really passionate about writing software that has fairly strong guarantees about its quality in the face of errors.  For a majority of software, it doesn't matter which paradigm you choose.  Most errors will be stumbled upon during debugging and fairly soon after going into production or through writing unit and integration tests.  But, tests cannot catch everything.  And in distributed and concurrent code rare errors can now become common errors and it can be near impossible to reconstruct the conditions that caused it.  But in some cases it is possible to make whole classes of errors either impossible or catchable at compile-time with some discipline.  Ocaml is at least one language that makes this possible. </p> <h3>Checked exceptions</h3><p>A quick aside on checked exceptions, as in Java.  Checked exceptions provide some of the functionality I claim is valuable, the main problem with how checked exceptions are implemented in Java (the only language I have any experience in that uses them), is they have a very heavy syntax, to the point where using them can seem too burdensome. </p> <h3>The Claim</h3><p>The claim is that if one cares about ensuring they are handling all failure cases in their software, return-values are superior to exceptions because, with the help of a good type system, their handling can be validated at compile-time.  Ocaml provides a fairly light, non intrusive, syntax to make this feasible. </p> <h3>Good Returns</h3><p>The goal of a good return value based error handling system is to make sure that all errors are handled at compile-time.  This is because there is no way to enforce this at run-time, as an exception does.  This is a good reason to prefer exceptions in a dynamically typed language like Python or Ruby, your static analyzers are few and far between. </p> <p>In C this is generally accomplished by using a linting tool that will report an error if a function's return value is ignored in a call.  This is why you might see <code>printf</code> casted to <code>void</code> in some code, to make it clear the return value is meant to be ignored.  But a problem with this solution is that it only enforces that the developer handles the return value, not all possible errors.  For example, POSIX functions return a value saying the function failed and put the actual failure in <code>errno</code>.  How, then, to enforce that all of the possible failures are handled?  Without encoding all of that information in a linting tool, the options in C (and most languages) are pretty weak. Linting tools are also separate from the compiler and vary in quality.  Writing code that takes proper advantage of a linting tool, in C, is a skill all of its own as well. </p> <h3>Better Returns</h3><p>Ocaml supports exceptions but the compiler provides no guarantees that the exceptions are actually handled anywhere in the code.  So what happens if the documentation of a function is incomplete or a dependent function is changed to add a new exception being thrown?  The compiler won't help you. </p> <p>But Ocaml's rich type system, combined with some discipline, gives you more power than a C linter.  The primary strength is that Ocaml lets you encode information in your types.  For example, in POSIX many functions return an integer to indicate error.  But an <code>int</code> has no interesting meaning to the compiler other than it holds values between <code>INT_MIN</code> and <code>INT_MAX</code>.  In Ocaml, we can instead create a type to represent the errors a function can return and the compiler can enforce that all possible errors are handled in some way thanks to exhaustive pattern matching. </p> <h3>An Example</h3><p>What does all of this look like?  Below a contrived example. The goal is to provide a function, called <code>parse_person</code> that takes a string and turns it into a <code>person</code> record.  The requirements of the code is that if a valid person cannot be parsed out, the part of the string that failed is specified in the error message. </p> <p>Here is a version using exceptions, <a href="https://github.com/orbitz/blog_post_src/blob/master/intro_return_t/ex1.ml">ex1.ml</a>: </p>  <pre><code><b></b></code></pre><font color="#000080">open</font> <b><font color="#000080">Core</font></b><font color="#990000">.</font><font color="#009900">Std</font><br/><br/><b><font color="#0000FF">exception</font></b> <font color="#009900">Int_of_string</font> <b><font color="#0000FF">of</font></b> <font color="#009900">string</font><br/><br/><b><font color="#0000FF">exception</font></b> <font color="#009900">Bad_line</font> <b><font color="#0000FF">of</font></b> <font color="#009900">string</font><br/><b><font color="#0000FF">exception</font></b> <font color="#009900">Bad_name</font> <b><font color="#0000FF">of</font></b> <font color="#009900">string</font><br/><b><font color="#0000FF">exception</font></b> <font color="#009900">Bad_age</font> <b><font color="#0000FF">of</font></b> <font color="#009900">string</font><br/><b><font color="#0000FF">exception</font></b> <font color="#009900">Bad_zip</font> <b><font color="#0000FF">of</font></b> <font color="#009900">string</font><br/><br/><b><font color="#0000FF">type</font></b> person <font color="#990000">=</font> <font color="#FF0000">{</font> name <font color="#990000">:</font> <font color="#990000">(</font><font color="#009900">string</font> <font color="#990000">*</font> <font color="#009900">string</font><font color="#990000">)</font><br/>              <font color="#990000">;</font> age  <font color="#990000">:</font> <b><font color="#000080">Int</font></b><font color="#990000">.</font>t<br/>              <font color="#990000">;</font> zip  <font color="#990000">:</font> <font color="#009900">string</font><br/>              <font color="#FF0000">}</font><br/><br/><i><font color="#9A1900">(* A little helper function *)</font></i><br/><b><font color="#0000FF">let</font></b> int_of_string s <font color="#990000">=</font><br/>  <b><font color="#0000FF">try</font></b><br/>    <b><font color="#000080">Int</font></b><font color="#990000">.</font>of_string s<br/>  <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#009900">Failure</font> _ <font color="#990000">-&gt;</font><br/>      raise <font color="#990000">(</font><font color="#009900">Int_of_string</font> s<font color="#990000">)</font><br/><br/><b><font color="#0000FF">let</font></b> parse_name name <font color="#990000">=</font><br/>  <b><font color="#0000FF">match</font></b> <b><font color="#000080">String</font></b><font color="#990000">.</font>lsplit2 <font color="#990000">~</font>on<font color="#990000">:</font>' ' name <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#009900">Some</font> <font color="#990000">(</font>first_name<font color="#990000">,</font> last_name<font color="#990000">)</font> <font color="#990000">-&gt;</font><br/>      <font color="#990000">(</font>first_name<font color="#990000">,</font> last_name<font color="#990000">)</font><br/>    <font color="#990000">|</font> <font color="#009900">None</font> <font color="#990000">-&gt;</font><br/>      raise <font color="#990000">(</font><font color="#009900">Bad_name</font> name<font color="#990000">)</font><br/><br/><b><font color="#0000FF">let</font></b> parse_age age <font color="#990000">=</font><br/>  <b><font color="#0000FF">try</font></b><br/>    int_of_string age<br/>  <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#009900">Int_of_string</font> _ <font color="#990000">-&gt;</font><br/>      raise <font color="#990000">(</font><font color="#009900">Bad_age</font> age<font color="#990000">)</font><br/><br/><b><font color="#0000FF">let</font></b> parse_zip zip <font color="#990000">=</font><br/>  <b><font color="#0000FF">try</font></b><br/>    ignore <font color="#990000">(</font>int_of_string zip<font color="#990000">);</font><br/>    <b><font color="#0000FF">if</font></b> <b><font color="#000080">String</font></b><font color="#990000">.</font>length zip <font color="#990000">=</font> <font color="#993399">5</font> <b><font color="#0000FF">then</font></b><br/>      zip<br/>    <b><font color="#0000FF">else</font></b><br/>      raise <font color="#990000">(</font><font color="#009900">Bad_zip</font> zip<font color="#990000">)</font><br/>  <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#009900">Int_of_string</font> _ <font color="#990000">-&gt;</font><br/>      raise <font color="#990000">(</font><font color="#009900">Bad_zip</font> zip<font color="#990000">)</font><br/><br/><b><font color="#0000FF">let</font></b> parse_person s <font color="#990000">=</font><br/>  <b><font color="#0000FF">match</font></b> <b><font color="#000080">String</font></b><font color="#990000">.</font>split <font color="#990000">~</font>on<font color="#990000">:</font>'<font color="#990000">\</font>t' s <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#990000">[</font>name<font color="#990000">;</font> age<font color="#990000">;</font> zip<font color="#990000">]</font> <font color="#990000">-&gt;</font><br/>      <font color="#FF0000">{</font> name <font color="#990000">=</font> parse_name name<br/>      <font color="#990000">;</font> age  <font color="#990000">=</font> parse_age age<br/>      <font color="#990000">;</font> zip  <font color="#990000">=</font> parse_zip zip<br/>      <font color="#FF0000">}</font><br/>    <font color="#990000">|</font> _ <font color="#990000">-&gt;</font><br/>      raise <font color="#990000">(</font><font color="#009900">Bad_line</font> s<font color="#990000">)</font><br/><br/><b><font color="#0000FF">let</font></b> <font color="#990000">()</font> <font color="#990000">=</font><br/>  <i><font color="#9A1900">(* Pretend input came from user *)</font></i><br/>  <b><font color="#0000FF">let</font></b> input <font color="#990000">=</font> <font color="#FF0000">"Joe Mama\t25\t11425"</font> <b><font color="#0000FF">in</font></b><br/>  <b><font color="#0000FF">try</font></b><br/>    <b><font color="#0000FF">let</font></b> person <font color="#990000">=</font> parse_person input <b><font color="#0000FF">in</font></b><br/>    printf <font color="#FF0000">"Name: %s %s\nAge: %d\nZip: %s\n"</font><br/>      <font color="#990000">(</font>fst person<font color="#990000">.</font>name<font color="#990000">)</font><br/>      <font color="#990000">(</font>snd person<font color="#990000">.</font>name<font color="#990000">)</font><br/>      person<font color="#990000">.</font>age<br/>      person<font color="#990000">.</font>zip<br/>  <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#009900">Bad_line</font> l <font color="#990000">-&gt;</font><br/>      printf <font color="#FF0000">"Bad line: '%s'\n"</font> l<br/>    <font color="#990000">|</font> <font color="#009900">Bad_name</font> name <font color="#990000">-&gt;</font><br/>      printf <font color="#FF0000">"Bad name: '%s'\n"</font> name<br/>    <font color="#990000">|</font> <font color="#009900">Bad_age</font> age <font color="#990000">-&gt;</font><br/>      printf <font color="#FF0000">"Bad age: '%s'\n"</font> age<br/>    <font color="#990000">|</font> <font color="#009900">Bad_zip</font> zip <font color="#990000">-&gt;</font><br/>      printf <font color="#FF0000">"Bad zip: '%s'\n"</font> zip<br/> <p><a href="https://github.com/orbitz/blog_post_src/blob/master/intro_return_t/ex2.ml">ex2.ml</a> is a basic translation of the above but using variants.  The benefit is that the type system will ensure that all failure case are handled.  The problem is the code is painful to read and modify.  Every function that can fail has its own variant type to represent success and error.  Composing the functions is painful since every thing returns a different type.  We have to create a type that can represent all of the failures the other functions returned.  It would be nice if each function could return an error and we could use that value instead.  It would also be nice if everything read as a series of steps, rather than pattern matching on a tuple which makes it hard to read. </p> <p><a href="https://github.com/orbitz/blog_post_src/blob/master/intro_return_t/ex3.ml">ex3.ml</a> introduces Core's <code>Result.t</code> type.  The useful addition is that we only need to define a type for <code>parse_person</code>.  Every other function only has one error condition so we can just encode the error in the <code>Error</code> variant.  This is still hard to read, though.  The helper functions aren't so bad but the main function is still painful. </p> <p>While the previous solutions have solved the problem of ensuring that all errors are handled, they introduced the problem of being painful to develop with.  The main problem is that nothing composes.  The helpers have their own error types and for every call to them we have to check their return and then encompass their error in any function above it.  What would be nice is if the compiler could automatically union all of the error codes we want to return from itself and any function it called.  Enter polymorphic variants. </p> <p><a href="https://github.com/orbitz/blog_post_src/blob/master/intro_return_t/ex4.ml">ex4.ml</a> Shows the version with polymorphic variants.  The nice bit of refactoring we were able to do is in <code>parse_person</code>.  Rather than an ugly match, the calls to the helper functions can be sequenced: </p> <pre><code><b></b></code></pre><font color="#0000FF">let</font> parse_person s <font color="#990000">=</font><br/>  <b><font color="#0000FF">match</font></b> <b><font color="#000080">String</font></b><font color="#990000">.</font>split <font color="#990000">~</font>on<font color="#990000">:</font>'<font color="#990000">\</font>t' s <b><font color="#0000FF">with</font></b><br/>    <font color="#990000">|</font> <font color="#990000">[</font>name<font color="#990000">;</font> age<font color="#990000">;</font> zip<font color="#990000">]</font> <font color="#990000">-&gt;</font><br/>      <b><font color="#0000FF">let</font></b> <b><font color="#000080">open</font></b> <b><font color="#000080">Result</font></b><font color="#990000">.</font><font color="#009900">Monad_infix</font> <b><font color="#0000FF">in</font></b><br/>      parse_name name <font color="#990000">&gt;&gt;=</font> <b><font color="#0000FF">fun</font></b> name <font color="#990000">-&gt;</font><br/>      parse_age  age  <font color="#990000">&gt;&gt;=</font> <b><font color="#0000FF">fun</font></b> age  <font color="#990000">-&gt;</font><br/>      parse_zip  zip  <font color="#990000">&gt;&gt;=</font> <b><font color="#0000FF">fun</font></b> zip  <font color="#990000">-&gt;</font><br/>      <font color="#009900">Ok</font> <font color="#FF0000">{</font> name<font color="#990000">;</font> age<font color="#990000">;</font> zip <font color="#FF0000">}</font><br/>    <font color="#990000">|</font> _ <font color="#990000">-&gt;</font><br/>      <font color="#009900">Error</font> <font color="#990000">(</font>`<font color="#009900">Bad_line</font> s<font color="#990000">)</font><br/> <p>Don't worry about the monad syntax, it's really just to avoid the nesting to make the sequencing easier on the eyes.  Except for the <code>&gt;&gt;=</code>, this looks a lot like code using exceptions.  There is a nice linear flow and only the success path is shown.  But! The compiler will ensure that all failures are handled. </p> <p>The final version of the code is <a href="https://github.com/orbitz/blog_post_src/blob/master/intro_return_t/ex5.ml">ex5.ml</a>.  This takes ex4 and rewrites portions of it to be prettier.  As a disclaimer, I'm sure someone else would consider writing this differently even with the same restrictions I put on it, I might even write it different on a different day, but this version of the code demonstrates the points I am making. </p> <p>A few points of comparison between ex1 and ex5: </p> <p></p><ul><li>The body of <code>parse_person</code> is definitely simpler and easier to read in the exception code.  It is short and concise.</li><li>The rest of the helper functions are a bit of a toss-up between the exception and return-value code.  I think one could argue either direction.</li><li>The return-value code has fulfilled my requirements in terms of handling failures.  The compiler will complain if any failure <code>parse_person</code> could return is not handled.  If I add another error type the code will not compile.  It also fulfilled the requirements without bloating the code.  The return-value code and exception code are roughly the same number of lines.  Their flows are roughly equal.  But the return-value code is much safer.</li></ul><p></p> <h3>Two Points</h3><p>It's not all sunshine and lollipops.  There are two issues to consider: </p> <p></p><ul><li><b>Performance</b> - Exceptions in Ocaml are really, really, fast.  Like any performance issue, I suggest altering code only when needed based on measurements and encapsulating those changes as well as possible.  This also means if you want to provide a safe and an exception version of a function, you should probably implement the safe version in terms of the exception verson.</li><li><b>Discipline</b> - I referred to discipline a few times above.  This whole scheme is very easy to mess up with a single mistake: pattern matching on anything (<code>_</code>).  The power of exhaustive pattern matching means you need to match on every error individually.  This is effectively for the same reason catching the exception base class in other languages is such a bad idea, you lose a lot of information.</li></ul><p></p>  <h3>Conclusion</h3><p>The example given demonstrates an important point: code can become much safer at compile time without detriment to its length or readability.  The cost is low and the benefit is high.  This is a strong reason to prefer a return-value based solution over exceptions in Ocaml. </p><a onclick="switchContent('post6','post5')" class="btn" href="#bc1b8a06674f25766c2ef19b23b7d866">Hide</a></div></span>
<a name="de8a5b43b4b100ac2ecc59bc44a7b76e"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2013.01.01.html"> Caml Weekly News, 01 Jan 2013</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">01 Jan 2013</span></span><span class="rss-description">C interop: Return values in parameters / Other Caml News</span>
<a name="5545255706f634a2dd689cddc5f36692"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/blog/singleton-types-for-code-inference-2"> Singleton types for code inference, continued</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">30 Dec 2012</span></span><span class="rss-description"><div id="post7"><p>In this post you can find out what was cut from the <a href="http://gallium.inria.fr/blog/singleton-types-for-code-inference">previous post on
singleton
types</a>. These are
more technical considerations that may require some familiarity with
type theory. In particular, I'll discuss linear and dependent types in
the context of describing more and more singletons.</p>




<p>In <a href="http://gallium.inria.fr/blog/singleton-types-for-code-inference">the previous
post</a>,
I discussed a code inference construction <code>(Γ |- ? : σ)</code> that would be
replaced, after type-checking, by the unique term <code>t</code> of type <code>σ</code>
(modulo program equivalence) in the environment Γ, or fail if no term
or several distinct terms exist at type σ.</p>

<h2>More singletons</h2>

<a onclick="switchContent('post7','post8')" class="btn" href="#5545255706f634a2dd689cddc5f36692">Read more...</a></div><div id="post8" style="display: none"><p>In this post you can find out what was cut from the <a href="http://gallium.inria.fr/blog/singleton-types-for-code-inference">previous post on
singleton
types</a>. These are
more technical considerations that may require some familiarity with
type theory. In particular, I'll discuss linear and dependent types in
the context of describing more and more singletons.</p>




<p>In <a href="http://gallium.inria.fr/blog/singleton-types-for-code-inference">the previous
post</a>,
I discussed a code inference construction <code>(Γ |- ? : σ)</code> that would be
replaced, after type-checking, by the unique term <code>t</code> of type <code>σ</code>
(modulo program equivalence) in the environment Γ, or fail if no term
or several distinct terms exist at type σ.</p>

<h2>More singletons</h2>

<p>I have argued that the terms we will look for should live in
a different term language than the host language in which we would
consider using code-inference, to restrict ourselves to well-behaved,
pure terms. Any term language is fine as long as it can be embedded
into the host language, and can reasonably be shown to the user: you
may want to keep the <code>?</code> in the source code, but also sometimes show
the inferred term to the user, to help program understanding, or
because finding the term was the point as in my example of "I forgot
the argument order".</p>

<p>Another point of variability in the type system: we can in fact pick
any type system we want: in the most explicit form where the user
would write <code>(Γ |- ? : σ)</code> in the source, the type <code>σ</code> could live in
the type system for code inference, and not be a type expressions in
the host language. We only need to be able to translate the inferred
<em>terms</em> back into the host term language (and then we can verify
that they are type-correct if we don't trust the term
inference engine).</p>

<p>The embedding of the host type system to the type system for code
inference could be partial: maybe we won't be able to handle some of
the types inferred by the host system when using the simple <code>?</code>
construction, and those cases would fail with an error. The more
interesting aspect is that we can also have <em>finer types</em> in the
type system for code inference. For example, we can have linear
types.</p>

<p>For example, <code>∀α. (α → α → α) → α → α</code> is not a singleton type: it is
inhabited by <code>fun f x -&gt; x</code>, but also <code>fun f x -&gt; f x x</code>, <code>fun f x -&gt;
f x (f x x)</code>, etc. However, <code>∀α. (α → α → α) → α ⊸ α</code>, where the last
arrow is the linear arrow <code>⊸</code> (<code>-o</code> in glorious ASCII) which means "use
my argument exactly once", is a singleton type.</p>

<p>This suggests some experiment with finer type systems. For example,
<code>(β→γ) → (α*β*α) → (α*γ*α)</code> is not a singleton type:
the first and third components of the input tuple, of the same
type α, could be swapped in the output. But there are some type
systems (some of which my coworker Julien is working on) that are
somehow stricter than linear type systems in that they request not
only each input to be consumed exactly once, but its structure to be
preserved (no swapping of pair elements, etc.). Consider for example
a language of subtyping coercions: if you have a coercion of type
<code>β ≤ γ</code> in context, then there is only one coercion of type
<code>(α * β * α) ≤ (α * γ * α)</code>, and if seen as a function it does not
swap the tuple components.</p>

<p>We can observe the difference between the usual arrow <code>→</code>, the
linear arrow <code>⊸</code> and a notion of structure-preserving arrow
sketched above, that I would write <code>⇒</code>, on the type of <code>List.map</code>:</p>

<ul>
<li><p><code>∀αβ. (α → β) → (List α → List β)</code> is inhabited by any function
that applies its function argument to the elements of its list
argument, but may drop or reorder some of them. For example,
always returning the empty list is ok.</p></li>
<li><p>the inhabitants <code>∀αβ. (α ⊸ β) → (List α ⊸ List β)</code> are not
allowed to drop elements from the input list anymore, but may
still reorder them. <code>[x1,x2] ↦ [f x2, f x1]</code> is ok</p></li>
<li><p>the inhabitants of <code>∀αβ. (α ⇒ β) → (List α ⇒ List β)</code> must
preserve the structure of the input list, neither reordering nor
dropping elements; it is a singleton type. I think of it as the
coercion <code>(α ≤ β) |- List α ≤ List β</code> turned into a term.</p></li>
</ul>

<p>(You may be unsure what the <code>→</code> arrow between the function argument
and rest means in the two latter example. I am as well.)</p>

<h2>Towards dependent types</h2>

<p>Of course, another obvious direction to refine the type system is to
introduce dependent types (and refinement types, etc.). Consider the
type of List.fold_right: <code>∀αβ. (α → β → β) → (List α → β → β)</code>: in
this case, using linear or structure-preserving arrows does not get
us a singleton type, because there is no structure in the return
type <code>β</code> to be preserved. However, a dependent type for <code>fold_right</code>
on lists (with arguments reordered for readability) is a singleton:</p>

<pre><code>∀α ∀(P : List α → ★).
  P nil →
  (∀(x : α) (xs : List α). P xs → P (cons x xs)) → 
  ∀(li : List α). P li
</code></pre>

<p>Of course, you may notice that writing this type is in no way easier
than writing the corresponding term:</p>

<pre><code>let rec fold init f = function
  | nil -&gt; init
  | cons x xs -&gt; f x xs (fold init xs)
</code></pre>

<p>If you move to sophisticated enough type systems, the idea that
"types help you infer code" becomes a bit of cheating as writing the
types themselves is just as much work as writing the terms. The idea of
using singleton types for code inference is not a magic wand that
will have you suddenly write order of magnitudes less <em>stuff</em>,
rather one principled way to move between term implementation and
type specification, type and code inference, and to study the
practical aspects under different points of view. The study of
singleton types in sufficiently sophisticated type systems may turn
out to be of theoretical rather than practical interest, but it's
enough for me, because it looks <em>fun</em>.</p>

<h3>Singleton types?</h3>

<p>The concept of singleton types already exists in the literature in
a quite different form: for any term <code>M</code>, we can consider the type
<code>(= M)</code> which classifies the set of programs... equal to <code>M</code>. This has
been found quite useful by the people working on module systems to
capture just the level of dependent types needed to express public
type declarations in a module signature (they're used one level up:
singleton <em>kinds</em> that publish equalities with a <em>type</em>; but the
term/type level is more convenient for explanations).</p>

<p>Of course, the type <code>(= M)</code> is clearly a singleton type, and if you
determine that a type σ has a unique inhabitant <code>t</code>, this should be
equivalent to saying that you've discovered an equality between <code>σ</code>
and the singleton type <code>(= t)</code>. For example, if <code>∀αβ.(α*β)→(β*α)</code> is
"a singleton type" then it is the same type as
<code>(= λ(x,y).(y,x))</code>. This means that you could do everything of
interest by adding this notion of singleton types <code>(= M)</code> in your
language, and proving type equalities between regular types and this
explicit form of singletons.</p>

<p>However that only works if the <em>host</em> language and the <em>search</em>
language are the same. If I use singleton types to infer code in OCaml
or Haskell, I'll want to infer stuff from <code>∀αβ.(α*β)→(β*α)</code> while this
type is not equal to <code>(= λ(x,y).(y,x))</code> in the host language. I'd
rather keep the two different notions of singleton types separate, to
emphasize that my focus here is on code inference, not equality
reasoning (which, again, may not hold in the host language).</p>

<h2>Singleton types as "proof search"</h2>

<p>There is a nice interplay with Curry-Howard (already explicitly
employed in the previous works of Wells and Yakobowski): if we see
terms as proofs, we are interested in properties that have a <em>unique</em>
proof. I am not aware of logicians having worked on this question
(probably ignorance on my side), but to be fair mathematicians tend to
be interested in <em>existence</em> of proofs (the question of
type inhabitation) more than unicity. A good thing however is that
a large part of the literature on proof search is concerned with
finding <em>canonical</em> proofs, to avoid "redundancy" between proof
terms. Proof nets, uniform proofs, focusing are all somehow concerned
about this aspect (because proving meta-theorems about your proof
system is easier when proof objects are strongly structured). And it
turns out that the work to have more "canonical" proofs consists
exactly in finding representations where less different proofs are
equivalent as programs. This is an excellent excuse to learn more
about the proof search literature, to see if we can find ideas inside
that are helpful to determine singleton types.</p>

<p>As a form of proof search, there is also a clear relation with
<em>tactics</em> (or maybe even more with this fascinating Emacs gadget
that Agda users have, that allows them to interactively refine proof
goals with "obvious" steps according to the shape of the goal). <code>?</code>
is a specific kind of tactics that is interested not only in finding
some proof term, but in the details of its dynamic semantics. Are
there other "tactics" that are also useful for programming rather
than proving?</p>

<h2>A closing remark and a quote</h2>

<p>Some readers will have recognized some example of types I gave here as
examples of reasoning on parametricity. The fact that <code>∀α.α→α</code> is only
inhabited by the identity function is, for example, often argued by
invoking the kind of results of "Theorems for free!". But a simple
algorithm to find singletons will simply prove that there is only one
correct βη-normal form of this type: first you have to use a Λαλ(x:α)
by η-expanding, and then you have nothing to use as a function body in
your context other than (x:α).</p>

<p>I'll remark that the link between parametricity and singleton types is
maybe weaker than it could seem, as a practical algorithm to determine
that types are singleton will rather work by trying to exhaust the
search space for terms, than reasoning on semantic relations derived
from the type -- but who knows. Let's say, at least, that I understand
term search better than I understand parametricity, a topic on which
I suspect we have still a lot to find out.</p>

<p>Let me conclude with
a nice 2011 quote from Conor McBride <a href="http://www.quora.com/Why-do-programming-languages-use-type-systems">on
Quora</a>
(no idea why he put it there). </p>

<blockquote>
  <p>Whilst I don't want to gainsay the importance of types as a source
of corrective raspberry-blowing, I would like to offer the prospect
that types might have an active role to play, structuring the
process of program inference. Overloading allows you to get rid of
boring lumps of code if it can be figured out from
types. Datatype-generic programming uses representations of the
structure of types to calculate specific instances of
algorithm-schemes. Dependent type systems often allow
run-time-relevant values to be inferred silently from type
information.</p>

<p>Crucially, also, types structure the search for programs in useful
ways, provided your editing environment offers you type information
and makes it easy to select type-appropriate choices. Sometimes it's
easier to search for good programs in the space of well typed
programs, rather than in the space of ascii turds.</p>

<p>This position constitutes a change of viewpoint in the purpose of
types. If programs worked just the same with the types rubbed out,
then types would represent a form of piety often inadequate with
respect to testing. It's when types contribute information to
algorithm selection, design statements which program definitions
need merely refine, that they constitute a significant win.</p>

<p>To be fair, even in last century's typed languages, types had
a beneficial organisational effect on programmers. This century,
it's just possible types will have a comparable effect on
programs. Types are concepts and now mechanisms supporting
program-discovery as well as error-discovery. I think that's more
than just gravy.</p>
</blockquote><a onclick="switchContent('post8','post7')" class="btn" href="#5545255706f634a2dd689cddc5f36692">Hide</a></div></span>
<script type="text/javascript">function switchContent(id1,id2) {
     // Get the DOM reference
     var contentId1 = document.getElementById(id1);
     var contentId2 = document.getElementById(id2);
     // Toggle
     contentId1.style.display = "none";
     contentId2.style.display = "block";
     }</script></div>

  
    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
</body></html>
