<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: OCaml Planet</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contrinutors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="OCaml Planet" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it in your browser</a></li>
    <li><a href="../taste.html">A Hundred Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who is using it?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development tools</a></li>
    <li><a href="../documentation.html">Manuals and Cheat Sheets</a></li>
    <li><a href="../tutorials/#advanced">Advanced tutorials &amp; Papers</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">Github</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing lists</a></li>
    <li><a href="../planet/">OCaml Planet (blogs)</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml-lang.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>OCaml Planet
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

    <h1>OCaml Planet</h1>

    <p>The OCaml Planet aggregates various blogs from the OCaml
    community.  It is kindly provided
    by <a href="http://www.ocamlcore.com/">OCamlCore</a>.  If you
    would like to be added, read
    the <a href="http://www.ocamlcore.org/planet/">Planet
    subscription HOWTO</a>.</p>

    <br/>
    <div style="float: right; margin-right: 0; margin-top: 0" class="span2 planet-subscriptions"><em>Subscriptions</em>
      <ul><li><a href="http://alexleighton.tumblr.com/tagged/ocaml/rss">Alex Leighton</a></li><li><a href="http://blog.mestan.fr/feed/?cat=16">Alp Mestan</a></li><li><a href="http://andreiformiga.com/blog/?cat=5&feed=rss2">Andrei Formiga</a></li><li><a href="http://math.andrej.com/feed/">Andrej Bauer</a></li><li><a href="http://anil.recoil.org/feeds/atom.xml">Anil Madhavapeddy</a></li><li><a href="http://unnali.com/tag/ocaml/feed/">Arlen Cuss</a></li><li><a href="http://ashishagarwal.org/tag/ocaml/feed/">Ashish Agarwal</a></li><li><a href="http://www.blogger.com/feeds/7617521785419311079/posts/default">Cameleon news</a></li><li><a href="http://caml.inria.fr/news.en.rss">Caml INRIA</a></li><li><a href="http://camlspotter.blogspot.com/feeds/posts/default?alt=rss">Caml Spotting</a></li><li><a href="http://alan.petitepomme.net/cwn/cwn.rss">Caml Weekly News</a></li><li><a href="http://procrastiblog.com/category/ocaml/feed/">Christopher Conway</a></li><li><a href="http://coherentpdf.com/blog/?tag=ocaml&feed=rss">Coherent Graphics</a></li><li><a href="http://coq.inria.fr/news/feed">Coq</a></li><li><a href="http://erratique.ch/feeds/news.atom">Daniel Bünzli</a></li><li><a href="http://blog.dbpatterson.com/rss">Daniel Patterson</a></li><li><a href="http://nleyten.com/atom.aspx">Dario Teixeira</a></li><li><a href="http://www.blogger.com/feeds/17133288/posts/default/-/ocaml">David Baelde</a></li><li><a href="http://bentobako.org/david/blog/index.php?feed/tag/ocaml/atom">David Mentré</a></li><li><a href="http://dutherenverseauborddelatable.wordpress.com/category/ocaml/feed/">David Teller</a></li><li><a href="http://www.examachine.net/blog/?feed=rss2&cat=4">Eray Özkural</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/CodeHacking/Ocaml/index.rss20">Erik de Castro Lopo</a></li><li><a href="http://blog.emillon.org/feeds/ocaml.xml">Etienne Millon</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/FP-Syd/index.rss20">FP-Sydney</a></li><li><a href="http://www.blogger.com/feeds/8964007124326996693/posts/default/-/ocaml">Fayssal Martani</a></li><li><a href="http://frama-c.com/rss.xml">Frama-C</a></li><li><a href="http://functionaljobs.com/jobs/search/?q=ocaml&format=rss">Functional Jobs</a></li><li><a href="http://gallium.inria.fr/~scherer/gagallium/index.rss">GaGallium</a></li><li><a href="http://gaiustech.wordpress.com/category/ocaml/feed/">Gaius Hammond</a></li><li><a href="http://blog.camlcity.org/blog/rss">Gerd Stolpmann</a></li><li><a href="http://www.wisdomandwonder.com/tag/OCaml/feed">Grant Rettke</a></li><li><a href="http://blog.incubaid.com/tag/ocaml/feed/">Incubaid Research</a></li><li><a href="http://ambassadortothecomputers.blogspot.com/feeds/posts/default?alt=rss">Jake Donham</a></li><li><a href="http://scattered-thoughts.net/rss?tag=ocaml">Jamie Brandon</a></li><li><a href="http://ocaml.janestcapital.com/?q=rss.xml">Jane Street</a></li><li><a href="http://www.lexifi.com/blogs/ocaml/feed">LexiFi</a></li><li><a href="http://savonet.sourceforge.net/liquidsoap.rss">Liquidsoap</a></li><li><a href="http://syntaxexclamation.wordpress.com/tag/ocaml/feed/">Matthias Puech</a></li><li><a href="http://www.blogger.com/feeds/5888658295182480819/posts/default">Matías Giovannini</a></li><li><a href="http://eigenclass.org/R2/feeds/rss2/all">Mauricio Fernandez</a></li><li><a href="http://www.elehack.net/michael/blog/tags/ocaml?format=rss">Michael Ekstrand</a></li><li><a href="http://www.rktmb.org:82/feed/category/work/ocaml/atom">Mihamina Rakotomandimby</a></li><li><a href="http://nyc-ocaml.posterous.com/rss.xml">NYC OCaml</a></li><li><a href="http://ocamlhackers.ning.com/profiles/blog/feed?tag=ocaml&xn_auth=no">OCaml Hackers</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfnews.php">OCamlCore Forge News</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfprojects.php">OCamlCore Forge Projects</a></li><li><a href="http://www.ocamlcore.com/wp/?feed=rss2&amp;language=en&#038;language=en">OCamlCore.com</a></li><li><a href="http://www.ocamlpro.com/feed/atom.xml">OCamlPro</a></li><li><a href="http://odns.tuxfamily.org/feed/">ODNS project</a></li><li><a href="http://ox.tuxfamily.org/feed/">Ocaml XMPP project</a></li><li><a href="http://ocsigen.org/news.atom">Ocsigen project</a></li><li><a href="http://www.blogger.com/feeds/2073503406800427577/posts/default">Opa</a></li><li><a href="http://www.openmirage.org/blog/atom.xml">Open Mirage</a></li><li><a href="http://www.donadeo.net/facets/programming-languages/objective-caml/feed/">Paolo Donadeo</a></li><li><a href="https://mancoosi.org/~abate/taxonomy/term/5/0/feed">Pietro Abate</a></li><li><a href="http://redlizards.com/blog/feed/?tag=ocaml">Red Lizard Software</a></li><li><a href="http://rwmj.wordpress.com/tag/ocaml/feed/">Richard Jones</a></li><li><a href="http://blog.rastageeks.org/spip.php?page=rss&id_mot=2">Romain Beauxis</a></li><li><a href="http://seb.mondet.org/blog/feed/ocaml.rss">Sebastien Mondet</a></li><li><a href="http://upsilon.cc/~zack/tags/ocaml/index.rss">Stefano Zacchiroli</a></li><li><a href="http://le-gall.net/sylvain+violaine/blog/index.php?feed/tag/ocaml/atom">Sylvain Le Gall</a></li><li><a href="http://caml.inria.fr/hump.rss">The Caml Humps</a></li><li><a href="http://www.blogger.com/feeds/6115529230232389198/posts/default">Till Varoquaux</a></li><li><a href="http://www.nicollet.net/toroidal/ocaml/feed/">Victor Nicollet</a></li><li><a href="http://y-node.com/blog/feeds/tag/ocaml/">y-node</a></li></ul>

      <a href="http://planet.ocaml.org/rss20.xml"><img src=".././img/rss20.png"/></a>
      <a href="http://planet.ocaml.org/opml.xml"><img src=".././img/opml.png"/></a>
    </div>
    <div class="planet"><a name="c2fcb8b4aa00ad4abb174274b6a1d45f"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/~scherer/gagallium/singleton-types-for-code-inference"> Singleton types for code inference</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">29 Dec 2012</span></span><span class="rss-description"><div id="post1"><p>Could the compiler <em>guess</em> a part of the program I am
currently writing? It's impossible in general, but it may be possible,
and hopefully interesting, in special cases. For a start, I am
interested in a situation where there is <em>only one possibility</em>: at
the expected type, there is only one possible program -- modulo
(an approximation of) program equivalence.</p>

<p>In a fixed environment, a type is a <em>singleton type</em> if it has only
one inhabitant. How widespread are those? Would a language feature to
infer their inhabitants be useful? Can we have more interesting
singleton types by enriching the type system?</p>

<p>Don't expect a structured story with a happy ending: this is only
a writing-ideas-down session for something I have been thinking about
lately.</p>




<h2>From erasable coercions to singleton types</h2>

<a onclick="switchContent('post1','post2')" class="btn" href="#c2fcb8b4aa00ad4abb174274b6a1d45f">Read more...</a></div><div id="post2" style="display: none"><p>Could the compiler <em>guess</em> a part of the program I am
currently writing? It's impossible in general, but it may be possible,
and hopefully interesting, in special cases. For a start, I am
interested in a situation where there is <em>only one possibility</em>: at
the expected type, there is only one possible program -- modulo
(an approximation of) program equivalence.</p>

<p>In a fixed environment, a type is a <em>singleton type</em> if it has only
one inhabitant. How widespread are those? Would a language feature to
infer their inhabitants be useful? Can we have more interesting
singleton types by enriching the type system?</p>

<p>Don't expect a structured story with a happy ending: this is only
a writing-ideas-down session for something I have been thinking about
lately.</p>




<h2>From erasable coercions to singleton types</h2>

<p>I started to think about this kind of singleton types seriously when
discussing with one of our fellow students at Gallium, <a href="http://gallium.inria.fr/~jcretin/">Julien
Cretin</a>. Julien has been working on
coercions for long enough that, if you listen to him, basically
anything in a type system is a coercion in disguise. But for the most
part he has worked on <em>erasable coercions</em>, that are terms from a type
<code>A</code> to a type <code>B</code> that are just the identity function (once you erase
the type annotations that make them useful).</p>

<p>One example in System F is the coercion</p>

<pre><code>λ(f:A→∀α.B). Λα.λ(x:A). f x α
</code></pre>

<p>from <code>A→∀α.B</code> to <code>∀α.(A→B)</code>. Note that if you erase all the type
annotations (including type abstractions and applications), this
becomes just <code>λfλx. f x</code>, which is an η-expansion of the identity
function. Those identities are "erasable" in the sense that, after the
type-checking phase, you can just drop them from your program and you
will never notice: they do not affect the runtime semantics of the
program.</p>

<p>Erasable coercions are fairly interesting as a way to structure and
explain type systems. For example, they allow to understand various
variants of System F (System Fη, Fsub, and MLF) as instances of
a general version of System F enhanced with abstraction on coercions,
whose formal study is surprisingly challenging. You can learn about
this in <a href="http://gallium.inria.fr/~remy/coercions/Cretin-Remy:coercions@popl2012.pdf">Julien's 2012 paper with Didier
Rémy</a>
(<a href="http://hal.inria.fr/docs/00/60/85/66/PDF/full.pdf">long version</a>).</p>

<p>But what would be a notion of <em>non-erasable</em> coercion? My suggestion
was to consider terms that may not exactly be the identity, but that
are unique at their type. This is actually a fairly different concept:
some coercions (for example <code>int → int</code>) are not unique in their
types, and some unique inhabitants (for example in <code>∀αβ.(α*β)→(β*α)</code>)
have a runtime behavior that is fairly different from the identity.</p>

<h2>Singleton types in practice</h2>

<p>As a thought experiment, imagine adding the keyword <code>?</code> in the
syntactic class of expressions of your programming language. The
semantics of <code>?</code> is as follows: at typing time, it can take absolutely
any type and will never raise a type error. After the program has been
verified to be type-correct, we look at each occurrence of <code>?</code> and its
inferred type. If the type is a singleton (assume we know how to
check this), we replace <code>?</code> with the unique inhabitant, otherwise we
fail with an error.</p>

<p>That's an inference-centered point of view. In languages with less
robust type inference than ML languages, we could have a more robust
feature with a construction <code>(? : σ)</code> that is given a precise type,
which should later turn out to be a singleton. A simple <code>?</code> is then
explained as <code>(? : _)</code>, where <code>_</code> means "infer me" at the type level.</p>

<p>Consider for example those lines of OCaml or Haskell code found in
the wild (in fact in the OCaml type-checker and in GHC):</p>

<pre><code>(List.map (fun (name, smty, smodl) -&gt; (name, smty))

zipWith3M f xs ys zs =
  zipWithM (\x -&gt; \(y,z) -&gt; (f x y z)) xs (zip ys zs)
</code></pre>

<p>The functions passed to <code>List.map</code> and <code>zipWithM</code> here are the
typical kind of boilerplate that is boring to write. Provided that
"the types are distinct enough", they are also singleton types: <code>fun
(x,y,z) -&gt; (x,y)</code> is a singleton type as long as the types for <code>x</code>,
<code>y</code> and <code>z</code> are distinct (in this example I checked and they are),
likewise in the second example. Wouldn't it be nice to be able to write:</p>

<pre><code>(List.map ?)

zipWith3M f xs ys ys = zipWithM (? f) xs (zip ys zs)
</code></pre>

<p>The hope is that some of the case where you think "This is dumb,
I should not have to write it" may turn out to be, when looking at
them the right way, inferrable through singleton types.</p>

<h2>Singleton types precisely</h2>

<p>What does it mean for a type to be a singleton type? We have to make
a choice on four aspects:</p>

<ul>
<li><p>The type system we consider (the static semantics). Are we looking
for singleton types in ML, in System F, in a dependently typed
calculus? All those choices have merit, but for the purpose of the
demonstration I will mostly use examples in System F.</p></li>
<li><p>The language of the terms we infer (the dynamic semantics). If we
consider the full term language of OCaml (or Haskell) as the space
of our search, no interesting type is a singleton because of
non-terminating terms inhabiting any type. We want to restrict
ourselves to a pure (including total) lambda-calculus. For a start,
just the obvious explicitly typed thing with variables, lambdas and
applications will be fine.</p></li>
<li><p>Our notion of program equivalence: if we consider <code>t</code> and <code>(λx.x) t</code>
as two different programs, we will have trouble finding unique
inhabitants. On the other end, observational equivalence is often
undecidable for realistic languages, so we may have to pick
reasonable restrictions. I will just imagine I can perfectly decide
observational equivalence for now.</p></li>
<li><p>The typing context where inhabitants live: I am asking whether a type
<code>σ</code> has a unique inhabitant <code>t : σ</code>. To consider this properly
I need to pick a typing context <code>Γ</code> and ask about <code>Γ ⊢ ? : σ</code>. We
could imagine giving the user some freedom to specify the context in
which the search should take place. A good starting choice is to
consider the super-empty context: a context with no variables, but
also <em>no constants</em>: forget about <code>0, 1, 2, true, false</code>, etc., to
get even more singleton types (<code>bool → int → bool</code>,
for example). Other reasonable choices include the empty context
with constants, the current context of the program, or a restriction
of the current context with only the variables that have been marked
"implicit" of sorts.</p></li>
</ul>

<p>The restriction to an empty context is why I wrote <code>(? f)</code> in the
previous example:</p>

<pre><code>zipWithM3 f xs ys zs = zipWithM (? f) xs (zip ys zs)
</code></pre>

<p>If I just write <code>zipWithM ? xs ..</code>, this tries to infer code at the
type <code>(a → (b, c) → m d)</code>, which is not inhabited in an empty
context. On the contrary, the <code>?</code> in <code>(? f)</code> has type
<code>(a → b → c → m d) → (a → (b, c) → m d)</code>, which is a singleton
type. This shows that this construct can actually be used for
<em>partial</em> term inference, just add the hints as parameters to
<code>?</code>. (Another possibility would be to add syntax to specify
a context by hand, eg. <code>(f,g |- ? : σ)</code>.)</p>

<p>Similarly, it can also be used for plumbing: if you cannot remember
which of <code>x</code> or <code>y</code> comes first as a parameter to <code>f</code>, and they have
different types, <code>(? f x y)</code> can do the job. (If they don't have
different types there is a potential for non-statically-catchable
error and that's bad. OCaml's <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual006.html#toc35">labeled
arguments</a>
are very nice when used to fight this, but it's orthogonal to the
present considerations.)</p>

<h2>Related Work</h2>

<p>I know of surprisingly little work on the topic of "code inference"
(looking for this search string on Google Scholar for example brings
up very little hits), and would welcome pertinent pointers. There is
a paper at PLDI last year, <a href="http://research.microsoft.com/en-us/um/people/sumitg/pubs/pldi12.pdf">Type-Directed Completion of Partial
Expressions</a>
by Daniel Perelman, Sumit Gulwani, Thomas Ball and Dan Grossman, but
it is much more practically oriented: "let's look for completions
using typing hints and see how often we were right in ranking highly
a suggestion to the user". In the limit, you get something fuzzy and
interactive and machine-learning-based, where type-correctness is just
one ranking criterion among others, as you can find in <a href="http://research.microsoft.com/en-us/people/smcdirm/">Sean
McDirmid</a>'s work
on touch-based programming or calls to <a href="http://www.cs.rutgers.edu/~ccshan/rational/pcr.pdf">Programming as collaborative
reference</a>, but
that is not where I want to go now. The idea here more to study the
mathematical structure of singleton types, which is quite a different
subject.</p>

<p>Of course, "singleton types" is just a special case: it could also be
interesting for code inference to determine which types have only two
inhabitants; the compiler then wouldn't choose automatically
(that would break principality) but instead give the choice to the
user. Joe B. Wells has a paper with Boris Yakobowski (which is,
incidentally, a former <a href="http://gallium.inria.fr/~yakobows/">Gallium PhD
student</a>), <a href="http://www.macs.hw.ac.uk/~jbw/papers/#Wel+Yak:LOPSTR-2004-informal">Graph-based proof
counting and enumeration with applications for program fragment
synthesis</a>,
that does exactly this: count the number of inhabitants of types in an
intuitionistic type theory, and devise a term enumeration algorithm
out of it. It is the most pertinent previous work that I know of, and
was done with program synthesis in mind.</p>

<h2>Singleton types and programming experience</h2>

<p>I've mentioned that singleton types is only one specific case in the
wider setting of "please find me the inhabitants of this
type". I think however that focusing on singleton types is maybe not
as ad-hoc at is looks like: if a type has a finite number of
inhabitants, it can probably be decomposed as a sum of singleton
types. Maybe we could tell to the user of our <code>?</code> construction that
"you're not a singleton yet, you have to make a choice between this
type and this type", and let him add just enough information to
determine which situation she's interested in. That would be
potentially even more useful than enumerating the full terms and
letting the user choose one, as <code>?</code> may be more robust in the face of
code maintenance than system-spewed boilerplate.</p>

<p>More robust, or more fragile: being a singleton is not stable by
instantiation. The type <code>∀αβ. α*β → β*α</code> is a singleton, but
instantiating <code>α:=int, β:=int</code> breaks this property. (Note that it
is interesting in practice only if the type is inferred,
because it is just as long as the term.). People are
surprised/dismayed by this aspect when I give them examples of
singleton types, but I think it's fine: we are checking singletons
<em>after</em> type inference, where type abstractions and applications
have been fully determined. Yet I don't know how robust those <code>?</code>
would be in practice. I think the idea of doing all this <em>after</em>
type inference is a sane protection: I have this intuition that we
probably don't want a system that tries to infer <em>simultaneously</em>
the types of some part of our program, and the terms of another.</p>

<p>Note that it is possible to see the work on type classes as a specific
instance of the idea of singleton types. Using an operation of a type
class would add a <code>?</code> to synthesize the expected dictionary. Instance
declarations are function declarations (instance dependencies being
function arrows) that populate the context of search. The coherence
relations that reduce ambiguities in Haskell are a way to ensure
unicity of inhabitants. Finally, inference of class predicates
(the way <code>Eq a =&gt;</code> gets added to an inferred function type if you use
<code>(==)</code> inside the body of the function) is a way to ensure that there
is always an inhabitant.</p>

<p>This is not a realization of the highest importance, because it
actually tells us little new about type classes; singletons are
a rather general way to look at everything that involves some form of
"guessing code" that is a bit principled (and doesn't just produce
code at random); this recasting should work for other features that
can be expressed as code inference. It tells us, however, that some
particular forms in the design space for putting singleton types in
practice have already found themselves useful enough for
programmers. I think that justifies looking at the concept at a wide
angle.</p>

<h2>A temporary ending -- or delay</h2>

<p>This post is getting quite long, so I'll temporarily conclude
here. Stay tuned for another blog post with even more ramblings about
singleton types !</p><a onclick="switchContent('post2','post1')" class="btn" href="#c2fcb8b4aa00ad4abb174274b6a1d45f">Hide</a></div></span>
<a name="442a8cf9808ce87d6f90546225bcb702"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/forum/forum.php?forum_id=867"> Macaque 0.6.1</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge News</span>, <span class="rss-date">26 Dec 2012</span></span><span class="rss-description"><pre class="rss-text">This is mostly a bugfix release: Jacques-Pascal Deplaix has spotted a bug in the way Macaque handles PostgreSQL rather baroque string escaping convention (you don't want to know the details), and after some head scratching we have a reasonable fix.

In addition, Petter Urkedal has contributed support for the 'bytea' and 'int32_array' datatypes; for now, there is no literal syntax to describe them in the syntax extension, so one should build values on the OCaml side, through Sql.Value.bytea and Sql.Value.int32_array.</pre></span>
<a name="e6c5dd3a656929c1664b08fc37901245"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2012.12.25.html"> Caml Weekly News, 25 Dec 2012</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">25 Dec 2012</span></span><span class="rss-description">new ocaml.org website / OCaml wiki / OCaml search into libraries for ocaml.org / Post-doc/Software Engineer at OCamlPro / Other Caml News</span>
<a name="e672efd955ba77a031ef9e8392474060"></a><span class="rss-header"><span class="rss-title"><a href="http://math.andrej.com/2012/12/25/free-variables-are-not-implicitly-universally-quantified/"> Free variables are not “implicitly universally quantified”!</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Andrej Bauer</span>, <span class="rss-date">25 Dec 2012</span></span><span class="rss-description"><div id="post3"><p>Mathematicians are often confused about the meaning of variables. I hear them say “a free variable is implicitly universally quantified”, by which they mean that it is ok to equate a formula $\phi$ with a free variable $x$ with its universal closure $\forall x \,.\, \phi$. I am addressing this post to those who share this opinion.</p>
<p><span id="more-1387"></span></p>
<p>I will give several reasons, which are all essentially the same, why “there is no difference between $\phi$ and $\forall x \,.\, \phi$” is a really bad opinion to have.</p>
<h3>Reason 1: you wouldn’t equate a function with its definite integral</h3>
<p>You would not claim that a real-valued function $f : \mathbb{R} \to \mathbb{R}$ is “the same thing” as its definite integral $\int_{\mathbb{R}} f(x) \, d x$, would you? One is a real function, the other is a real number. Likewise, $\phi$ is a truth &lt;emph&gt;function&lt;/emph&gt; and $\forall x \,.\, \phi(x)$ is a truth &lt;emph&gt;value&lt;/emph&gt;.</p>
<h3>Reason 2: functions are not their own values</h3>
<a onclick="switchContent('post3','post4')" class="btn" href="#e672efd955ba77a031ef9e8392474060">Read more...</a></div><div id="post4" style="display: none"><p>Mathematicians are often confused about the meaning of variables. I hear them say “a free variable is implicitly universally quantified”, by which they mean that it is ok to equate a formula $\phi$ with a free variable $x$ with its universal closure $\forall x \,.\, \phi$. I am addressing this post to those who share this opinion.</p>
<p><span id="more-1387"></span></p>
<p>I will give several reasons, which are all essentially the same, why “there is no difference between $\phi$ and $\forall x \,.\, \phi$” is a really bad opinion to have.</p>
<h3>Reason 1: you wouldn’t equate a function with its definite integral</h3>
<p>You would not claim that a real-valued function $f : \mathbb{R} \to \mathbb{R}$ is “the same thing” as its definite integral $\int_{\mathbb{R}} f(x) \, d x$, would you? One is a real function, the other is a real number. Likewise, $\phi$ is a truth &lt;emph&gt;function&lt;/emph&gt; and $\forall x \,.\, \phi(x)$ is a truth &lt;emph&gt;value&lt;/emph&gt;.</p>
<h3>Reason 2: functions are not their own values</h3>
<p>To be quite precise, the expression $\phi$ by itself is not a function, just like the expression $x + \sin x$ is not a function. To make it into a function we must first &lt;emph&gt;abstract&lt;/emph&gt; the variable $x$, which is usually written as $x \mapsto x + \sin x$, or $\lambda x \,.\, x + \sin x$, or <code>fun x -&gt; x +. sin x</code>. In logic we indicate the fact that $\phi$ is a function by putting it in a &lt;emph&gt;context&lt;/emph&gt;, so we write something like $x : \mathbb{R} \vdash \phi$.</p>
<p>Why is all this nit-picking necessary? Try answering these questions with “yes” and “no” consistently:</p>
<ol>
<li>Is $x + \sin x$ a function in variable $x$?</li>
<li>Is $x + \sin x$ a function in variables $x$ and $y$?</li>
<li>Is $y – y + x + \sin x$ a function in variables $x$ and $y$?</li>
<li>Is $x + \sin x = y – y + x + \sin x$?</li>
</ol>
<p>A similar sort of mistake happens in algebra where people think that polynomials are functions. They are not. They are elements of a certain freely generated ring.</p>
<h3>Reason 3: They are not logically equivalent</h3>
<p>It is absurd to claim that $\phi$ and $\forall x \in \mathbb{R} \,.\, \phi$ are logically equivalent statements. Suppose $\forall x \in \mathbb{R} \,.\, x &gt; 2$ were equivalent to $x &gt; 2$. Then I could replace one by the other in any formula I wish. So I choose the formula $\exists x \in \mathbb{R} \,.\, x &gt; 2$. It must be equivalent to $\exists x \in \mathbb{R} \,.\, \forall x \in \mathbb{R} \,.\, x &gt; 2$, but since $\forall x \in \mathbb{R} \,.\, x &gt; 2$ is false, we get $\exists x \in \mathbb{R} \,.\, \bot$, which is false. We proved that there is no number larger than 2.</p>
<h3>Reason 4: They are not inter-derivable</h3>
<p>If you can tell the difference between an implication and logical entailment, perhaps you might try to counter reason 3 by pointing out that $\phi$ and $\forall x \,.\, \phi$ are either both derivable, or both not derivable. That is to say, we can prove one if, and only if, we can prove the other. But again, this is not the case. We can prove $\forall x \in \emptyset \,.\, \bot$ but we cannot prove $\bot$.</p>
<h3>Reason 5: Bound variables can be renamed but free variables cannot</h3>
<p>The formula $x &gt; 2$ is obviously not the same thing as the formula $y &gt; 2$. But the formula $\forall x \in \mathbb{R} . x &gt; 2$ is actually the same as $\forall y \in \mathbb{R} . y &gt; 2$. If you find this confusing it is because you were never taught properly how to handle <a href="http://en.wikipedia.org/wiki/Free_variables_and_bound_variables">free and bound variables</a>.</p>
<h3>Reason 6: You cannot prove $\forall x \,.\, \phi$ without allowing $x$ to become free</h3>
<p>Perhaps we can just forbid free variables altogether and &lt;emph&gt;stipulate&lt;/emph&gt; that all variables must always be quantified. But how are you then going to prove $\forall x \in \mathbb{R} \,.\, \phi$? The usual way</p>
<blockquote><p>
“Consider any $x \in \mathbb{R}$. Then bla bla bla, therefore $\phi$.”
</p></blockquote>
<p>is now forbidden because the first sentence introduces $x$ as a free variable.</p>
<p>We can abolish variables altogether if we wish, by resorting to combinators, but it makes no sense to keep variables and make them all bound all the time.</p>
<h3>Epilogue: so in what sense are they the same?</h3>
<p>There is a theorem in model theory:</p>
<blockquote><p>
Let $\phi$ be a formula in context $x_1, \ldots, x_n$ and $M$ a structure in which we can interpret $\phi$. The following are equivalent:</p>
<ol>
<li>the universal closure $\forall x_1, \ldots, x_n \,.\, \phi$ is valid in $M$,</li>
<li>for every valuation $\nu : \lbrace x_1, \ldots, x_n \rbrace \to M$, $\phi[\nu]$ is valid in $M$.</li>
</ol>
</blockquote>
<p>This is sometimes abbreviated (quite inaccurately) as “a formula and its universal closure are semantically equivalent”. This theorem is causing a lot of harm because mathematicians interpret it as “free variables are implicitly universally bound”. But the theorem itself clearly distinguishes a formula from its universal closure. It has a limited range of applications in model theory. It is not a general reasoning principle that would allow you to dispose of thinking about free variables.</p>
<p>You are in good company. Philosophers have thought about free variables for millennia, although they phrase the problem in the language of <a href="http://en.wikipedia.org/wiki/Universal_(metaphysics)">universals</a> and <a href="http://en.wikipedia.org/wiki/Particular">particulars</a>. They wonder whether “dog” is the same thing as the set of all dogs, or perhaps there is an ideal dog which is “pure dogness”, but then do we need two ideal dogs to make ideal pups, etc. The answer is simple: a free variable is a projection from a cartesian product.</p><a onclick="switchContent('post4','post3')" class="btn" href="#e672efd955ba77a031ef9e8392474060">Hide</a></div></span>
<a name="2f9fc6a8ae811c870e3859f2689319a7"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/tptp/"> tptp</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">21 Dec 2012</span></span><span class="rss-description">Library for parsing FOF and CNF formulas from TPTP format. Depends on: zarith.</span>
<a name="7848ce5e403469fa5a3757e71a0f8191"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=817"> Xtmpl 0.5</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">19 Dec 2012</span></span><span class="rss-description">Xtmpl is a small XML templating library for OCaml.</span>
<a name="7ff089ca4b443c810138d4a7c8e8b486"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=818"> Stog 0.5</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">19 Dec 2012</span></span><span class="rss-description">Stog is a kind of Jekyll in OCaml: It is a static web site generator, able to handle blog posts as well as regular pages.</span>
<a name="3aeebe7a5873af158331e6566e6c7b25"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/cryptodbm/"> Cryptodbm: Encrypted dbm</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">18 Dec 2012</span></span><span class="rss-description">Library for creating and reading encrypted databases (serverless, encrypted key-value databases).</span>
<a name="ebe2a7c57571bc1eb87b0df1ac92c1c5"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2012.12.18.html"> Caml Weekly News, 18 Dec 2012</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">18 Dec 2012</span></span><span class="rss-description">new OPAM command-line interface / RTT (Run-time types) online toplevel for trying / Other Caml News</span>
<a name="cbef3ca3cfb05f18395bdae71d4ad36b"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/~scherer/gagallium/we-need-a-representative-benchmark-suite"> OCaml compiler optimizations: we need a representative benchmark suite</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">18 Dec 2012</span></span><span class="rss-description"><div id="post5"><p>This is a call to arms: to improve the OCaml compiler, we
sorely need a suite of representative benchmarks. If you have ever
written performance-sensitive programs in OCaml, you can
contribute.</p>




<p>PS: When I originally started to write this blog post, it was about
a small experiment on optimizing a small program for float
unboxing. Writing a general introduction on the few joys and numerous
pitfalls of compiler optimizations suddenly turned it into a totally
different post. Oh well.</p>

<h2>Having a simple compiler is a valid design choice</h2>

<p>The OCaml native compiler is well-known for its simple and robust
behavior. Thanks to efficient choices of value representation and
a sophisticated garbage collector (GC), it is able to make good OCaml
programs run fast. But it doesn't actually optimize in clever way:
efficient code will give an efficient program, but little is done to
make inefficient code efficient.</p>

<a onclick="switchContent('post5','post6')" class="btn" href="#cbef3ca3cfb05f18395bdae71d4ad36b">Read more...</a></div><div id="post6" style="display: none"><p>This is a call to arms: to improve the OCaml compiler, we
sorely need a suite of representative benchmarks. If you have ever
written performance-sensitive programs in OCaml, you can
contribute.</p>




<p>PS: When I originally started to write this blog post, it was about
a small experiment on optimizing a small program for float
unboxing. Writing a general introduction on the few joys and numerous
pitfalls of compiler optimizations suddenly turned it into a totally
different post. Oh well.</p>

<h2>Having a simple compiler is a valid design choice</h2>

<p>The OCaml native compiler is well-known for its simple and robust
behavior. Thanks to efficient choices of value representation and
a sophisticated garbage collector (GC), it is able to make good OCaml
programs run fast. But it doesn't actually optimize in clever way:
efficient code will give an efficient program, but little is done to
make inefficient code efficient.</p>

<p>This approach has some nice advantages. On the user side, it makes for
a predictable compiler (no hope of the killer optimization kicking in
when it actually doesn't due to a small change). On the developer
side we have a well-written and rather simple post-frontend that is
easy to understand and maintain. Compilation times are also usually
very small: with the additional good support for separate compilation,
compilation times is rarely a problem in OCaml as it can be in some
other compiled languages (<em>cough</em> C++ <em>cough</em>).</p>

<p>Yet this also comes with drawbacks. For example, "inefficient" code is
rarely written by OCaml programmers (smart men and women), of
course :), but is easy to obtain when you're doing automatic code
generation; you may have to be a bit careful if you produce OCaml
programs to not spit out stupid code, while a general whole-program
optimizer could have taken care of this for you.</p>

<p>Another problem is that some abstractions are more costly that we
would like them to be. It's hard to write monadic code, for example,
without generating a lot of (often unnecessary) closures. While the
cost of the additional closure allocations and function calls are
often drowned by the overall monadic logic (for example thread
scheduling in monadic cooperative threading libraries such as Lwt and
Async), fine-grained monad style can still have a sensible overhead.</p>

<p>For example, Arnaud Spiwak
<a href="https://sympa.inria.fr/sympa/arc/coq-club/2012-10/msg00013.html">reported</a>
that switching the Coq internal tactics to a pervasive monadic style
incurred sensible overhead (~15% slowdown on the whole Coq archive,
with some individual tactics getting several times slower). Using
Coq's inlining engine to maximally reduce monadic closures, he was
able to get a 10% performance gain over what "idiomatic monadic OCaml
code" produces through the OCaml compiler. (Remark that inlining is
easier to do in Coq thanks to a pure (including total) programming
language with sensible strong reduction semantics.)</p>

<p>Finally, not every programming style and application domain is equal
in the face of OCaml compilation choices. Memory allocation, tail
calls, exceptions and pattern matching on algebraic datatypes are
extremely fast, and code using lot of them (typically: a compiler,
a proof assistant, symbolic computations in general) will have you
extremely satisfied. But this sometimes required compromises that have
downsides for other language features, and the sophistication effort
that went there didn't necessarily find itself reproduced in other
parts of the language features that were of less interest at the time
of the compiler's inception.</p>

<p>As a concrete example, OCaml does not shine at number crunching: its
integers are tagged to make the GC life easier, and its
(double-precision) floating points are boxed to keep a uniform value
representation. The compiler is well aware of these facts and tries to
suppress this overhead when it is easy to do so, but those
optimization are relatively simple and have room for improvement.</p>

<p>This doesn't mean that OCaml should not be used when a problem domain
involves some number crunching: the benefit you can gain from
expressive language features and a reasonable type system may very
well outweigh, in terms of productivity and final code efficiency, the
approximate halving of performance (when compared to C) on numeric
benchmarks. A large number of people pay a sensibly higher performance
price to use less-efficient language everyday, for example Javascript
(even on today's highly-optimized runtimes, that took exponentially
more effort to develop than the OCaml native compiler).</p>

<h2>Compiler optimization is an ungrateful business</h2>

<p>Just above I've mentioned a few fronts (function inlining, local
unboxing or untagging) on which the OCaml compiler could possibly help
with more aggressive optimizations. There are other specific areas
where compilation choices could be improved. The problem with compiler
optimizations is that there is a large disconnect between what we,
compiler programmers and language geeks, find satisfying to work on,
and the hard reality of actual program performances.</p>

<p>It is easy to spend some months implementing and debugging, say,
a state-of-the-art register allocator, only to find out that it makes
practically no performance difference on the programs you have at
hand. Why then would the maintainer accept a large code change that
certainly introduces bug and doesn't provably improves over the naive
but simple and debugged-by-time current implementation?</p>

<p>If advertising for a change in a compiler with the argument that "the
generated code is much nicer", you're doing it wrong. It is
surprisingly often the case that while the generated code looks much
nicer to the naked eye, it is not actually faster on today's
overly-complicated processors. More importantly, it is generally the
case that said nicer code never actually appears in the hot section of
your program, and therefore produces no observable performance
change. Again, "if it ain't broke, don't fix it", it would be
unreasonable to accept a change that cannot demonstrate a real
improvement on a real program -- while it's generally easy to craft
micro-benchmark that demonstrate impressive improvements.</p>

<p>I have personally experienced this problem in <a href="http://caml.inria.fr/mantis/view.php?id=4800">the work on
PR#4800</a>. Currently,
OCaml optimizes tupled assignments such as <code>let (x,y,z) = (foo, bar, baz)</code>
to remove the tuple construction and destruction that would
happen per the naive pattern-matching semantics. However this only
works if the right-hand-side is syntactically a tuple, and would fail
for example on <code>let (x,y) = if foo then (bar, baz) else (foobar, foobaz)</code>.</p>

<p>Alain Frisch proposed a patch to optimize this (and some other)
situation, to make this multi-binding style more convenient to
use. I've spent some time reviewing the patch and proposing an
alternative implementation, but we've both been unable to find an
actual real-world example where adding this optimization made
a significant difference.</p>

<p>This is a delicate point because those optimizations are here to make
new abstractions available that were previously avoided. If we don't
observe any difference, maybe it is because OCaml programmers have
avoided that idiom so far, but would make convenient use of it if it
was cost-free. However, if we can't demonstrate a real example where
this optimization is important, it's probably not a good idea to
include it upstream.</p>

<h2>We really need a benchmark suite, and you can help</h2>

<p>What we really need is a benchmark suite that would contain
representative examples of real-world OCaml code. There is a handful
of benchmarks distributed with the compiler but they don't cover
much. Likewise, the programs in <a href="http://benchmarksgame.alioth.debian.org/u64q/ocaml.php">the
Shootout</a> are
too small to be representative of actual uses of OCaml.</p>

<p>This is why we currently use "big software" in OCaml to evaluate
performance changes (eg. bootstrap the OCaml compiler itself, or
compile Coq). Some big OCaml users have internal performance
testsuites (for example Pascal Cuoq, which works on Frama-C,
infrequently contributes performance-improving changes to the
OCaml compiler), but we severely lack an easily-available, informative
benchmark suite to evaluate performance changes.</p>

<p>This is a losing situation because optimization-related changes cannot
be reliably assessed in absence of representative code, and specific
problem domains that we can't measure against will not be improved.</p>

<p>The good thing with benchmark needs is that it's a problem the
community at large can efficiently solve in parallel. If everyone
contributed a piece of code that comes from real-world OCaml software
and is representative of its performance-critical part, we would have
a complete benchmark suite by now.</p>

<p>Feel free to <strong>contribute</strong> by providing, either here in the blog
comments or by mail (gabriel dot scherer at inria, or at gmail), your
benchmark program(s). Code that has few external dependencies and that
comes with a simple interface to parametrize running time is highly
preferred. Of course, an open source license is required (say MIT/BSD
or LGPL with linking exception).</p>

<p>What is a representative benchmark? A benchmark is representative when
performance changes observed in the benchmark will reliably be
reproducible against (some use cases of) the whole software it was
extracted or inspired from. The changes must be comparable in
magnitude: if a 80% performance change (improvement or degradation) in
the benchmark code results in a 0.5% performance change in the actual
software, it's difficult to rely on benchmark results to make design
compromises.</p><a onclick="switchContent('post6','post5')" class="btn" href="#cbef3ca3cfb05f18395bdae71d4ad36b">Hide</a></div></span>
<script type="text/javascript">function switchContent(id1,id2) {
     // Get the DOM reference
     var contentId1 = document.getElementById(id1);
     var contentId2 = document.getElementById(id2);
     // Toggle
     contentId1.style.display = "none";
     contentId2.style.display = "block";
     }</script></div>

  
    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
</body></html>
