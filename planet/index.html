<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: OCaml Planet</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contributors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="OCaml Planet" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it Online</a></li>
    <li><a href="../taste.html">100 Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who Is Using It?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a>
        <a href="http://langref.org/ocaml">langref.org</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
    <li><a href="../papers.html">Papers</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../releases/">Releases</a></li>
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development Tools</a></li>
    <li><a href="../books.html#manual">User Manual</a></li>
    <li><a href="../cheat_sheets.html">Cheat Sheets</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API Search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">GitHub</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing Lists</a></li>
    <li><a href="../planet/">Blogs</a></li>
    <li><a href="../meetings/">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>OCaml Planet
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

    <h1>OCaml Planet</h1>

    <p>The OCaml Planet aggregates various blogs from the OCaml
    community.  It is kindly provided
    by <a href="http://www.ocamlcore.com/">OCamlCore</a>.  If you
    would like to be added, read
    the <a href="http://www.ocamlcore.org/planet/">Planet
    subscription HOWTO</a>.</p>

    <br/>
    <div style="float: right; margin-right: 0; margin-top: 0" class="span2 planet-subscriptions"><em>Subscriptions</em>
      <ul><li><a href="http://alexleighton.tumblr.com/tagged/ocaml/rss">Alex Leighton</a></li><li><a href="http://feeds.feedburner.com/amirmc-ocaml">Amir Chaudhry</a></li><li><a href="http://andreiformiga.com/blog/?cat=5&feed=rss2">Andrei Formiga</a></li><li><a href="http://math.andrej.com/feed/">Andrej Bauer</a></li><li><a href="http://anil.recoil.org/feeds/atom.xml">Anil Madhavapeddy</a></li><li><a href="http://ashishagarwal.org/tag/ocaml/feed/">Ashish Agarwal</a></li><li><a href="http://www.blogger.com/feeds/7617521785419311079/posts/default">Cameleon news</a></li><li><a href="http://caml.inria.fr/news.en.rss">Caml INRIA</a></li><li><a href="http://camlspotter.blogspot.com/feeds/posts/default?alt=rss">Caml Spotting</a></li><li><a href="http://alan.petitepomme.net/cwn/cwn.rss">Caml Weekly News</a></li><li><a href="http://coherentpdf.com/blog/?tag=ocaml&feed=rss">Coherent Graphics</a></li><li><a href="http://coq.inria.fr/news/feed">Coq</a></li><li><a href="http://erratique.ch/feeds/news.atom">Daniel Bünzli</a></li><li><a href="http://nleyten.com:82/feed/tag/ocaml/atom">Dario Teixeira</a></li><li><a href="http://www.blogger.com/feeds/17133288/posts/default/-/ocaml">David Baelde</a></li><li><a href="http://blog.bentobako.org/index.php?feed/tag/ocaml/atom">David Mentré</a></li><li><a href="http://dutherenverseauborddelatable.wordpress.com/category/ocaml/feed/">David Teller</a></li><li><a href="http://www.examachine.net/blog/cat/ocaml/feed/">Eray Özkural</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/index.rss20">Erik de Castro Lopo</a></li><li><a href="http://blog.emillon.org/feeds/ocaml.xml">Etienne Millon</a></li><li><a href="http://www.blogger.com/feeds/8964007124326996693/posts/default/-/ocaml">Fayssal Martani</a></li><li><a href="http://frama-c.com/rss.xml">Frama-C</a></li><li><a href="http://functionaljobs.com/jobs/search/?q=ocaml&format=rss">Functional Jobs</a></li><li><a href="http://gallium.inria.fr/blog/index.rss">GaGallium</a></li><li><a href="http://gaiustech.wordpress.com/category/ocaml/feed/">Gaius Hammond</a></li><li><a href="http://blog.camlcity.org/blog/rss">Gerd Stolpmann</a></li><li><a href="http://www.wisdomandwonder.com/tag/OCaml/feed">Grant Rettke</a></li><li><a href="http://hongboz.wordpress.com/feed/">Hong bo Zhang</a></li><li><a href="http://blog.incubaid.com/tag/ocaml/feed/">Incubaid Research</a></li><li><a href="http://ambassadortothecomputers.blogspot.com/feeds/posts/default?alt=rss">Jake Donham</a></li><li><a href="http://scattered-thoughts.net/atom.xml">Jamie Brandon</a></li><li><a href="https://ocaml.janestreet.com/?q=rss.xml">Jane Street</a></li><li><a href="http://lpw25.net/rss.xml">Leo White</a></li><li><a href="http://www.lexifi.com/blogs/ocaml/feed">LexiFi</a></li><li><a href="http://newblog.0branch.com/rss.xml">Marc Simpson</a></li><li><a href="http://syntaxexclamation.wordpress.com/tag/ocaml/feed/">Matthias Puech</a></li><li><a href="http://www.blogger.com/feeds/5888658295182480819/posts/default">Matías Giovannini</a></li><li><a href="http://www.elehack.net/michael/blog/tags/ocaml?format=rss">Michael Ekstrand</a></li><li><a href="">Mihamina Rakotomandimby</a></li><li><a href="http://mcclurmc.wordpress.com/feed/">Mike McClurg</a></li><li><a href="http://nyc-ocaml.posterous.com/rss.xml">NYC OCaml</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfnews.php">OCamlCore Forge News</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfprojects.php">OCamlCore Forge Projects</a></li><li><a href="http://www.ocamlcore.com/wp/?feed=rss2&amp;language=en&#038;language=en">OCamlCore.com</a></li><li><a href="http://www.ocamlpro.com/feed/atom.xml">OCamlPro</a></li><li><a href="http://odns.tuxfamily.org/feed/">ODNS project</a></li><li><a href="http://ox.tuxfamily.org/feed/">Ocaml XMPP project</a></li><li><a href="http://ocsigen.org/news.atom">Ocsigen project</a></li><li><a href="http://www.blogger.com/feeds/2073503406800427577/posts/default">Opa</a></li><li><a href="http://www.openmirage.org/blog/atom.xml">Open Mirage</a></li><li><a href="http://functional-orbitz.blogspot.com/feeds/posts/default/-/planetocaml?alt=rss">Orbitz</a></li><li><a href="http://www.donadeo.net/facets/programming-languages/objective-caml/feed/">Paolo Donadeo</a></li><li><a href="https://mancoosi.org/~abate/taxonomy/term/5/0/feed">Pietro Abate</a></li><li><a href="http://rwmj.wordpress.com/tag/ocaml/feed/">Richard Jones</a></li><li><a href="http://blog.rastageeks.org/spip.php?page=rss&id_mot=2">Romain Beauxis</a></li><li><a href="http://seb.mondet.org/blog/feed/ocaml.rss">Sebastien Mondet</a></li><li><a href="http://upsilon.cc/~zack/tags/ocaml/index.rss">Stefano Zacchiroli</a></li><li><a href="http://le-gall.net/sylvain+violaine/blog/index.php?feed/tag/ocaml/atom">Sylvain Le Gall</a></li><li><a href="http://caml.inria.fr/hump.rss">The Caml Humps</a></li><li><a href="http://www.blogger.com/feeds/6115529230232389198/posts/default">Till Varoquaux</a></li><li><a href="http://y-node.com/blog/feeds/latest/">y-node</a></li></ul>

      <a href="http://planet.ocaml.org/rss20.xml"><img src=".././img/rss20.png"/></a>
      <a href="http://planet.ocaml.org/opml.xml"><img src=".././img/opml.png"/></a>
    </div>
    <div class="planet"><a name="95a7761a721456bf40e8c3358f475413"></a><span class="rss-header"><span class="rss-title"><a href="http://www.ocamlpro.com/blog/2013/04/22/monthly-04.html"> April Monthly Report</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author"><span id="ocaml_2">OCamlPro &#9001;thomas<abbr title="(at) &rarr; @">(at)</abbr>ocamlpro.com (Thomas Gazagnaire)&#9002;</span><script type="text/javascript"><!--;
local = "thomas";
h = "ocamlpro.com (Thomas Gazagnaire)";
hq = "ocamlpro.com%20(Thomas%20Gazagnaire)";
document.getElementById("ocaml_2").innerHTML = '<a href="mailto:' + local + '@' + hq + "\" >OCamlPro<\/a>";
//--></script></span>, <span class="rss-date">22 Apr 2013</span></span><span class="rss-description"><div id="post1"><p>This post aims at summarizing the activities of OCamlPro for the past month. As usual, we worked in three main areas: the OCaml toolchain, development tools for OCaml and R&amp;D projects.</p><h2>The toolchain</h2><p>Our multi-runtime implementation of OCaml had gained stability. <a href="http://ageinghacker.net/">Luca</a> fixed a lot of low-level bugs in the "master" branch of <a href="http://www.github.com/lucasaiu/ocaml">his OCaml repository</a>, which were mainly related to the handling of signals. There are still some issues, which seem to be related to thread-switching (ie. when using OS level mutli-threading).</p><a onclick="switchContent('post1','post2')" class="btn" href="#95a7761a721456bf40e8c3358f475413">Read more...</a></div><div id="post2" style="display: none"><p>This post aims at summarizing the activities of OCamlPro for the past month. As usual, we worked in three main areas: the OCaml toolchain, development tools for OCaml and R&amp;D projects.</p><h2>The toolchain</h2><p>Our multi-runtime implementation of OCaml had gained stability. <a href="http://ageinghacker.net/">Luca</a> fixed a lot of low-level bugs in the "master" branch of <a href="http://www.github.com/lucasaiu/ocaml">his OCaml repository</a>, which were mainly related to the handling of signals. There are still some issues, which seem to be related to thread-switching (ie. when using OS level mutli-threading).</p><p>We made great progress on improved inlining strategy. In the current OCaml compiler, inlining, closure conversion and constant propagation are done in a single pass interleaved with analysis. It has served well until now, but to improve it in a way which is easily extensible in the future, it needs a complete rewrite. After a few prototypes, <a href="http://www.lsv.ens-cachan.fr/~chambart/">Pierre</a> is now coming up with a suitable intermediate language (IR) more suited for the job, using a dedicated value analysis to guide the simplification and inlining passes. This IR will stand between the lambda code and the C-lambda and is designed such that future specialized optimization can be easily be added. There are two good reasons for this IR: First, it is not as intrusive and reduces the extent of the modifications to the compiler, as it can be plugged between two existing passes and turned on or off using a command-line flag. Second, it can be tweaked to make the abstract interpretation more precise and efficient. For instance, we want the inlining to work with higher-order functions as well as modules and functors, performing basic defunctorization. It is still in an experimentation phase, but we are quickly converging on the API and hope to have something we can demo in the next months.</p><p>Our <a href="http://www.ocamlpro.com/blog/2012/08/08/profile-native-code.html">frame-pointer patch</a> has also been accepted. Note that, as this patch changes the calling sconvention of OCaml programs, you cannot link together libraries compiled with and without the patch. Hence, this option will be provided as a configuration switch (<code>./configure --with-frame-pointer</code>).</p><p>Regarding memory profiling, we released a preliminary prototype of the memory profiler for native code. It is available in <a href="https://github.com/cago/ocaml">Çagdas</a> repository. We are still in the process of testing and evaluating the prototype before making it widely available through OPAM. As the previous bytecode prototype, you need to compile the libraries and the program you want to profile as usual in order to build a table associating unique identifier to program locations (.prof file). Then, for each allocated block, we have then patched the runtime of OCaml to encode in the header the identifier of the line which allocated it. To be able to dump the heap, you can either instrument your program, or send a signal, or set the appropriate environment variable (<code>OCAMLRUNPARAM=m</code>). Finally, you can use the profiler which will read the .prof and .cmt files in order to generate a pdf file which is the amount of memory use by type. More details on this will come soon, you can already read the <a href="https://github.com/cago/ocaml/blob/4.00.1%2Bmemprof/README">README</a> file available on github.</p><p>Finally, we organized a new meeting with the core-team to discuss some of the bugs in the <a href="http://caml.inria.fr/mantis">OCaml bug tracker</a>. It was the first of the year, but we are now going to have one every month, as it has a very positive impact on the involvement of everybody in fixing bugs and helps focus work on the most important issues.</p><h2>Development Tools for OCaml</h2><p>Since the latest release of <a href="http://github.com/OCamlPro/ocp-indent">ocp-indent</a>, <a href="http://louis.gesbert.fr/cv.en.html">Louis</a> continued to improve the tool. We plan to release version 1.2.0 in the next couple of days, with some bug fixes (esp. related to the handling of records) and the following new features: operators are now aligned by default (as well as opened parentheses not finishing a line) and indentation can be bounded using the <code>max_indent</code> parameter. We are also using the great <a href="http://erratique.ch/software/cmdliner">cmdliner</a> which means <code>ocp-indent</code> now has nice manual pages.</p><p>We are also preparing a new minor release of <a href="http://opam.ocamlpro.com/">OPAM</a>, with a few bug fixes, an improved solver heuristic and improved performance. OPAM statistics seem to converge towards round numbers, as <a href="http://github.com/OCamlPro/opam">OcamlPro/opam</a> repository has recently reached 100 "stars" on Github, <a href="http://github.com/OCamlPro/opam-repository">OCamlPro/opam-repository</a> is not very far from being forked 100 times, while the number of unique packages on <a href="http://opam.ocamlpro.com">opam.ocamlpro.com</a> is almost 400. We are also preparing the platform release, with a cleaner and simpler client API to be used by the upcoming "Ocamlot", the automated infrastructure which will test and improve the quality and consistency of OPAM packages.</p><p>Last, we released a very small - but already incredibly useful tool: <a href="http://github.com/OCamlPro/ocp-index">ocp-index</a>. This new tool provides completion based on what is installed on your system, with type and documentation when available. Similarly to <code>ocp-indent</code>, the main goal of this tool is to make it easy to integrate in your editor of choice. As a proof of concept, we also distribute a small curses-based tool, called <code>ocp-browser</code>, which lets you browse interactively the libraries installed on your system, as well as an emacs binding for <code>auto-complete.el</code>. Interestingly enough, behind the scene <code>ocp-index</code> uses a <a href="https://github.com/OCamlPro/ocp-index/blob/master/src/trie.mli">lazy immutable prefix tree</a> with merge operations to efficiently store and load cmis and cmt files.</p><h2>Other R&amp;D Projects</h2><p>We continued to work on the <a href="http://www.richelieu.pro/">Richelieu</a> project. We are currently adding basic type-inference for Scilab programs to our tool <a href="https://github.com/OCamlPro/richelieu/tree/jit-fabrice/scilab/modules/jit_ocaml/src/scilint">scilint</a>, to be able to print warnings on possible programers mistakes. A first part of the work was to understand how to automatically get rid of some of the <code>eval</code> constructs, especially <code>deff</code> and <code>evalstr</code> primitives that are often used. After this, <a href="https://github.com/Michaaell">Michael</a> manually analyzed some real-world Scilab programs to understand how typing should be done, and he is now implementing the type checker and a table of types for primitive functions.</p><p>We are also submitting a new project, called SOCaml, for funding by the French government. In 2010, <a href="http://www.ssi.gouv.fr/">ANSSI</a>, the French agency for the security of computer systems, commanded a study, called LAFOSEC, to understand the advantages of using functional languages in the domain of security. Early results of the study were presented in <a href="http://jfla.inria.fr/2013/programme">JFLA'2013</a>, with in particular recommandations on how to improve OCaml to use it for security applications. The goal of the SOCaml project would be to implement these recommandations, to improve OCaml, to provide additional tools to detect potential errors and to implement libraries to verify marshaled values and bytecode. We hope the project will be accepted, as it opens a new application domain for OCaml, and would allow us to work on this topic with our partners in the project, such as <a href="http://www.lexifi.com">LexiFi</a> and <a href="http://michel.mauny.net/">Michel Mauny</a>'s team at ENSTA Paristech (the project would also contribute to their <a href="http://github.com/ocaml-bytes/ocamlcc">ocamlcc</a> bytecode-to-c compiler).</p><a onclick="switchContent('post2','post1')" class="btn" href="#95a7761a721456bf40e8c3358f475413">Hide</a></div></span>
<a name="df531457e019bd3465b87aa00850583f"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/forum/forum.php?forum_id=874"> forge distribution upgrade 2013/04/24 - 04/27</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge News</span>, <span class="rss-date">23 Apr 2013</span></span><span class="rss-description"><pre class="rss-text">The admin team plans to upgrade the forge system. There will be various upgrade on the system. So some program can be broken in the next coupld of days. I expect to spend in between 1 and 3 days, depending on what breaks on the system. Feel free to contact me directly sylvain ... le-gall.net or gildor on IRC #ocaml. Sylvain Le Gall on behalf of the admin team.</pre></span>
<a name="b1be0f78f401b7324e7dbfcd9b5b32e8"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/forum/forum.php?forum_id=875"> Cryptokit 1.7 released</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge News</span>, <span class="rss-date">24 Apr 2013</span></span><span class="rss-description"><pre class="rss-text">Now includes the SHA-3 hash function recently standardized by NIST.</pre></span>
<a name="d8a9f97f1e45b54416fd3ccd6a575957"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/test-svn/"> test-svn</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">26 Apr 2013</span></span><span class="rss-description">This project is a test for subversion.</span>
<a name="0434b6d2a87c72dc73fbb876ef4d9db6"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2013.04.30.html"> Caml Weekly News, 30 Apr 2013</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">30 Apr 2013</span></span><span class="rss-description">first release of dolog: the dumb ocaml logger / ackermann microbenchmark strange results / OCaml-Java &amp; concurrent programming: request for feedback / OCaml mechanize? / Request for feedback: A problem with injectivity and GADTs / Book reviewers wanted / Thematic trimester "Semantics of proofs and certified mathematics", spring 2014, Paris / Other Caml News</span>
<a name="ce3449f4ecec39241f58510e39fc4183"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/merlin/"> Merlin</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">01 May 2013</span></span><span class="rss-description">Context sensitive completion and interactive error-reporting for Ocaml in Vim and Emacs.</span>
<a name="18981a4f5baec9ac692241677e8ec22d"></a><span class="rss-header"><span class="rss-title"><a href="https://ocaml.janestreet.com/?q=node/114"> Patch review vs diff review, revisited</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Jane Street</span>, <span class="rss-date">03 May 2013</span></span><span class="rss-description"><div id="post3"><p>I've been thinking about code review a lot recently.</p> <p>Code review is a key part of our dev process, and has been from the beginning. From our perspective, code is more than a way of getting things done, it's a way of expressing your intent. Code that's easy to read and understand is likely to be more robust, more flexible, and critically, safer. And we care about safety a lot, for obvious reasons.</p> <p>But the importance of code review doesn't mean that we've always done a good job of organizing it. I'll talk a bit more about how we used to do code review, how we do it now, and the impact that those changes have had.</p> <h2>The bad old world</h2> <a onclick="switchContent('post3','post4')" class="btn" href="#18981a4f5baec9ac692241677e8ec22d">Read more...</a></div><div id="post4" style="display: none"><p>I've been thinking about code review a lot recently.</p> <p>Code review is a key part of our dev process, and has been from the beginning. From our perspective, code is more than a way of getting things done, it's a way of expressing your intent. Code that's easy to read and understand is likely to be more robust, more flexible, and critically, safer. And we care about safety a lot, for obvious reasons.</p> <p>But the importance of code review doesn't mean that we've always done a good job of organizing it. I'll talk a bit more about how we used to do code review, how we do it now, and the impact that those changes have had.</p> <h2>The bad old world</h2> <p>Our old code review process was what you might call <em>batch-oriented</em>. We'd prepare a set of changes for a release, and then, after someone gave it a quick look-over, combine these changes together in a branch. We'd then read over these changes very carefully, with multiple people reading each file, making comments, requesting changes, and fixing those changes, until the code was in a releasable state.</p> <p>This was a big and expensive process, involving many people, and quite a lot of work and coordination. Given the time it took, we focused our code review on our so-called <em>critical path systems</em>, <em>i.e.</em>, the ones that are involved in sending orders to the market.</p> <p>The management task was complex enough that we wrote a tool called <code>cr</code> for managing and tracking the reading of these diffs, parceling out responsibility for different files to different people. We've actually blogged about this before, <a href="https://ocaml.janestreet.com/?q=node/66">here</a> and <a href="https://ocaml.janestreet.com/?q=node/67">here</a>.</p> <p>Batch-oriented review worked well when we and our codebase were smaller, but it did not scale. By combining multiple changes into a single branch, you were stuck reading a collection of unrelated changes, and the breadth of the changes made fitting it all into your head harder. Even worse, when you throw a bunch of changes together, some are going to take longer than others, so the release is blocked until the slowest change gets beaten into shape.</p> <p>The end result is that, while we found code review to be indispensable in creating high quality code that we felt comfortable connecting to the markets, the overhead of that review kept on getting higher and higher as we grew.</p> <p>We needed a better solution.</p> <h2>Feature-based review</h2> <p>Another approach to code review, and a more common one, is patch-based review. In patch review, someone proposes a change to the current release in the form of a patch, and it is the patch itself that is reviewed. Once it passes review, it can be applied to the tree. Patch-based review is great in that it gives you independence: one patch taking a while doesn't block other patches from getting out.</p> <p>We avoided patch-based review initially because we were worried about the complexities of dealing with conflicting patches. Indeed, one issue with patch-based review is that the state of the tree when the patch is reviewed is likely not the state of the tree when the patch is applied. Even when this doesn't lead to textual conflicts, this should leave you a little nervous, since a patch that is correct against one version of the tree is not necessarily correct against a changed tree.</p> <p>And then, what do you do when there's a conflict and the patch no longer applies cleanly? You can rebase the patch against the new state of the tree, and then re-review the patch from scratch. But humans are really bad at investing mental energy in boring work, and carefully re-reviewing a patch you've already mostly read is deadly dull.</p> <p>Moreover, when do you decide that there's a conflict? When dealing with patches that involve file moves and renames, even deciding what it means for a patch written previously to still apply cleanly is a tricky question.</p> <p>Also, squaring patch-based review with a git or hg-based workflow can be tricky. There's something quite nice about the github-style pull-request workflow; but the semantics of merging are pretty tricky, and you need to be careful that what you read corresponds with the actual changes that are made by the merge.</p> <p>For all the problems, the virtues of patch-based review are clear, and so about six months ago we started a project to revamp our <code>cr</code> tool to make it suitable for doing patch-like review. The new version of <code>cr</code> is now organized around what we call <em>features</em>, which are essentially hg bookmarks (similar to git branches) augmented with some associated metadata. This metadata includes</p> <ul> <li>An English description of the change</li> <li>A base-revision that the changes should be read against</li> <li>An owner</li> <li>A collection (usually just one other than the owner) of full-feature reviewers.</li> </ul> <p>The workflow for a developer goes something like this:</p> <ul> <li><strong>create a new feature</strong> by running <code>cr feature create</code>. You'll select a name for the feature and write the initial description. The base-revision will automatically be chosen as the most recent release.</li> <li><strong>Write the code</strong>, using <code>hg</code> in the ordinary way, making commits as you go and pushing the result to a shared, multi-headed repo that has all of the features people are working on.</li> <li>When you think the code is in a good state, <strong>get the feature enabled</strong> for review. At this point, you'll need to get a full-feature reviewer selected. It's this person's job to read every change that goes into this feature.</li> <li>The full feature reviewer then <strong>reads the diff</strong> from the base-revision to the tip, adding comments, requesting fixes, and reading diffs forward until they're happy, at which point, it's <strong>seconded</strong>.</li> <li>Once it's seconded, the feature is <strong>enabled for review</strong> by anyone who is signed up for review for the specific files you touched. How many file reviewers you are depends on the nature of the project. In our most safety-critical systems, every file has three reviewers. In some other systems, there are no file reviewers at all.</li> </ul> <p>The remaining work needs to be done by the release manager. A release manager can create a new release based on a set of features that:</p> <ul> <li>are fully reviewed, and have no outstanding reviewer complaints to be resolved.</li> <li>compile cleanly on their own and pass their automated tests</li> <li>have as their base revision the previous release</li> <li>can be merged together cleanly</li> </ul> <p>Checking that things "can be merged together cleanly" is actually tricky, since you can't just trust hg's notion of a merge. <code>cr</code> has its own merge logic that is more conservative than what <code>hg</code> and <code>git</code> do. The biggest worry with <code>hg</code> is that it tries to guess at a reasonable base-point for the 3-way merge (usually the greatest common ancestor of the two heads to be merged). Usually this works well, but it's easy to construct crazy cases where on one branch you make changes that are just silently dropped in the merge. There is also some rather surprising behavior that can come into play when files are moved, copied or deleted as part of the mix.</p> <p><code>cr</code>, on the other hand, will always choose the base-point of the features to be merged as the base-point for the 3-way merge. This way, the diffs that are reviewed are also the diffs that are used for constructing the merged node. Also, <code>cr</code> has some extra sanity conditions on what merges it's willing to try. This all greatly reduces the scope for surprising results popping out the other side of a merge.</p> <p>If the base-revision of a given feature is against an older release, then you need to <em>rebase</em> the review before it can be released, <em>i.e.</em>, update the base-revision to the most recent release. Among other things requires you to merge your changes with tip. If there are conflicts, you then either need to review the resolution of the conflicts, or you simply need to reread the diffs from scratch. The last bit is pretty rare, but it's an important escape hatch.</p> <h2>How'd it go?</h2> <p>The new code-review process has had a dramatic effect on our world. The review process for our main repository used to take anywhere from a couple of weeks to a three months to complete a cycle. Today, those releases go out every week, like clockwork. Everyone knows that if they can get their feature cleaned up and ready, they can always get it out that week. Indeed, if you're following our open-source releases on github, you'll see that new packages have shown up once a week for the last 16 weeks.</p> <p>Feature-baaed review has led to a significant increase in the rate of change of our critical-path systems. Code review is now considerably less painful, and most importantly, it's easier than ever to say no to a feature that isn't ready to go. In old-style batch review, there was a lot of pressure to not hold up a release polishing some small bit, which sometimes lead you to release code that wasn't really ready. Now, that problem has largely vanished.</p> <p>The barrier to entry for people who want to contribute to critical path systems has also been lowered. This has also contributed to us being able to get projects out the door faster.</p> <p>But the most striking result I've seen is from our post-trade group, which operates outside of the review process used for the critical-path systems. The post-trade team is responsible for our infrastructure that handles everything after a transaction is done, like tracking the clearing and settlement of our trades or managing our trading books and records.</p> <p>Post-trade has historically had a more relaxed approach to code review --- they do it, but not on all parts of the system, and not in a particularly strict way. In the last few months, however, they switched over to using the new feature-based workflow, and even though they're doing a lot more code review (which takes serious time), their overall process has become faster and more efficient. We think that's largely do to having a well-managed workflow for managing and merging independent features, even without whatever the benefits of review itself.</p> <p>I'm now pushing to get feature-based review adopted throughout the firm. Obviously, not all code needs to be scrutinized to the same level --- having three reviewers for every file is sometimes sensible, sometimes overkill --- but ensuring that no change can get in unless one other person reads it and thinks it's reasonable is a good baseline rule. Review has a lot of benefits: it improves the quality of the code, gives you a great opportunity for training, and helps spread knowledge. Those benefits make sense everywhere we have people programming.</p> <p>Maybe the biggest lesson in this for me is the importance of thinking through your processes, focusing on the biggest bottlenecks, and doing what you can to fix them.</p><a onclick="switchContent('post4','post3')" class="btn" href="#18981a4f5baec9ac692241677e8ec22d">Hide</a></div></span>
<a name="8be63598fea3cfac05b00990d6028c5d"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/blog/a-new-Coq-tactic-for-inversion"> A new Coq tactic for inversion</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">04 May 2013</span></span><span class="rss-description"><div id="post5"><p>With <a href="http://www.pps.univ-paris-diderot.fr/~pboutill/">Pierre Boutillier</a>, we have been working on a new Coq tactic lately, called <code>invert</code>. From my point of view, it started as a quest to build a replacement to the <code>inversion</code> tactic. <code>inversion</code> is a pain to use, as it generates sub-goals with many (dependent) equalities that must be substituted, which force the use of <code>subst</code>, which in turns also has its quirks, making the mantra <code>inversion H; clear H; subst</code> quite fragile. Furthermore, <code>inversion</code> has efficiency problems, being quite slow and generating big proof terms. From Pierre's point of view, this work was a good way to implement a better <code>destruct</code> tactic, based on what he did during an internship (<a href="http://www.pps.univ-paris-diderot.fr/~pboutill/files/Boutillier10.pdf">report in French (PDF)</a>).</p> <a onclick="switchContent('post5','post6')" class="btn" href="#8be63598fea3cfac05b00990d6028c5d">Read more...</a></div><div id="post6" style="display: none"><p>With <a href="http://www.pps.univ-paris-diderot.fr/~pboutill/">Pierre Boutillier</a>, we have been working on a new Coq tactic lately, called <code>invert</code>. From my point of view, it started as a quest to build a replacement to the <code>inversion</code> tactic. <code>inversion</code> is a pain to use, as it generates sub-goals with many (dependent) equalities that must be substituted, which force the use of <code>subst</code>, which in turns also has its quirks, making the mantra <code>inversion H; clear H; subst</code> quite fragile. Furthermore, <code>inversion</code> has efficiency problems, being quite slow and generating big proof terms. From Pierre's point of view, this work was a good way to implement a better <code>destruct</code> tactic, based on what he did during an internship (<a href="http://www.pps.univ-paris-diderot.fr/~pboutill/files/Boutillier10.pdf">report in French (PDF)</a>).</p> <p>In a nutshell, the idea behind a destruction and an inversion is quite similar: it boils down to a case analysis over a given hypothesis. And there are quite a few tactics that follow this scheme: <code>elim</code>, <code>case</code>, <code>destruct</code>, <code>inversion</code>, <code>dependent destruction</code>, <code>injection</code> and <code>discriminate</code> (it is true that the last two tactics are quite specialized, but fit the bill nevertheless). Why on Earth would we need to add a new element to this list?</p> <p>Well, it turns out that building on ideas by <a href="http://www-verimag.imag.fr/~monin/">Jean-Francois Monin</a> to make so called <a href="http://hal.inria.fr/inria-00489412/en/">"small inversions"</a>, one can unify the inner-working of most of the aforementioned list: it suffices to build the right return clause for the case analysis.</p> <p>Let's take an example.</p> <pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Variable</span> <span class="dt">A</span> : Type<span class="kw">.</span> <span class="dt">Inductive</span> vector: nat -&gt; <span class="dt">Type</span> := | nil : vector 0 | cons: forall n (h:A) (v: vector n), vector (<span class="dt">S</span> n). <span class="dt">Inductive</span> <span class="dt">P</span> : forall n, vector n -&gt; <span class="dt">Prop</span> := | <span class="dt">Pnil</span> : <span class="dt">P</span> 0 nil | <span class="dt">Pcons:</span> forall n h v, <span class="dt">P</span> n v -&gt; <span class="dt">P</span> (<span class="dt">S</span> n) (cons n h v). <span class="dt">Lemma</span> test n h v (<span class="dt">H:</span> <span class="dt">P</span> (<span class="dt">S</span> n) (cons n h v)) : <span class="dt">P</span> n v. Proof<span class="kw">.</span></code></pre> <p>At this point, doing <code>inversion H</code> generates 4 new hypotheses:</p> <pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">H2</span> : <span class="dt">P</span> n v0 <span class="dt">H0</span> : n0 = n <span class="dt">H1</span> : h0 = h <span class="dt">H3</span> : existT (<span class="kw">fun</span> n : nat =&gt; vector n) n v0 = existT (<span class="kw">fun</span> n : nat =&gt; vector n) n v ============================ <span class="dt">P</span> n v</code></pre> <p>Yuck: first, <code>H0</code> and <code>H1</code> are just cruft. Then, the goal isn't very palatable, because the equality <code>H3</code> between <code>v</code> and <code>v0</code> is defined in terms of a dependent equality: in order to go further, one need to assume axioms about dependent equality<sup><a href="http://gallium.inria.fr/blog/index.rss#fn1" id="fnref1" class="footnoteRef">1</a></sup>, equivalent to Streicher's axiom K. (Just to keep tabs, note that running the <code>Show Proof</code> command in Coq outputs a partial proof term that is already 73 lines long at this point.)</p> <p>If we use <code>dependent destruction H</code> instead of inversion, we get the expected hypothesis <code>H: P n v</code> (which is far better from an usability point of view). Yet, there is no magic here: dependent destruction simply used a dependent equality axiom internally to get rid of the dependent equality, and generates a 64 lines long proof term that is not very pretty.</p> <p>At this point, one may wonder: what <em>should</em> the proof term look like? and, is it necessary to use the K axiom here?</p> <p>A black belt Coq user versed in dependent types could write the following one.</p> <pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> diag := <span class="kw">fun</span> n0 : nat =&gt; <span class="kw">match</span> n0 <span class="kw">as</span> n' return (forall v0 : vector n', <span class="dt">P</span> n' v0 -&gt; <span class="dt">Prop</span>) <span class="kw">with</span> | 0 =&gt; <span class="kw">fun</span> (v0 : vector 0) (_ : <span class="dt">P</span> 0 v0) =&gt; <span class="dt">True</span> | <span class="dt">S</span> m =&gt; <span class="kw">fun</span> v0 : vector (<span class="dt">S</span> m) =&gt; <span class="kw">match</span> v0 <span class="kw">as</span> v1 <span class="kw">in</span> (vector m0) return (<span class="dt">P</span> m0 v1 -&gt; <span class="dt">Prop</span>) <span class="kw">with</span> | nil =&gt; <span class="kw">fun</span> _ : <span class="dt">P</span> 0 nil =&gt; <span class="dt">True</span> | cons p x v1 =&gt; <span class="kw">fun</span> _ : <span class="dt">P</span> (<span class="dt">S</span> p) (cons p x v1) =&gt; <span class="dt">P</span> p v1 end end <span class="kw">in</span> <span class="kw">match</span> <span class="dt">H</span> <span class="kw">as</span> <span class="dt">H'</span> <span class="kw">in</span> (<span class="dt">P</span> x y) return (diag x y <span class="dt">H'</span>) <span class="kw">with</span> | <span class="dt">Pnil</span> =&gt; <span class="dt">I</span> | <span class="dt">Pcons</span> n0 h0 v0 <span class="dt">Pv</span> =&gt; <span class="dt">Pv</span> end.</code></pre> <p>Wow, 15 lines long. Let's demystify it a bit.</p> <p>First, recall that the return type of a match is dictated by its return clause (the <code>as ... in ... return ...</code> part). This is basically a function that binds the arguments of the inductive (<code>S n</code> as x, <code>cons n h v</code> as y in our case), <code>H'</code> of type <code>P x y</code>, and which body is the return part. Usually, the return part is a constant (e.g., nat for the match in the List.length), but it is not mandatory. Here, the <code>diag</code> term packs some computations, such that <code>diag (S n) (cons n h v) H</code> reduces to <code>P n v</code>, the conclusion of the goal. (In general, this kind of return clauses make it possible to eliminate impossible branches in a match, as done here by marking them with the trivial return type <code>True</code>; we direct the interested readers to the online CPDT book by Adam Chlipala for more informations on this, especially <a href="http://adam.chlipala.net/cpdt/html/MoreDep.html">this chapter</a>.)</p> <p>Then, what is <code>diag</code>? Well, it is a function that follows the structure of the arguments of <code>P</code> to single out impossible cases, and to refine the context in the other ones using dependent pattern matching, in order to reduce to the right type (the type of the initial conclusion of the goal). The idea behind such "small-scale inversions" was described by Monin in 2010 and is out of the scope of this blog post. What is new here is that we have mechanized the construction of the <code>diag</code> functions as a Coq tactic, making this whole approach practical.</p> <p>All in all, using our new tactic, we can just use the following proof script:</p> <pre class="sourceCode ocaml"><code class="sourceCode ocaml">invert <span class="dt">H;</span> tauto. </code></pre> <p>At this point, <code>Show Proof.</code> outputs the following complete proof term (where <code>invert_subgoal</code> is the type of the subgoal solved by <code>tauto</code>):</p> <pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> diag := <span class="kw">fun</span> n0 : nat =&gt; <span class="kw">match</span> n0 <span class="kw">as</span> n1 return (forall v0 : vector n1, <span class="dt">P</span> n1 v0 -&gt; <span class="dt">Prop</span>) <span class="kw">with</span> | 0 =&gt; <span class="kw">fun</span> (v0 : vector 0) (_ : <span class="dt">P</span> 0 v0) =&gt; <span class="dt">False</span> -&gt; <span class="dt">True</span> | <span class="dt">S</span> x =&gt; <span class="kw">fun</span> v0 : vector (<span class="dt">S</span> x) =&gt; <span class="kw">match</span> v0 <span class="kw">as</span> v1 <span class="kw">in</span> (vector n1) return (<span class="kw">match</span> n1 <span class="kw">as</span> n2 return (vector n2 -&gt; <span class="dt">Type</span>) <span class="kw">with</span> | 0 =&gt; <span class="kw">fun</span> _ : vector 0 =&gt; <span class="dt">False</span> -&gt; <span class="dt">True</span> | <span class="dt">S</span> x0 =&gt; <span class="kw">fun</span> v2 : vector (<span class="dt">S</span> x0) =&gt; <span class="dt">P</span> (<span class="dt">S</span> x0) v2 -&gt; <span class="dt">Prop</span> end v1) <span class="kw">with</span> | nil =&gt; <span class="kw">fun</span> <span class="dt">H0</span> : <span class="dt">False</span> =&gt; <span class="dt">False_rect</span> <span class="dt">True</span> <span class="dt">H0</span> | cons n1 h0 v1 =&gt; <span class="kw">fun</span> _ : <span class="dt">P</span> (<span class="dt">S</span> n1) (cons n1 h0 v1) =&gt; <span class="dt">P</span> n1 v1 end end <span class="kw">in</span> (<span class="kw">fun</span> invert_subgoal : forall (n0 : nat) (h0 : <span class="dt">A</span>) (v0 : vector n0) (<span class="dt">H0</span> : <span class="dt">P</span> n0 v0), diag (<span class="dt">S</span> n0) (cons n0 h0 v0) (<span class="dt">Pcons</span> n0 h0 v0 <span class="dt">H0</span>) =&gt; <span class="kw">match</span> <span class="dt">H</span> <span class="kw">as</span> p <span class="kw">in</span> (<span class="dt">P</span> n0 v0) return (diag n0 v0 p) <span class="kw">with</span> | <span class="dt">Pnil</span> =&gt; <span class="kw">fun</span> <span class="dt">H0</span> : <span class="dt">False</span> =&gt; <span class="dt">False_rect</span> <span class="dt">True</span> <span class="dt">H0</span> | <span class="dt">Pcons</span> x x0 x1 x2 =&gt; invert_subgoal x x0 x1 x2 end) (<span class="kw">fun</span> (n0 : nat) (_ : <span class="dt">A</span>) (v0 : vector n0) (<span class="dt">H0</span> : <span class="dt">P</span> n0 v0) =&gt; <span class="dt">H0</span>))</code></pre> <p>Some of the differences with the proof term above come from the fact that we generate it interactively, rather than writing it once at all.</p> <p>A legitimate question: how do we compare to destruct and inversion and dependent destruction? First, we aim at producing a "better" destruct: that is, we might resolve the situation in which <code>destruct</code> fails, in order to avoid producing ill-typed terms. Then, the situation with respect to inversion and dependent destruction is less clear. Right now, we would rather <em>not</em> assume the K axiom (the right thing to do if homotopy is the future). In that case, we would fail for inversion problems that require K, and inversion and dependent destruction would be more powerful than our tactic. For problems that do no require to use K, <code>invert</code> would be equivalent to <code>dependent destruction</code> with better looking proof terms<sup><a href="http://gallium.inria.fr/blog/index.rss#fn2" id="fnref2" class="footnoteRef">2</a></sup>.</p> <p>We are still working on our prototype, but we are quite confident that we got the main thing right: mechanizing the construction of the return clause. We will come back to this blog when we need beta-testers!</p> <div class="footnotes"> <hr/> <ol> <li id="fn1"><p>See <a href="http://coq.inria.fr/faq?som=5#htoc47">the following FAQ question</a> (Can I prove that the second components of equal dependent pairs are equal?). You may also be interested in <a href="http://coq.inria.fr/faq?som=5#htoc39">this other question</a> (What is Streicher's axiom K?). The <a href="http://coq.inria.fr/library/Coq.Logic.EqdepFacts.html">EqdepFacts</a> standard library module, that has the equivalence proofs between all those subtle notions. Finally, if you want to finish this proof using these axioms, you can use <code>Require Import Eqdep.</code> then the <code>inj_pair2</code> lemma. Once you're done, <code>Print Assumptions test.</code> will let you check that you relied on an additional axiom -- or <code>Print Assumptions inj_pair2</code>.<a href="http://gallium.inria.fr/blog/index.rss#fnref1">↩</a></p></li> <li id="fn2"><p>Moreover, since our proof terms are less cluttered, it seems less likely than recursive definitions made in "proof mode" with <code>invert</code> will fail to pass the termination check once Coq's guard condition deals properly with such commutative cuts, another part of Pierre's thesis work.<a href="http://gallium.inria.fr/blog/index.rss#fnref2">↩</a></p></li> </ol> </div><a onclick="switchContent('post6','post5')" class="btn" href="#8be63598fea3cfac05b00990d6028c5d">Hide</a></div></span>
<a name="ea3a33b9f10f2055d03ae11467486927"></a><span class="rss-header"><span class="rss-title"><a href="http://syntaxexclamation.wordpress.com/?p=365"> malloc() is the new gensym()</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Matthias Puech</span>, <span class="rss-date">04 May 2013</span></span><span class="rss-description"><div id="post7"><a onclick="switchContent('post7','post8')" class="btn" href="#ea3a33b9f10f2055d03ae11467486927">Read more...</a></div><div id="post8" style="display: none"><p>Teaching an introductory course to “compilation” this semester (actually it was called <a href="http://www.pps.univ-paris-diderot.fr/~puech/ens/mv6.html">Virtual Machines</a>, but it was really about compiling expressions to stack machines), I realized something I hadn’t heard before, and wish I had been told when I first learned OCaml many years ago. Here it is: as soon as you are programming in a functional language with physical equality (i.e. pointer equality, the <code>(==)</code> operator in OCaml), then you are actually working in a “weakly impure” language, and you can for example implement a limited form of <code>gensym</code>. What? <code>gensym</code> is this classic “innocuously effectful” function returning a different <i>symbol</i>—usually a string—each time it is called. It is used pervasively to generate fresh variable names, in compilers notably. How? well, you actually don’t have much to do, except let the runtime call <code>malloc</code>: it will return a “fresh” pointer where to store your data. <code>malloc</code> and the garbage collector together ensures this freshness condition, and you can then compare two pointers with <code>(==)</code>. As a bonus, you can even store data along your fresh symbol.</p> <p>In this post, I’ll exploit that simple idea to develop an assembler for a little stack machine close to that of OCaml.</p> <p><span id="more-365"></span></p> <h3>The idea</h3> <p>In OCaml, something as simple as this is a <code>gensym</code>:</p> <pre class="brush: fsharp; title: ; notranslate">type 'a sym = C of 'a let gensym x = C x </pre> <p>Each call to say <code>gensym ()</code> will allocate one new data block in memory; you can then compare two symbols with the physical equality <code>(==)</code>.What we care about here is not the content of that memory span, but its <i>address</i>, which is unique.</p> <p>A few warnings first: in OCaml, the constructor must have arguments, otherwise the compiler optimizes the representation to a simple integer and nothing is allocated. Also, don’t replace the argument <code>x</code> to <code>C</code> by a constant, say <code>()</code>, in the function code: if you do so, the compiler will place value <code>C ()</code> in the data segment of the program, and calling <code>gensym</code> will not trigger an allocation either. There is an excellent and already classic series of blog post about OCaml’s value representation <a href="http://rwmj.wordpress.com/2009/08/04/ocaml-internals/">here</a>.</p> <p>Another way of saying the same thing is that (non-cyclic) values in OCaml are not trees, as they can be thought of considering the purely functional fragment, but DAGs, that is trees with sharing. </p> <p>I think that not many beginner/intermediate OCaml programmers realize the power of this, so I’d like to show a cool application of this remark. We will code a small compiler from a arithmetic language to a stack machine. Bear with me, it’s going to be fun!</p> <h3>An application: compiling expressions to a stack machine</h3> <p>The input language of expressions is:</p> <pre class="brush: fsharp; title: ; notranslate">type expr = | Int of int | Plus of expr * expr | If of expr * expr * expr </pre> <p>Its semantics should be clear, except for the fact that <code>If</code> are like in C: if their condition is different than 0, then their first branch is taken; if it is 0, then the second is taken. Because we have these conditionals, the stack machine will need instructions to jump around in the code. The instructions of this stack machine are:</p> <ul> <li><code>Push i</code> pushes <code>i</code> on the stack;</li> <li><code>Add</code> pops two values off the stack and pushes their sum;</li> <li><code>Halt</code> stops the machine and returning the (supposedly unique) stack value;</li> <li><code>Branch o</code> skips the next <code>o</code> instructions in the code;</li> <li><code>Branchif o</code> skips the next <code>o</code> instructions <i>if</i> the top of the stack is not <code>0</code>, and has no effect otherwise </li></ul> <p>For instance, the expression <i>1 + (if 0 then 2 else (3+3))</i> is compiled into:</p> <pre class="brush: fsharp; title: ; notranslate">[Push 1; Push 0; Branchif 3; Push 3; Push 3; Add; Branch 1; Push 2; Add; Halt] </pre> <p>and evaluates of course to <code>7</code>. Notice how the two branches of the <code>If</code> are turned around in the code? First, we’ve got the code of expression <i>2</i>, then the code of <i>3+3</i>. In general, expression <i>if e1 then e2 else e3</i> will be compiled to [<i>c1</i>; <code>Branchif</code> (|<i>c3</i>|+1); <i>c3</i>; <code>Branch</code> |<i>c2</i>|; <i>c2</i>; ...] where <i>ci</i> is the compiled code of <i>ei</i>, and |<i>l</i>| is the size of code <i>l</i>. But I’m getting ahead of myself.</p> <h3>Compilation</h3> <p>Now, compiling an <code>expr</code> to a list of instructions in one pass would be a little bit messy, because we have to compute these integer offset for jumps. Let’s follow instead the common practice and first compile expressions to an assembly language where some suffixes of the code have <i>labels</i>, which are the names referred to by instructions <code>Branch</code> and <code>Branchif</code>. This assembly language <code>asm</code> will then be well… assembled into actual <code>code</code>, where jumps are translated to integer offsets. But instead of generating label names by side-effect as customary, let’s use our trick: we will refer to them by a unique <i>pointer</i> to the code attached to it. In other words, the arguments to <code>Branch</code> and <code>Branchif</code> will actually be pointers to <code>asm</code> programs, comparable by <code>(==)</code>.</p> <p>To represent the <code>code</code> and <code>asm</code> data structures, we generalize over the notion of label:</p> <pre class="brush: fsharp; title: ; notranslate">type 'label instr = | Push of int | Add | Branchif of 'label | Branch of 'label | Halt </pre> <p>An assembly program is a list of instruction where labels are themselves assembly programs (the <code>-rectypes</code> option of OCaml is required here):</p> <pre class="brush: fsharp; title: ; notranslate">type asm = asm instr list </pre> <p>For instance, taking our previous example,</p> <pre class="brush: fsharp; title: ; notranslate">Plus (Int 1, If (Int 0, Int 2, Plus (Int 3, Int 3))) </pre> <p>is compiled to the (shared) value:</p> <pre class="brush: fsharp; title: ; notranslate">Push 1 :: Push 0 :: let k = [Add; Halt] in Branchif (Push 2 :: k) :: Push 3 :: Push 3 :: Add :: k </pre> <p>See how the suffix <code>k</code> (the continuation of the <code>If</code>) is shared among the <code>Branchif</code> and the main branch? In call-by-value, this is a value: if you reduce it any further by inlining <code>k</code>, you will get a different value, that can be told apart from the first by using <code>(==)</code>. So don’t let OCaml’s pretty-printing of values fool you: this is not a tree, the sharing of <code>k</code> <i>is</i> important! What you get is the DAG of all possible execution traces of your program; they eventually all merge in one point, the code suffix <code>k = [Add; Halt]</code>.</p> <p>The compilation function is relatively straightforward; it’s an accumulator-based function:</p> <pre class="brush: fsharp; title: ; notranslate">let rec compile e k = match e with | Int i -&gt; Push i :: k | Plus (e1, e2) -&gt; compile e1 (compile e2 (Add :: k)) | If (e1, e2, e3) -&gt; compile e1 (Branchif (compile e2 k) :: compile e3 k) let compile e = compile e [Halt] </pre> <p>The sharing discussed above is realized here in the <code>If</code> case, by compiling its two branches using the accumulator (continuation) <code>k</code> twice. Again, many people think of this erroneously as <i>duplicating</i> a piece of value. Actually, this is only mentioning twice a pointer to an already-allocated unique piece of value; and since we can compare pointers, we have a way to know that they are the same. Note also that this compilation function is purely compositional: to each subexpression corresponds a contiguous span of assembly code.</p> <h3>Assembly</h3> <p>Now, real code for our machine is simply a list of instructions where labels are represented by (positive) integers:</p> <pre class="brush: fsharp; title: ; notranslate">type code = int instr list </pre> <p>Why positive? Well, since we have no way to make a loop, code can be arranged such that all jumps are made <i>forward</i> in the code.</p> <p>The assembly function took me a while to figure out. It “linearizes” the assembly, a DAG, into a list by traversing it depth-first. The tricky part is that we don’t want to repeat the common suffixes of all branches; that’s where we use the fact that they are at the same memory address, which we can check with <code>(==)</code>. If a piece of input code has already been compiled <i>n</i> instructions ahead in the output code, instead of repeating it we just emit a <code>Branch</code> <i>n</i>.</p> <p>So practically, we must keep as an argument an association list <code>k</code> mapping already-compiled suffixes of the input to the corresponding output instruction; think of it as a kind of “cache” of the function. It also doubles as the <i>result</i> of the process: it is what’s eventually returned by <code>assemble</code>. For each input <code>is</code>, we first traverse that list <code>k</code> looking for the pointer <code>is</code>; if we find it, then we have our <code>Branch</code> instruction; otherwise, we assemble the next instruction. This first part of the job corresponds to the <code>assemble</code> function:</p> <pre class="brush: fsharp; title: ; notranslate">let rec assemble is k = try (is, Branch (List.index (fun (is', _) -&gt; is == is') k)) :: k with Not_found -&gt; assem is k </pre> <p>(<code>List.index p xs</code> returns the index of the first element <code>x</code> of <code>xs</code> such that <code>p x</code> is <code>true</code>). </p> <p>Now the auxiliary function <code>assem</code> actually assembles instructions into a list of pairs of source programs and target instruction:</p> <pre class="brush: fsharp; title: ; notranslate">and assem asm k = match asm with | (Push _ | Add | Halt as i) :: is -&gt; (asm, i) :: assemble is k | Branchif is :: js -&gt; let k = assemble is k in let k' = assemble js k in (asm, Branchif (List.length k' - List.length k)) :: k' | Branch _ :: _ -&gt; assert false | [] -&gt; k </pre> <p>Think of the arguments <code>asm</code> and <code>k</code> as one unique list <code>asm @ k</code> that is “open” for insertion in two places: at top-level, as usual, and in the middle, between <code>asm</code> and <code>k</code>. The <code>k</code> part is the already-processed suffix, and <code>asm</code> is what remains to be processed. The first case inserts the non-branching instructions <code>Push, Add, Halt</code> at top-level in the output (together with their corresponding assembly suffix of course). The second one, <code>Branchif</code>, begins by inserting the branch <code>is</code> at top-level, and then inserts the remainder <code>js</code> in front of it. Note that when assembling this remainder, we can discover sharing that was recorded in <code>k</code> when compiling the branch. Note also that there can’t be any <code>Branch</code> in the assembly since it would not make much sense (everything after a <code>Branch</code> instruction would be dead code), hence the <code>assert false</code>.</p> <p>Finally, we can strip off the “cached” information in the returned list, keeping only the target instructions:</p> <pre class="brush: fsharp; title: ; notranslate">let assemble is = snd (List.split (assemble is [])) </pre> <h3>Conclusion</h3> <p>That’s it, we have a complete compilation chain for our expression language! We can execute the target code on this machine:</p> <pre class="brush: fsharp; title: ; notranslate">let rec exec = function | s, Push i :: c -&gt; exec (i :: s, c) | i :: j :: s, Add :: c -&gt; exec (i + j :: s, c) | s, Branch n :: c -&gt; exec (s, List.drop n c) | i :: s, Branchif n :: c -&gt; exec (s, List.drop (if i&lt;&gt;0 then n else 0) c) | [i], Halt :: _ -&gt; i | _ -&gt; failwith "error" let exec c = exec ([], c) </pre> <p>The idea of using labels that are actual pointers to the code seems quite natural and seems to scale well (I implemented a compiler from a mini-ML to a virtual machine close to OCaml’s bytecode). In terms of performance however, <code>assemble</code> is quadratic: before assembling each instruction, we look up if we didn’t assemble it already. When we have real (string) labels, we can represent the “cache” as a data structure with faster lookup; unfortunately, if labels are pointers, we can’t really do this because we don’t have a total order on pointers, only equality <code>(==)</code>.</p> <p>This is only one example of how we can exploit pointer equality in OCaml to mimick a name generator. I’m sure there are lots of other applications to be discovered, or that I don’t know of (off the top of my head: to represent variables in the lambda-calculus). The big unknown for me is the nature of the language we’ve been working in, functional OCaml + pointer equality. Can we still consider it a functional language? How to reason on its programs? The comment section is right below!</p> <br/> <a href="http://feeds.wordpress.com/1.0/gocomments/syntaxexclamation.wordpress.com/365/" rel="nofollow"><img src="http://feeds.wordpress.com/1.0/comments/syntaxexclamation.wordpress.com/365/" alt="" border="0"/></a> <img src="http://stats.wordpress.com/b.gif?host=syntaxexclamation.wordpress.com&amp;blog=14690639&amp;post=365&amp;subd=syntaxexclamation&amp;ref=&amp;feed=1" alt="" height="1" border="0" width="1"/><a onclick="switchContent('post8','post7')" class="btn" href="#ea3a33b9f10f2055d03ae11467486927">Hide</a></div></span>
<a name="8d4bd5a3b62e46c38a466a1fade01fc3"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2013.05.07.html"> Caml Weekly News, 07 May 2013</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">07 May 2013</span></span><span class="rss-description">OCaml mechanize? / -principal / Request for feedback: A problem with injectivity and GADTs / Other Caml News</span>
<script type="text/javascript">function switchContent(id1,id2) {
     // Get the DOM reference
     var contentId1 = document.getElementById(id1);
     var contentId2 = document.getElementById(id2);
     // Toggle
     contentId1.style.display = "none";
     contentId2.style.display = "block";
     }</script></div>

  
    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>

    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-37808023-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

    </script>

</body></html>
