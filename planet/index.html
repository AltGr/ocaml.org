<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: OCaml Planet</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contributors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="OCaml Planet" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it Online</a></li>
    <li><a href="../taste.html">100 Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who Is Using It?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a>
        <a href="http://langref.org/ocaml">langref.org</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
    <li><a href="../papers.html">Papers</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../releases/">Releases</a></li>
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development Tools</a></li>
    <li><a href="../books.html#manual">User Manual</a></li>
    <li><a href="../cheat_sheets.html">Cheat Sheets</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API Search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">GitHub</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing Lists</a></li>
    <li><a href="../planet/">Blogs</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>OCaml Planet
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

    <h1>OCaml Planet</h1>

    <p>The OCaml Planet aggregates various blogs from the OCaml
    community.  It is kindly provided
    by <a href="http://www.ocamlcore.com/">OCamlCore</a>.  If you
    would like to be added, read
    the <a href="http://www.ocamlcore.org/planet/">Planet
    subscription HOWTO</a>.</p>

    <br/>
    <div style="float: right; margin-right: 0; margin-top: 0" class="span2 planet-subscriptions"><em>Subscriptions</em>
      <ul><li><a href="http://alexleighton.tumblr.com/tagged/ocaml/rss">Alex Leighton</a></li><li><a href="http://andreiformiga.com/blog/?cat=5&feed=rss2">Andrei Formiga</a></li><li><a href="http://math.andrej.com/feed/">Andrej Bauer</a></li><li><a href="http://anil.recoil.org/feeds/atom.xml">Anil Madhavapeddy</a></li><li><a href="http://ashishagarwal.org/tag/ocaml/feed/">Ashish Agarwal</a></li><li><a href="http://www.blogger.com/feeds/7617521785419311079/posts/default">Cameleon news</a></li><li><a href="http://caml.inria.fr/news.en.rss">Caml INRIA</a></li><li><a href="http://camlspotter.blogspot.com/feeds/posts/default?alt=rss">Caml Spotting</a></li><li><a href="http://alan.petitepomme.net/cwn/cwn.rss">Caml Weekly News</a></li><li><a href="http://coherentpdf.com/blog/?tag=ocaml&feed=rss">Coherent Graphics</a></li><li><a href="http://coq.inria.fr/news/feed">Coq</a></li><li><a href="http://erratique.ch/feeds/news.atom">Daniel Bünzli</a></li><li><a href="http://nleyten.com:82/feed/tag/ocaml/atom">Dario Teixeira</a></li><li><a href="http://www.blogger.com/feeds/17133288/posts/default/-/ocaml">David Baelde</a></li><li><a href="http://bentobako.org/david/blog/index.php?feed/tag/ocaml/atom">David Mentré</a></li><li><a href="http://dutherenverseauborddelatable.wordpress.com/category/ocaml/feed/">David Teller</a></li><li><a href="http://www.examachine.net/blog/cat/ocaml/feed/">Eray Özkural</a></li><li><a href="http://www.mega-nerd.com/erikd/Blog/index.rss20">Erik de Castro Lopo</a></li><li><a href="http://blog.emillon.org/feeds/ocaml.xml">Etienne Millon</a></li><li><a href="http://www.blogger.com/feeds/8964007124326996693/posts/default/-/ocaml">Fayssal Martani</a></li><li><a href="http://frama-c.com/rss.xml">Frama-C</a></li><li><a href="http://functionaljobs.com/jobs/search/?q=ocaml&format=rss">Functional Jobs</a></li><li><a href="http://gallium.inria.fr/blog/index.rss">GaGallium</a></li><li><a href="http://gaiustech.wordpress.com/category/ocaml/feed/">Gaius Hammond</a></li><li><a href="http://blog.camlcity.org/blog/rss">Gerd Stolpmann</a></li><li><a href="http://www.wisdomandwonder.com/tag/OCaml/feed">Grant Rettke</a></li><li><a href="http://hongboz.wordpress.com/feed/">Hong bo Zhang</a></li><li><a href="http://blog.incubaid.com/tag/ocaml/feed/">Incubaid Research</a></li><li><a href="http://ambassadortothecomputers.blogspot.com/feeds/posts/default?alt=rss">Jake Donham</a></li><li><a href="http://scattered-thoughts.net/atom.xml">Jamie Brandon</a></li><li><a href="https://ocaml.janestreet.com/?q=rss.xml">Jane Street</a></li><li><a href="http://lpw25.net/rss.xml">Leo White</a></li><li><a href="http://www.lexifi.com/blogs/ocaml/feed">LexiFi</a></li><li><a href="http://newblog.0branch.com/rss.xml">Marc Simpson</a></li><li><a href="http://syntaxexclamation.wordpress.com/tag/ocaml/feed/">Matthias Puech</a></li><li><a href="http://www.blogger.com/feeds/5888658295182480819/posts/default">Matías Giovannini</a></li><li><a href="http://www.elehack.net/michael/blog/tags/ocaml?format=rss">Michael Ekstrand</a></li><li><a href="">Mihamina Rakotomandimby</a></li><li><a href="http://mcclurmc.wordpress.com/feed/">Mike McClurg</a></li><li><a href="http://nyc-ocaml.posterous.com/rss.xml">NYC OCaml</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfnews.php">OCamlCore Forge News</a></li><li><a href="http://forge.ocamlcore.org/export/rss_sfprojects.php">OCamlCore Forge Projects</a></li><li><a href="http://www.ocamlcore.com/wp/?feed=rss2&amp;language=en&#038;language=en">OCamlCore.com</a></li><li><a href="http://www.ocamlpro.com/feed/atom.xml">OCamlPro</a></li><li><a href="http://odns.tuxfamily.org/feed/">ODNS project</a></li><li><a href="http://ox.tuxfamily.org/feed/">Ocaml XMPP project</a></li><li><a href="http://ocsigen.org/news.atom">Ocsigen project</a></li><li><a href="http://www.blogger.com/feeds/2073503406800427577/posts/default">Opa</a></li><li><a href="http://www.openmirage.org/blog/atom.xml">Open Mirage</a></li><li><a href="http://functional-orbitz.blogspot.com/feeds/posts/default/-/planetocaml?alt=rss">Orbitz</a></li><li><a href="http://www.donadeo.net/facets/programming-languages/objective-caml/feed/">Paolo Donadeo</a></li><li><a href="https://mancoosi.org/~abate/taxonomy/term/5/0/feed">Pietro Abate</a></li><li><a href="http://rwmj.wordpress.com/tag/ocaml/feed/">Richard Jones</a></li><li><a href="http://blog.rastageeks.org/spip.php?page=rss&id_mot=2">Romain Beauxis</a></li><li><a href="http://seb.mondet.org/blog/feed/ocaml.rss">Sebastien Mondet</a></li><li><a href="http://upsilon.cc/~zack/tags/ocaml/index.rss">Stefano Zacchiroli</a></li><li><a href="http://le-gall.net/sylvain+violaine/blog/index.php?feed/tag/ocaml/atom">Sylvain Le Gall</a></li><li><a href="http://caml.inria.fr/hump.rss">The Caml Humps</a></li><li><a href="http://www.blogger.com/feeds/6115529230232389198/posts/default">Till Varoquaux</a></li><li><a href="http://y-node.com/blog/feeds/latest/">y-node</a></li></ul>

      <a href="http://planet.ocaml.org/rss20.xml"><img src=".././img/rss20.png"/></a>
      <a href="http://planet.ocaml.org/opml.xml"><img src=".././img/opml.png"/></a>
    </div>
    <div class="planet"><a name="c3f4de345dacff845f985e402cced3c6"></a><span class="rss-header"><span class="rss-title"><a href="http://lpw25.net/2013/03/10/ocaml-namespaces.html"> Adding namespaces to OCaml</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author"><span id="ocaml_1">Leo White &#9001;leo<abbr title="(at) &rarr; @">(at)</abbr>lpw25.net (Leo White)&#9002;</span><script type="text/javascript"><!--;
local = "leo";
h = "lpw25.net (Leo White)";
hq = "lpw25.net%20(Leo%20White)";
document.getElementById("ocaml_1").innerHTML = '<a href="mailto:' + local + '@' + hq + "\" >Leo White<\/a>";
//--></script></span>, <span class="rss-date">10 Mar 2013</span></span><span class="rss-description"><div id="post1"><a onclick="switchContent('post1','post2')" class="btn" href="#c3f4de345dacff845f985e402cced3c6">Read more...</a></div><div id="post2" style="display: none"><div class="well well-small">
<h4>Contents</h4>
<div class="toc">
   <ul>

   </ul><ul>

   </ul><ul>
   <li><a href="http://www.lpw25.net/rss.xml#Problems+with+pack">Problems with pack</a>   </li>
   <li><a href="http://www.lpw25.net/rss.xml#Formal+semantics">Formal semantics</a>   </li>
   <li><a href="http://www.lpw25.net/rss.xml#Design+goals">Design goals</a>   </li>
   <li><a href="http://www.lpw25.net/rss.xml#Design+choices">Design choices</a>
    <ul>
    <li><a href="http://www.lpw25.net/rss.xml#Flat+or+hierarchical?">Flat or hierarchical?</a>    </li>
    <li><a href="http://www.lpw25.net/rss.xml#Should+namespaces+be+opened+explicitly+in+source+code?">Should namespaces be opened explicitly in source code?</a>    </li>
    <li><a href="http://www.lpw25.net/rss.xml#How+should+the+compiler+find+modules+in+the+presence+of+namespaces?">How should the compiler find modules in the presence of namespaces?</a>
     <ul>
     <li><a href="http://www.lpw25.net/rss.xml#Using+filenames">Using filenames</a>     </li>
     <li><a href="http://www.lpw25.net/rss.xml#Checking+multiple++.cmi++files">Checking multiple “.cmi” files</a>     </li>
     <li><a href="http://www.lpw25.net/rss.xml#Using+namespace+description+files">Using namespace description files</a>     </li>
     <li><a href="http://www.lpw25.net/rss.xml#Using+environment+description+files">Using environment description files</a>     </li>
    </ul>
    </li><li><a href="http://www.lpw25.net/rss.xml#How+should+namespaces+specified?">How should namespaces specified?</a>
     <ul>
     <li><a href="http://www.lpw25.net/rss.xml#Explicitly+in+the+source+files">Explicitly in the source files</a>     </li>
     <li><a href="http://www.lpw25.net/rss.xml#Through+command-line+arguments">Through command-line arguments</a>     </li>
     <li><a href="http://www.lpw25.net/rss.xml#Through+filenames">Through filenames</a>     </li>
     <li><a href="http://www.lpw25.net/rss.xml#Through+namespace+description+files">Through namespace description files</a>     </li>
     <li><a href="http://www.lpw25.net/rss.xml#Through+environment+description+files">Through environment description files</a>     </li>
    </ul>
    </li><li><a href="http://www.lpw25.net/rss.xml#How+rich+should+a+description+language+be?">How rich should a description language be?</a>    </li>
    <li><a href="http://www.lpw25.net/rss.xml#Should+namespaces+support+automatically+opened+members?">Should namespaces support automatically opened members?</a>    </li>
   </ul>
   </li><li><a href="http://www.lpw25.net/rss.xml#Proposal">Proposal</a>
    <ul>
    <li><a href="http://www.lpw25.net/rss.xml#Simple+namespaces+through+filenames">Simple namespaces through filenames</a>    </li>
    <li><a href="http://www.lpw25.net/rss.xml#An+alternative+to+search+paths">An alternative to search paths</a>    </li>
    <li><a href="http://www.lpw25.net/rss.xml#The++-name++argument">The “-name” argument</a>    </li>
    <li><a href="http://www.lpw25.net/rss.xml#The++-open++argument">The “-open” argument</a>    </li>
    </ul>
   </li>
   </ul>
  
  
 
 

</div>
</div>


<p>Recently there has been a lot of discussion on
<a href="http://lists.ocaml.org/listinfo/platform">platform@lists.ocaml.org</a> about
proposals for adding namespaces to OCaml. I’ve written this post to summarise
the design decisions for such a proposal and to make my own proposal.</p>

<p>Before discussing what namespaces are and the issues surrounding their
implementation, it is important to explain why they are needed in the first
place.</p>

<p>The most important reason for adding namespaces is to provide some means for
grouping the components of a library together. Up to now this has been
achieved using the OCaml module system. Since the components of an OCaml
library are modules, a module can be created that contains all the components
of the library as sub-modules. The “-pack” option for the compiler was created
to allow this module to be created while still keeping each component of the
library in its own file.</p>

<h3 id="Problems+with+pack">Problems with pack</h3>

<p>There are some critical problems with using “-pack” to create a single module
containing the whole library:</p>

<ul>
<li><p>The packed module is a single unit that has to be linked or not as a
unit. This means that any program using part of the library must include the
entire library.</p></li>
<li><p>The packed module is a choke-point in the dependency graph.  If a file
depends on one thing in the packed module then it needs to be recompiled if
anything in the packed module changes.</p></li>
<li><p>Opening a large packed module is very slow and can seriously affect build
performance.</p></li>
</ul>


<p>These problems are all caused by the fact that pack creates an OCaml
module. To understand this consider the run-time semantics of the module
system.</p>

<p>At run-time a module is a record. Initialising a module involves initialising
every component of the module and placing them in this record.  Initialising
these components can involve executing arbitrary code; in fact the execution
of an OCaml program is simply the initialisation of all its modules.</p>

<p>The problems with pack are related to these dynamic semantics. In order to
be a module pack must create a record to represent this module. This means
that it must initialise all of its components. It is this (rather than any
detail of pack’s implementation) that causes the problems identified above.</p>

<p>Access to the components of a top-level module could proceed without the
existence of this record. However, the record is required in order to “alias”
the module, use the module as a first-class value or use it as the argument to
a functor.</p>

<p>Any attempt to overcome the problems with pack, whilst still maintaining
the illusion that the “pack” is a normal module, would result (at the very
least) in one of the following unhealthy situations:</p>

<ul>
<li><p>The module type of the “packed module” would depend on which of its
components were accessed by the program.</p></li>
<li><p>Any use of the “packed module” other than as a simple container
(e.g.
<span class="highlight"><code><span class="k">module</span>
<span class="nc">CS</span>
<span class="o">=</span>
<span class="nn">Core</span><span class="p">.</span><span class="nc">Std</span></code></span>
) could have a dramatic effect on what was
linked into the program and potentially on the semantics of the program.</p></li>
</ul>


<p>Namespaces are basically modules that can only be used as a simple
container. This means that they do not need a corresponding record at
run-time (or any other run-time representation). This avoids the problems
with pack as well as enabling other useful features.</p>

<h3 id="Formal+semantics">Formal semantics</h3>

<p>Following the semantics and description language for namespaces described by
<a href="http://gallium.inria.fr/~scherer/namespaces/spec.pdf">Gabriel Scherer et al</a>,
I will consider namespaces to be name-labelled trees whose leaves are
compilation units. I will use
<span class="highlight"><code><span class="o">#</span></code></span>
to represent projection on namespaces, so the
<span class="highlight"><code><span class="nc">Bar</span></code></span>
member of the
<span class="highlight"><code><span class="nc">Foo</span></code></span>
namespace will be referred to as
<span class="highlight"><code><span class="nc">Foo</span><span class="o">#</span><span class="nc">Bar</span></code></span>.</p>

<h3 id="Design+goals">Design goals</h3>

<p>Some design goals that we might want from a proposal for adding namespaces to
OCaml include:</p>

<ul>
<li><p><strong>Allow library components to be grouped together without creating a module
containing them.</strong></p></li>
<li><p><strong>Allow users to group together modules from different libraries as they see
fit.</strong> This means letting people change which namespace a library module is
in.</p></li>
<li><p><strong>Allow library components to be given multiple names.</strong> For example
<span class="highlight"><code><span class="nc">Lib</span><span class="o">#</span><span class="nc">Foo</span></code></span>
and
<span class="highlight"><code><span class="nc">Lib</span><span class="o">#</span><span class="nc">Stable</span><span class="o">#</span><span class="nc">Foo</span></code></span>
, where
<span class="highlight"><code><span class="nc">Lib</span><span class="o">#</span><span class="nc">Stable</span></code></span>
is a namespace containing only those components whose interfaces are stable.</p></li>
<li><p><strong>Be simple and easy to explain to beginners.</strong></p></li>
<li><p><strong>Allow multiple source files to share the same filename.</strong> Each module that
is linked into an OCaml program must have a unique name. Currently, a
module’s name is completely determined by its filename. This forces library
developers to either use pack (which gives its components new long names) or
give their source files long names like “libName_Foo.ml”. A namespaces
proposal may be able to alleviate this problem.</p></li>
<li><p><strong>Allow libraries to control which modules are open by default.</strong> By default
OCaml opens the standard library’s
<span class="highlight"><code><span class="nc">Pervasives</span></code></span>
module. Libraries that wish to replace the standard library may also wish to
provide their own
<span class="highlight"><code><span class="nc">Pervasives</span></code></span>
module and have it opened by default.</p></li>
<li><p><strong>Support libraries that wish to remain compatible with versions of OCaml
without namespaces.</strong></p></li>
<li><p><strong>Require minimal changes to existing build systems.</strong> Since a namespace
proposal changes how a library’s components are named, it may require
changes to some build systems. If these changes are too invasive then users
of some build systems will probably be unable to use namespaces in the near
future.</p></li>
</ul>


<h3 id="Design+choices">Design choices</h3>

<h4 id="Flat+or+hierarchical?">Flat or hierarchical?</h4>

<p>In order to replace pack, namespaces must be able to contain modules. It is
not clear, however, whether they need to be able to contain other
namespaces. We call namespaces that can contain other namespaces
<em>hierarchical</em>, as opposed to <em>flat</em>.</p>

<p>In favour of flat namespaces:</p>

<ul>
<li><p>Hierarchical namespaces might lead to arbitrary categorising of components
(e.g.<br/>
<span class="highlight"><code><span class="nc">Data</span><span class="o">#</span><span class="nc">Array</span></code></span>
). These add syntactic clutter and do not bring any real benefit.</p></li>
<li><p>Hierarchical namespaces might lead to deep java-style hierarchies
(e.g.<br/>
<span class="highlight"><code><span class="nc">Com</span><span class="o">#</span><span class="nc">Janestreet</span><span class="o">#</span><span class="nc">Core</span><span class="o">#</span><span class="nc">Std</span></code></span>
). These add syntactic clutter without adding any actual information.</p></li>
</ul>


<p>In favour of hierarchical namespaces:</p>

<ul>
<li>
A library may wish to provide multiple versions of some of its components. For
example:

<ul>
<li>    
<span class="highlight"><code><span class="nc">Http</span><span class="o">#</span><span class="nc">Async</span><span class="o">#</span><span class="nc">IO</span></code></span>
 and 
<span class="highlight"><code><span class="nc">Http</span><span class="o">#</span><span class="nc">Lwt</span><span class="o">#</span><span class="nc">IO</span></code></span>
</li>
<li>
<span class="highlight"><code><span class="nc">File</span><span class="o">#</span><span class="nc">Windows</span><span class="o">#</span><span class="nc">Directories</span></code></span>
and 
<span class="highlight"><code><span class="nc">File</span><span class="o">#</span><span class="nc">Unix</span><span class="o">#</span><span class="nc">Directories</span></code></span>
</li>
<li>
<span class="highlight"><code><span class="nc">Core</span><span class="o">#</span><span class="nc">Mutex</span></code></span>
and 
<span class="highlight"><code><span class="nc">Core</span><span class="o">#</span><span class="nc">Testing</span><span class="o">#</span><span class="nc">Mutex</span></code></span>
</li>
</ul>

In such situations it is useful to be able to write both


<div class="highlight"><pre><code class="ocaml"><span class="k">open</span> <span class="nc">Core</span>
<span class="o">[...]</span>
<span class="nc">Testing</span><span class="o">#</span><span class="nn">Mutex</span><span class="p">.</span><span class="n">lock</span> <span class="n">x</span>
</code></pre></div>


and


<div class="highlight"><pre><code class="ocaml"><span class="k">open</span> <span class="nc">Core</span><span class="o">#</span><span class="nc">Testing</span>
<span class="o">[...]</span>
<span class="nn">Mutex</span><span class="p">.</span><span class="n">lock</span> <span class="n">x</span>
</code></pre></div>

</li>
<li>
None of the systems of namespaces that have been proposed have any
additional cost for supporting hierarchical namespaces.
</li>
</ul>


<h4 id="Should+namespaces+be+opened+explicitly+in+source+code?">Should namespaces be opened explicitly in source code?</h4>

<p>There was some debate on the platform mailing list about whether to support
opening namespaces explicitly in source code. This means allowing a syntax
like:</p>

<div class="highlight">
<pre><code class="ocaml"><span class="k">open</span> <span class="k">namespace</span> <span class="nc">Foo</span></code></pre>
</div>


<p>that allows the members of namespace
<span class="highlight"><code><span class="nc">Foo</span></code></span>
to be referenced directly (i.e.
<span class="highlight"><code><span class="nc">Foo</span><span class="o">#</span><span class="nc">Bar</span></code></span>
can be referred to as
<span class="highlight"><code><span class="nc">Bar</span></code></span>).</p>

<p>The alternative would be to only support opening namespaces through a
command-line argument.</p>

<p>In favour of supporting explicit opens:</p>

<ul>
<li><p>If you open two namespaces with commonly named sub-components then the order
of those opens matters. If the opens are command-line arguments then the
order of those command-line arguments (often determined by build systems and
other tools) matters. This is potentially very fragile.</p></li>
<li><p>Explicit opens in a source file give valuable information about which
libraries are being used by that source file. If a file contains “open
namespace Core” then you know it uses the Core library.</p></li>
<li><p>Local namespace opens provide users more precise control over their naming
environment.</p></li>
</ul>


<p>Against supporting explicit opens:</p>

<ul>
<li>They require a new syntactic construct.</li>
</ul>


<h4 id="How+should+the+compiler+find+modules+in+the+presence+of+namespaces?">How should the compiler find modules in the presence of namespaces?</h4>

<p>Currently, when looking for a module
<span class="highlight"><code><span class="nc">Bar</span></code></span>
that is not in the current environment, the OCaml compiler will search the
directories in its search path for a file called “bar.cmi”.</p>

<p>In the presence of namespaces this becomes more complicated: how does the
compiler find the module
<span class="highlight"><code><span class="nc">Foo</span><span class="o">#</span><span class="nc">Bar</span></code></span>
?</p>

<p>The suggested possible methods for finding modules in the presence of
namespaces fall into four categories.</p>

<h5 id="Using+filenames">Using filenames</h5>

<p>By storing the interface for
<span class="highlight"><code><span class="nc">Foo</span><span class="o">#</span><span class="nc">Bar</span></code></span>
in a file named “foo-bar.cmi” the compiler can continue to simply look-up
modules in its search path.</p>

<p>Note that “–” is an illegal character in module names so there is no risk of
<span class="highlight"><code><span class="nc">Foo</span><span class="o">#</span><span class="nc">Bar</span></code></span>
being confused with a module called
<span class="highlight"><code><span class="nc">Foo-bar</span></code></span>.</p>

<p>This simple scheme does not support placing a module within multiple
namespaces or allowing users to put existing modules in a new namespace.</p>

<h5 id="Checking+multiple++.cmi++files">Checking multiple “.cmi” files</h5>

<p>The name of the namespace containing a compilation unit could be included in
the “.cmi” file of that unit. Then, when looking for a module
<span class="highlight"><code><span class="nc">Foo</span><span class="o">#</span><span class="nc">Bar</span></code></span>
, the compiler would try every “bar.cmi” file in its search path until it
found one that was part of the “Foo” namespace. This may require the compiler
to open all the “bar.cmi” files on its search path, which could be expensive
on certain operating systems.</p>

<p>This scheme does not support allowing users to put existing modules in a new
namespace, but can support placing a module in multiple namespaces.</p>

<p>It is difficult to detect typos in namespace open statements using this
scheme. For example, detecting that
<span class="highlight"><code><span class="k">open</span>
<span class="k">namespace</span>
<span class="nc">Core</span><span class="o">#</span><span class="nc">Sdt</span></code></span>
should have been
<span class="highlight"><code><span class="k">open</span>
<span class="k">namespace</span>
<span class="nc">Core</span><span class="o">#</span><span class="nc">Std</span></code></span>
would require the compiler to check every file in its search path for one that
was part of namespace
<span class="highlight"><code><span class="nc">Core</span><span class="o">#</span><span class="nc">Sdt</span></code></span>.</p>

<h5 id="Using+namespace+description+files">Using namespace description files</h5>

<p>The compiler could find a member of a namespace by consulting a file that
describes the members of that namespace.</p>

<p>For example, if namespace
<span class="highlight"><code><span class="nc">Foo</span></code></span>
was described by a file “foo.ns” that was on the compiler’s search path then
the compiler could find
<span class="highlight"><code><span class="nc">Foo</span><span class="o">#</span><span class="nc">Bar</span></code></span>
by locating “foo.ns” and using it to look-up the location of the “.cmi” file
for
<span class="highlight"><code><span class="nc">Bar</span></code></span>.</p>

<p>These namespace description files could be created automatically by some
tool. However, they must be produced before detecting dependencies with
OCamlDep, which could complicate the build process.</p>

<h5 id="Using+environment+description+files">Using environment description files</h5>

<p>The compiler could find a member of a namespace by consulting a file that
describes a mapping between module names and “.cmi” files.</p>

<p>For example, if a file “foo.mlpath” included the mapping “Foo#Bar:
foo/bar.cmi” then that file could be passed as a command-line argument to the
compiler and used to look up the “bar.cmi” file directly.</p>

<p>Looking up modules using this scheme may speed up compilation by avoiding the
need to scan directories for files.</p>

<h4 id="How+should+namespaces+specified?">How should namespaces specified?</h4>

<p>Perhaps the most important question for any namespaces proposal is how
namespaces are specified. It is closely related to the above question of how
the compiler finds modules in the presence of namespaces.</p>

<p>The suggested possible methods for specifying namespaces fall into five
categories.</p>

<h5 id="Explicitly+in+the+source+files">Explicitly in the source files</h5>

<p>Namespaces could be specified by adding a line like:</p>

<div class="highlight">
<pre><code class="ocaml"><span class="k">namespace</span> <span class="nc">Foo</span></code></pre>
</div>


<p>to the beginning of each compilation unit that is part of the
<span class="highlight"><code><span class="nc">Foo</span></code></span>
namespace.</p>

<p>This has the benefit of making namespaces explicitly part of the language
itself, however it does mean that the full name of a module is specified in
two locations: partly in the filename and partly within the file itself.</p>

<h5 id="Through+command-line+arguments">Through command-line arguments</h5>

<p>Namespaces could be specified by passing a command-line argument to the
compiler. For example,
<span class="highlight"><code><span class="nc">Foo</span><span class="o">#</span><span class="nc">Bar</span></code></span>
could be compiled with the command-line:</p>

<div class="highlight"><pre><code class="sh">ocamlc -c -namespace Foo bar.ml 
</code></pre></div>


<p>This scheme also means that the full name of a module is specified in two
locations: partly in the build system and partly in the filename.</p>

<h5 id="Through+filenames">Through filenames</h5>

<p>Namespaces could be specified using the filenames of source files. For
example,
<span class="highlight"><code><span class="nc">Foo</span><span class="o">#</span><span class="nc">Bar</span></code></span>
would be created by compiling a file “foo-bar.ml”</p>

<p>This scheme is simple and very similar to how modules are currently named, but
it would require all source files to have long unique names.</p>

<h5 id="Through+namespace+description+files">Through namespace description files</h5>

<p>Namespaces could be specified using namespace description files. The
<span class="highlight"><code><span class="nc">Foo</span></code></span>
namespace would be specified by a file “foo.ns” that described the members of
<span class="highlight"><code><span class="nc">Foo</span></code></span>:</p>

<pre><code>module Bar = "foo_bar.cmi"
namespace Testing = "testing.ns"
</code></pre>

<h5 id="Through+environment+description+files">Through environment description files</h5>

<p>Namespaces could be specified using environment description files. A namespace
<span class="highlight"><code><span class="nc">Foo</span></code></span>
would be defined by passing an environment description file to the compiler
that included mappings for each of the members of
<span class="highlight"><code><span class="nc">Foo</span></code></span>. For example:</p>

<pre><code>Foo#Bar: "foo_bar.cmi"
Foo#Testing#Bar: "foo_testing_bar.cmi"
Baz: "baz.cmi"
</code></pre>

<p>In addition to specifying namespaces, this system allows users (or a tool like
OCamlFind) to have complete control the naming environment of a program.</p>

<h4 id="How+rich+should+a+description+language+be?">How rich should a description language be?</h4>

<p>For namespace proposals that use namespace or environment description files,
they must decide how rich their description language should be.</p>

<p>For example, <a href="http://gallium.inria.fr/~scherer/namespaces/spec.pdf">Gabriel Scherer et
al</a> describe a very rich
environment description language including many different operations that can
be performed on namespaces.</p>

<p>A rich description language can produce shorter descriptions. However, the
more operations a language supports the more syntax that users must understand
in order to read description files. The majority of description files are
unlikely to require complex operations.</p>

<h4 id="Should+namespaces+support+automatically+opened+members?">Should namespaces support automatically opened members?</h4>

<p>A feature of namespaces that has been proposed on the mailing list is to allow
some modules within a namespace to be automatically opened when the namespace
is also opened. This makes it seem that the namespace has values and types as
members.</p>

<p>This feature is based on the current design of Jane Street’s Core
library. Users of the Core library are expected to open the
<span class="highlight"><code><span class="nc">Core<span class="p">.</span>Std</span></code></span>
 module before using the library. Opening this module provides access to all
the other modules of the library (much like opening a namespace), but it also
provides types and values similar to those provided by the standard library’s
<span class="highlight"><code><span class="nc">Pervasives</span></code></span> module.</p>

<p>Supporting auto-opened modules would allow
<span class="highlight"><code><span class="nc">Core<span class="p">.</span>Std</span></code></span>
to be directly replaced by a namespace. However, the semantics of this feature
could be awkward due to potential conflicts between members of the namespace
and sub-modules of the auto-opened modules. It also increases the overlap
between namespaces and modules.</p>

<h3 id="Proposal">Proposal</h3>

<p>In the last section of this post I will outline a namespaces proposal that I
think satisfies the design goals set out earlier.</p>

<p>I think that satisfying these design goals requires a combination of
extensions to OCaml. My proposal is made up of four such extensions. To keep
things simple for users to understand, I have tried to keep each of these
extensions completely independent of the others and with a clearly defined
goal.</p>

<h4 id="Simple+namespaces+through+filenames">Simple namespaces through filenames</h4>

<p>Currently, the name of a module is completely defined by its filename, and
modules are looked up using a simple search path. While it has some problems,
this simple paradigm has served OCaml well and I think that it is important to
provide some support for namespaces within this paradigm.</p>

<p>This means allowing simple namespaces to be specified using source file
names. For example, to create a module
<span class="highlight"><code><span class="nc">Bar</span></code></span>
within the namespace
<span class="highlight"><code><span class="nc">Foo</span></code></span>
developers can simply create an implementation file “foo-bar.ml” and an
interface file “foo-bar.mli”. This interface file would be compiled to a
“foo-bar.cmi” file. Hierarchical namespaces would be created by files with
names like “foo-bar-baz.ml”.</p>

<p>These namespaced modules can be referred to using the syntax
<span class="highlight"><code><span class="nc">Foo</span><span class="o">#</span><span class="nc">Bar</span></code></span>.
This syntax simply causes the compiler to look in its search path for a
“foo-bar.cmi” file.</p>

<p>I also propose supporting a namespace opening syntax like:</p>

<div class="highlight">
<pre><code class="ocaml"><span class="k">open</span> <span class="k">namespace</span> <span class="nc">Foo</span>
[...]
<span class="nc">Bar</span></code></pre>
</div>


<h4 id="An+alternative+to+search+paths">An alternative to search paths</h4>

<p>Forcing the name of a module to be completely defined by its (compiled)
filename makes it easy to look-up modules in a search path. However, it
prevents modules from being given multiple names or being renamed by users. So
I propose supporting an alternative look-up mechanism.</p>

<p>I propose supporting environment description files called <em>search path
files</em>. These files would have a syntax like:</p>

<pre><code>Foo#Bar : "other_bar.cmi"
Foo#Baz : Foo#Bar
</code></pre>

<p>This file can be given to the “-I” command-line argument instead of a
directory and used to look-up the locations of “.cmi” files for given module
names.</p>

<p>These search path files can be used to alias modules and to create new
namespaces. They also allow a module to be available under multiple namespaces.</p>

<p>I envisage two particular modes of use:</p>

<ul>
<li><p>Library authors can write “.mlpath” files and tell OCamlFind to use that
file as its search path instead of a list of directories.</p></li>
<li><p>A user (or potentially OCamlFind) can create search path files to define
their entire naming environment as they see fit.</p></li>
</ul>


<h4 id="The++-name++argument">The “-name” argument</h4>

<p>While the hard link between a module’s name and the name of its source file
makes life easier for build systems (“list.cmi” can only be produced by
compiling “list.ml”), it forces library authors to give their source files long
unique names.</p>

<p>I propose adding a “-name” command-line argument to the OCaml compiler. This
would be used as follows:</p>

<div class="highlight"><pre><code class="sh">ocamlc -c -name Foo#Bar other.ml
</code></pre></div>


<p>This command would produce a “foo-bar.cmi” file defining a module named
<span class="highlight"><code><span class="nc">Foo</span><span class="o">#</span><span class="nc">Bar</span></code></span>
. This means that “.cmi” files would still be expected to be unique, but
source files could be named however the developer wants.</p>

<p>Obviously, any tools that assume that a module
<span class="highlight"><code><span class="nc">Bar</span></code></span>
must be compiled from a file called “bar.ml” will not work in this
situation. However, the only OCaml tool that absolutely relies on this
assumption is “OCamlDep” when it is producing makefile formatted output.</p>

<p>Build systems would not be required to support the “-name” argument, however
it would make it easy for them to provide features such as:</p>

<ul>
<li><p>Creating namespaces to reflect a directory structure (e.g. “foo/bar.mli” becomes “foo-bar.cmi”).</p></li>
<li><p>Placing all the modules of a library under a common namespace (e.g. “bar.mli” becomes “foo-bar.cmi”)</p></li>
</ul>


<p>This would mean that the names of source files could be kept conveniently
short.</p>

<h4 id="The++-open++argument">The “-open” argument</h4>

<p>My proposals do not include support for automatically opened modules within
namespaces. I feel that this feature conflates two separate issues and it
would be better to solve the problem of automatically opened modules elsewhere.</p>

<p>Auto-opened modules are meant to allow libraries to provide their own
equivalent of the standard library’s
<span class="highlight"><code><span class="nc">Pervasives</span></code></span>
module. I think that it would be more appropriate to have these “pervasive”
modules opened by default in any program compiled using one of these
libraries.</p>

<p>I propose adding a command-line argument “-open” that could be used to open a
module by default:</p>

<div class="highlight"><pre><code class="sh">ocamlc -c -open core-pervasives.cmi foo.ml
</code></pre></div>


<p>By adding support for this feature to OCamlFind, libraries could add this
argument to every program compiled using them. This amounts to having
automatically opened modules as part of the package system rather than part of
the namespace system.</p><a onclick="switchContent('post2','post1')" class="btn" href="#c3f4de345dacff845f985e402cced3c6">Hide</a></div></span>
<a name="0802910a1b39035bde5255ca97da05df"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/forum/forum.php?forum_id=871"> Barista: 2.0-beta</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge News</span>, <span class="rss-date">08 Mar 2013</span></span><span class="rss-description"><pre class="rss-text">Changes:
  - update for Objective Caml 4.00.1
  - update for Camlzip 1.05
  - new 'graph' command, allowing to generate the graph of classes references
    from a list of archives (supported file formats: Dot, GEXF, and GraphML)
  - new 'Lookup' module allowing to search for Java elements (classes,
    constructors, fields, and methods) from string queries
  - new 'Manifest' module providing support for archive manifest files
  - new 'ArchiveBuilder' module allowing to construct archives from classes,
    and handling manifest, services, and copy from other archives
  - the 'flow' command can now generate output to either GEXF, or GraphML, in
    addition to Dot
  - improved handling of classpaths
  - improved performance for class encoding (about 50% speed-up)
  - improved performance for stack state computations (about 30% speed-up)
  - optimization of switches (turning lookup switches into table switches if it
    saves some place)
  - new peephole optimizations, in order to avoid simple conversions of
    constants
  - API CHANGE: class types for 'traversal' objects enhanced with new methods
  - API CHANGE: 'Traversal' module renamed to 'ClassTraversal'
  - new 'traversal' class type allowing to fold over class elements
  - new 'ArchiveTraversal' module allowing to traverse archives
  - bug: incorrect handling of some 'package-info' class files
  - bug #86: '-ocaml-prefix' doesn't really work
  - bug #87: install shouldn't build anything
  - bug #89: do not activate warnings by default
  - bug #104: configure script should be executable
  - bug #110: error in annotation encoding of string value
  - bug #111: invalid stack frame when locals are changed in a protected block
  - bug #116: invalid stack frame after "invokespecial" instruction</pre></span>
<a name="92bfb9f28f5eb6765ff4f320fdad06cc"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=593"> Barista 2.0-beta</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">08 Mar 2013</span></span><span class="rss-description">Library for Java .class file manipulation.
Also a command-line [dis]assembler for Java.</span>
<a name="86dbf4d4225c32b951bbd5d7b4ccdf18"></a><span class="rss-header"><span class="rss-title"><a href="http://caml.inria.fr/cgi-bin/hump.cgi?contrib=641"> Jane Street's core library 109.11.00</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">The Caml Humps</span>, <span class="rss-date">08 Mar 2013</span></span><span class="rss-description">Jane Street's alternative to the standard library.</span>
<a name="3e720f21429ee19a49cf32078b39dac8"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/projects/sekred/"> Sekred</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge Projects</span>, <span class="rss-date">07 Mar 2013</span></span><span class="rss-description">This program helps to manage passwords set automatically and stored in a semi-secure way.  It is not a secure storage for password because only the Unix ACL system protects the secret.  The system is designed to be a companion tool for puppet.</span>
<a name="e9fc41115a64834508d842591702fb5e"></a><span class="rss-header"><span class="rss-title"><a href="http://blog.opalang.org/2013/03/opa-111-is-coming-soon-book-is-here.html"> Opa 1.1.1 is coming soon. The book is here.</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author"><span id="ocaml_2">Opa &#9001;noreply<abbr title="(at) &rarr; @">(at)</abbr>blogger.com (HB)&#9002;</span><script type="text/javascript"><!--;
local = "noreply";
h = "blogger.com (HB)";
hq = "blogger.com%20(HB)";
document.getElementById("ocaml_2").innerHTML = '<a href="mailto:' + local + '@' + hq + "\" >Opa<\/a>";
//--></script></span>, <span class="rss-date">06 Mar 2013</span></span><span class="rss-description">Two short news:<br/>
<br/>
<ul><li>The latest Node.js release breaks the code generated by Opa 1.1.0. The fix is already in <a href="https://github.com/MLstate/opalang">master</a> -- packages will be available shortly.</li>
<li>The O'Reilly book <a href="http://bit.ly/Wvfbmd">Opa: Up and Running</a> is now available. This is the best source to learn Opa or improve your Opa skills.</li>
</ul><br/></span>
<a name="79d41aa7e4e1d14e47ff443db87f2ac6"></a><span class="rss-header"><span class="rss-title"><a href="https://mancoosi.org/~abate/ocaml-hash-function-and-complex-data-structures-0"> ocaml hash function and complex data structures</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Pietro Abate</span>, <span class="rss-date">06 Mar 2013</span></span><span class="rss-description"><div id="post3"><p>While writing the <a href="http://mancoosi.org/~abate/generic-graphml-printer-ocamlgraph">graphml printer for ocamlgraph</a> (that btw has just been committed in the ocamlgraph svn and it going to be part of the next release of ocamlgraph...), I stumbled in the following pitfall (this is really ocaml for dummies :D).  Imagine you want to associate a unique id to each data type. But you also want that equal values have equal ids. The first (wrong !) idea that might come to mind is to use the <em>Hashtbl.hash</em> function compute this integer uid. Even if this approach might work for simple data structure, it is doomed to fail for more complex data structure whose depth is greater then 10. The natural explanation for this lies in the documentation for the function <em>Hashtbl.hash</em> .</p>

<p>For example consider a simple list. If the list has less then 10 elements, then the hash function will return a unique id and equal lists will be associated to the same id. But if the list contains more then 10 elements, you have the following behavior :  </p><a onclick="switchContent('post3','post4')" class="btn" href="#79d41aa7e4e1d14e47ff443db87f2ac6">Read more...</a></div><div id="post4" style="display: none"><p>While writing the <a href="http://mancoosi.org/~abate/generic-graphml-printer-ocamlgraph">graphml printer for ocamlgraph</a> (that btw has just been committed in the ocamlgraph svn and it going to be part of the next release of ocamlgraph...), I stumbled in the following pitfall (this is really ocaml for dummies :D).  Imagine you want to associate a unique id to each data type. But you also want that equal values have equal ids. The first (wrong !) idea that might come to mind is to use the <em>Hashtbl.hash</em> function compute this integer uid. Even if this approach might work for simple data structure, it is doomed to fail for more complex data structure whose depth is greater then 10. The natural explanation for this lies in the documentation for the function <em>Hashtbl.hash</em> .</p>

<p>For example consider a simple list. If the list has less then 10 elements, then the hash function will return a unique id and equal lists will be associated to the same id. But if the list contains more then 10 elements, you have the following behavior :  </p><div class="geshifilter"><div style="font-family: monospace;" class="ocaml geshifilter-ocaml"><span style="color: #a52a2a;">#</span> <span style="color: #06c; font-weight: bold;">let</span> l2 <span style="color: #a52a2a;">=</span> <span style="color: #a52a2a;">[</span><span style="color: #c6c;">1</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">2</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">3</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">4</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">5</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">6</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">7</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">8</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">9</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">10</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">11</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">12</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">13</span><span style="color: #a52a2a;">]</span> <span style="color: #a52a2a;">;;</span><br/>
<span style="color: #06c; font-weight: bold;">val</span> l2 <span style="color: #a52a2a;">:</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #06c; font-weight: bold;">list</span> <span style="color: #a52a2a;">=</span> <span style="color: #a52a2a;">[</span><span style="color: #c6c;">1</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">2</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">3</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">4</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">5</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">6</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">7</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">8</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">9</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">10</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">11</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">12</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">13</span><span style="color: #a52a2a;">]</span><br/>
<span style="color: #a52a2a;">#</span> <span style="color: #06c; font-weight: bold;">let</span> l1 <span style="color: #a52a2a;">=</span> <span style="color: #a52a2a;">[</span><span style="color: #c6c;">1</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">2</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">3</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">4</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">5</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">6</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">7</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">8</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">9</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">10</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">11</span><span style="color: #a52a2a;">;</span><span style="color: #c6c;">12</span><span style="color: #a52a2a;">]</span> <span style="color: #a52a2a;">;;</span><br/>
<span style="color: #06c; font-weight: bold;">val</span> l1 <span style="color: #a52a2a;">:</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #06c; font-weight: bold;">list</span> <span style="color: #a52a2a;">=</span> <span style="color: #a52a2a;">[</span><span style="color: #c6c;">1</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">2</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">3</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">4</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">5</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">6</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">7</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">8</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">9</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">10</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">11</span><span style="color: #a52a2a;">;</span> <span style="color: #c6c;">12</span><span style="color: #a52a2a;">]</span><br/>
<span style="color: #a52a2a;">#</span> <span style="color: #06c; font-weight: bold;">Hashtbl</span><span style="color: #a52a2a;">.</span>hash l1<span style="color: #a52a2a;">;;</span><br/>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #a52a2a;">=</span> <span style="color: #c6c;">0</span><br/>
<span style="color: #a52a2a;">#</span> <span style="color: #06c; font-weight: bold;">Hashtbl</span><span style="color: #a52a2a;">.</span>hash l2<span style="color: #a52a2a;">;;</span><br/>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #a52a2a;">=</span> <span style="color: #c6c;">0</span></div></div><p></p>

<p>This is fully in line with the Hashtbl.hash function specification. Using the function Hashtbl.hash_param we can easily solve see that the problem here is related to the number of elements that are used to generate the hash code. If we consider more meaningful values, we get different results ...</p>

<p></p><div class="geshifilter"><div style="font-family: monospace;" class="ocaml geshifilter-ocaml"><span style="color: #a52a2a;">#</span> <span style="color: #06c; font-weight: bold;">Hashtbl</span><span style="color: #a52a2a;">.</span>hash_param <span style="color: #c6c;">12</span> <span style="color: #c6c;">100</span> l1<span style="color: #a52a2a;">;;</span><br/>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #a52a2a;">=</span> <span style="color: #c6c;">0</span><br/>
<span style="color: #a52a2a;">#</span> <span style="color: #06c; font-weight: bold;">Hashtbl</span><span style="color: #a52a2a;">.</span>hash_param <span style="color: #c6c;">13</span> <span style="color: #c6c;">100</span> l1<span style="color: #a52a2a;">;;</span><br/>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #a52a2a;">=</span> <span style="color: #c6c;">12</span><br/>
<span style="color: #a52a2a;">#</span> <span style="color: #06c; font-weight: bold;">Hashtbl</span><span style="color: #a52a2a;">.</span>hash_param <span style="color: #c6c;">14</span> <span style="color: #c6c;">100</span> l1<span style="color: #a52a2a;">;;</span><br/>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #a52a2a;">=</span> <span style="color: #c6c;">787199</span><br/>
<br/>
<span style="color: #a52a2a;">...</span><br/>
<br/>
<span style="color: #a52a2a;">#</span> <span style="color: #06c; font-weight: bold;">Hashtbl</span><span style="color: #a52a2a;">.</span>hash_param <span style="color: #c6c;">12</span> <span style="color: #c6c;">100</span> l2<span style="color: #a52a2a;">;;</span><br/>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #a52a2a;">=</span> <span style="color: #c6c;">0</span><br/>
<span style="color: #a52a2a;">#</span> <span style="color: #06c; font-weight: bold;">Hashtbl</span><span style="color: #a52a2a;">.</span>hash_param <span style="color: #c6c;">13</span> <span style="color: #c6c;">100</span> l2<span style="color: #a52a2a;">;;</span><br/>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #a52a2a;">=</span> <span style="color: #c6c;">0</span><br/>
<span style="color: #a52a2a;">#</span> <span style="color: #06c; font-weight: bold;">Hashtbl</span><span style="color: #a52a2a;">.</span>hash_param <span style="color: #c6c;">14</span> <span style="color: #c6c;">100</span> l2<span style="color: #a52a2a;">;;</span><br/>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #a52a2a;">=</span> <span style="color: #c6c;">13</span><br/>
<span style="color: #a52a2a;">#</span> <span style="color: #06c; font-weight: bold;">Hashtbl</span><span style="color: #a52a2a;">.</span>hash_param <span style="color: #c6c;">15</span> <span style="color: #c6c;">100</span> l2<span style="color: #a52a2a;">;;</span><br/>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #a52a2a;">=</span> <span style="color: #c6c;">852799</span><br/>
<span style="color: #a52a2a;">#</span> <span style="color: #06c; font-weight: bold;">Hashtbl</span><span style="color: #a52a2a;">.</span>hash_param <span style="color: #c6c;">16</span> <span style="color: #c6c;">100</span> l2<span style="color: #a52a2a;">;;</span><br/>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #a52a2a;">=</span> <span style="color: #c6c;">108186764</span><br/>
<span style="color: #a52a2a;">#</span> <span style="color: #06c; font-weight: bold;">Hashtbl</span><span style="color: #a52a2a;">.</span>hash_param <span style="color: #c6c;">17</span> <span style="color: #c6c;">100</span> l2<span style="color: #a52a2a;">;;</span><br/>
<span style="color: #a52a2a;">-</span> <span style="color: #a52a2a;">:</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #a52a2a;">=</span> <span style="color: #c6c;">583816830</span></div></div><p></p>

<p>Now this is of course an example and using hash_param is not an option. If we really want to hash a list we need something more reliable then to guess a value for  hash_param.</p>

<p>What we can do is to encapsulate our values in a new data type "Unique" that will make sure that each value is associated to a really unique id. The practice is easy :</p>

<p></p><div class="geshifilter"><div style="font-family: monospace;" class="ocaml geshifilter-ocaml"><span style="color: #06c; font-weight: bold;">module</span> <span style="color: #06c; font-weight: bold;">type</span> UniqueType <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">sig</span><br/>
  <span style="color: #06c; font-weight: bold;">type</span> t<br/>
  <span style="color: #06c; font-weight: bold;">type</span> v<br/>
  <span style="color: #06c; font-weight: bold;">val</span> create <span style="color: #a52a2a;">:</span> v <span style="color: #a52a2a;">-&gt;</span> t<br/>
  <span style="color: #06c; font-weight: bold;">val</span> value <span style="color: #a52a2a;">:</span> t <span style="color: #a52a2a;">-&gt;</span> v<br/>
  <span style="color: #06c; font-weight: bold;">val</span> uid <span style="color: #a52a2a;">:</span> t <span style="color: #a52a2a;">-&gt;</span> <span style="color: #06c; font-weight: bold;">int</span><br/>
<span style="color: #06c; font-weight: bold;">end</span><br/>
 <br/>
<span style="color: #06c; font-weight: bold;">module</span> <span style="color: #06c; font-weight: bold;">type</span> OrderedType <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">sig</span> <span style="color: #06c; font-weight: bold;">type</span> t <span style="color: #06c; font-weight: bold;">val</span> <span style="color: #06c; font-weight: bold;">compare</span> <span style="color: #a52a2a;">:</span> t <span style="color: #a52a2a;">-&gt;</span> t <span style="color: #a52a2a;">-&gt;</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #06c; font-weight: bold;">end</span><br/>
 <br/>
<span style="color: #06c; font-weight: bold;">module</span> UniqueMake <span style="color: #a52a2a;">(</span> S <span style="color: #a52a2a;">:</span> OrderedType <span style="color: #a52a2a;">)</span> <span style="color: #a52a2a;">:</span> UniqueType <span style="color: #06c; font-weight: bold;">with</span> <span style="color: #06c; font-weight: bold;">type</span> v <span style="color: #a52a2a;">=</span> S<span style="color: #a52a2a;">.</span>t <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">struct</span><br/>
 <br/>
  <span style="color: #06c; font-weight: bold;">module</span> VMap <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">Map</span><span style="color: #a52a2a;">.</span>Make<span style="color: #a52a2a;">(</span>S<span style="color: #a52a2a;">)</span><br/>
 <br/>
  <span style="color: #06c; font-weight: bold;">type</span> v <span style="color: #a52a2a;">=</span> S<span style="color: #a52a2a;">.</span>t<br/>
  <span style="color: #06c; font-weight: bold;">type</span> t <span style="color: #a52a2a;">=</span> Hash <span style="color: #06c; font-weight: bold;">of</span> <span style="color: #a52a2a;">(</span>v <span style="color: #a52a2a;">*</span> <span style="color: #06c; font-weight: bold;">int</span><span style="color: #a52a2a;">)</span><br/>
 <br/>
  <span style="color: #06c; font-weight: bold;">let</span> gentag <span style="color: #a52a2a;">=</span><br/>
    <span style="color: #06c; font-weight: bold;">let</span> r <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">ref</span> <span style="color: #c6c;">0</span> <span style="color: #06c; font-weight: bold;">in</span><br/>
    <span style="color: #06c; font-weight: bold;">fun</span> <span style="color: #a52a2a;">(</span><span style="color: #a52a2a;">)</span> <span style="color: #a52a2a;">-&gt;</span> <span style="color: #06c; font-weight: bold;">incr</span> r<span style="color: #a52a2a;">;</span> <span style="color: #a52a2a;">!</span>r<br/>
 <br/>
  <span style="color: #06c; font-weight: bold;">let</span> cons <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">ref</span> VMap<span style="color: #a52a2a;">.</span>empty<br/>
 <br/>
  <span style="color: #06c; font-weight: bold;">let</span> create v <span style="color: #a52a2a;">=</span><br/>
    <span style="color: #06c; font-weight: bold;">try</span> Hash<span style="color: #a52a2a;">(</span>v,VMap<span style="color: #a52a2a;">.</span>find v <span style="color: #a52a2a;">!</span>cons<span style="color: #a52a2a;">)</span> <span style="color: #06c; font-weight: bold;">with</span><br/>
    Not_found <span style="color: #a52a2a;">-&gt;</span> <span style="color: #06c; font-weight: bold;">begin</span><br/>
      <span style="color: #06c; font-weight: bold;">let</span> i <span style="color: #a52a2a;">=</span> gentag <span style="color: #a52a2a;">(</span><span style="color: #a52a2a;">)</span> <span style="color: #06c; font-weight: bold;">in</span><br/>
      cons <span style="color: #a52a2a;">:=</span> VMap<span style="color: #a52a2a;">.</span>add v i <span style="color: #a52a2a;">!</span>cons<span style="color: #a52a2a;">;</span><br/>
      Hash <span style="color: #a52a2a;">(</span>v,i<span style="color: #a52a2a;">)</span><br/>
    <span style="color: #06c; font-weight: bold;">end</span><br/>
 <br/>
  <span style="color: #06c; font-weight: bold;">let</span> value <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">function</span> Hash <span style="color: #a52a2a;">(</span>v,_<span style="color: #a52a2a;">)</span> <span style="color: #a52a2a;">-&gt;</span> v<br/>
  <span style="color: #06c; font-weight: bold;">let</span> uid <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">function</span> Hash <span style="color: #a52a2a;">(</span>_,i<span style="color: #a52a2a;">)</span> <span style="color: #a52a2a;">-&gt;</span> i<br/>
 <br/>
<span style="color: #06c; font-weight: bold;">end</span></div></div><p></p>

<p>In this module I use a variant data type and a Map to keep track the uids. And there is really nothing deep about it. Another idea would be to use a phantom type instead, in this version I've to query the map each time I want to associate an uid with a value.</p>

<p></p><div class="geshifilter"><div style="font-family: monospace;" class="ocaml geshifilter-ocaml"><span style="color: #06c; font-weight: bold;">module</span> <span style="color: #06c; font-weight: bold;">type</span> UniqueType <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">sig</span><br/>
  <span style="color: #06c; font-weight: bold;">type</span> unique<br/>
  <span style="color: #06c; font-weight: bold;">type</span> v<br/>
  <span style="color: #06c; font-weight: bold;">type</span> <span style="color: #a52a2a;">'</span>a t<br/>
  <span style="color: #06c; font-weight: bold;">val</span> create <span style="color: #a52a2a;">:</span> v <span style="color: #a52a2a;">-&gt;</span> unique t<br/>
  <span style="color: #06c; font-weight: bold;">val</span> value <span style="color: #a52a2a;">:</span> unique t <span style="color: #a52a2a;">-&gt;</span> v<br/>
  <span style="color: #06c; font-weight: bold;">val</span> uid <span style="color: #a52a2a;">:</span> unique t <span style="color: #a52a2a;">-&gt;</span> <span style="color: #06c; font-weight: bold;">int</span><br/>
<span style="color: #06c; font-weight: bold;">end</span><br/>
 <br/>
<span style="color: #06c; font-weight: bold;">module</span> <span style="color: #06c; font-weight: bold;">type</span> OrderedType <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">sig</span> <span style="color: #06c; font-weight: bold;">type</span> t <span style="color: #06c; font-weight: bold;">val</span> <span style="color: #06c; font-weight: bold;">compare</span> <span style="color: #a52a2a;">:</span> t <span style="color: #a52a2a;">-&gt;</span> t <span style="color: #a52a2a;">-&gt;</span> <span style="color: #06c; font-weight: bold;">int</span> <span style="color: #06c; font-weight: bold;">end</span><br/>
 <br/>
<span style="color: #06c; font-weight: bold;">module</span> Unique <span style="color: #a52a2a;">(</span> S <span style="color: #a52a2a;">:</span> OrderedType <span style="color: #a52a2a;">)</span> <span style="color: #a52a2a;">:</span> UniqueType <span style="color: #06c; font-weight: bold;">with</span> <span style="color: #06c; font-weight: bold;">type</span> v <span style="color: #a52a2a;">=</span> S<span style="color: #a52a2a;">.</span>t <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">struct</span><br/>
 <br/>
  <span style="color: #06c; font-weight: bold;">module</span> VMap <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">Map</span><span style="color: #a52a2a;">.</span>Make<span style="color: #a52a2a;">(</span>S<span style="color: #a52a2a;">)</span><br/>
  <span style="color: #06c; font-weight: bold;">type</span> unique<br/>
 <br/>
  <span style="color: #06c; font-weight: bold;">type</span> v <span style="color: #a52a2a;">=</span> S<span style="color: #a52a2a;">.</span>t<br/>
  <span style="color: #06c; font-weight: bold;">type</span> <span style="color: #a52a2a;">'</span>unique t <span style="color: #a52a2a;">=</span> S<span style="color: #a52a2a;">.</span>t<br/>
 <br/>
  <span style="color: #06c; font-weight: bold;">let</span> gentag <span style="color: #a52a2a;">=</span><br/>
    <span style="color: #06c; font-weight: bold;">let</span> r <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">ref</span> <span style="color: #c6c;">0</span> <span style="color: #06c; font-weight: bold;">in</span><br/>
    <span style="color: #06c; font-weight: bold;">fun</span> <span style="color: #a52a2a;">(</span><span style="color: #a52a2a;">)</span> <span style="color: #a52a2a;">-&gt;</span> <span style="color: #06c; font-weight: bold;">incr</span> r<span style="color: #a52a2a;">;</span> <span style="color: #a52a2a;">!</span>r<br/>
 <br/>
  <span style="color: #06c; font-weight: bold;">let</span> cons <span style="color: #a52a2a;">=</span> <span style="color: #06c; font-weight: bold;">ref</span> VMap<span style="color: #a52a2a;">.</span>empty<br/>
 <br/>
  <span style="color: #06c; font-weight: bold;">let</span> create v <span style="color: #a52a2a;">=</span><br/>
    <span style="color: #06c; font-weight: bold;">if</span> <span style="color: #06c; font-weight: bold;">not</span><span style="color: #a52a2a;">(</span>VMap<span style="color: #a52a2a;">.</span>mem v <span style="color: #a52a2a;">!</span>cons<span style="color: #a52a2a;">)</span> <span style="color: #06c; font-weight: bold;">then</span><br/>
      cons <span style="color: #a52a2a;">:=</span> VMap<span style="color: #a52a2a;">.</span>add v <span style="color: #a52a2a;">(</span>gentag <span style="color: #a52a2a;">(</span><span style="color: #a52a2a;">)</span><span style="color: #a52a2a;">)</span> <span style="color: #a52a2a;">!</span>cons<span style="color: #a52a2a;">;</span><br/>
    v<br/>
 <br/>
  <span style="color: #06c; font-weight: bold;">let</span> value v <span style="color: #a52a2a;">=</span> v<br/>
  <span style="color: #06c; font-weight: bold;">let</span> uid v <span style="color: #a52a2a;">=</span> VMap<span style="color: #a52a2a;">.</span>find v <span style="color: #a52a2a;">!</span>cons<br/>
 <br/>
<span style="color: #06c; font-weight: bold;">end</span></div></div><p></p>

<p>This is a very simple way of getting a unique ID for any custom data structure. Another way would be wrap my data structures in an object and then use <strong>Oo.id</strong> . I haven't tried this approach yet.</p><a onclick="switchContent('post4','post3')" class="btn" href="#79d41aa7e4e1d14e47ff443db87f2ac6">Hide</a></div></span>
<a name="f3ec9647f88b272fcb4f95537b008aeb"></a><span class="rss-header"><span class="rss-title"><a href="http://alan.petitepomme.net/cwn/2013.03.05.html"> Caml Weekly News, 05 Mar 2013</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">Caml Weekly News</span>, <span class="rss-date">05 Mar 2013</span></span><span class="rss-description">Brand-new BER MetaOCaml for OCaml 4.00.1 / Core Suite 109.11.00 released + ocaml_plugin / Research Assistantship at Oxford on Bidirectional Transformations / Other Caml News</span>
<a name="38faea8ab2754bc8157a129078b7bb44"></a><span class="rss-header"><span class="rss-title"><a href="http://gallium.inria.fr/blog/generators-iterators-control-and-continuations"> Generators, iterators, control and continuations</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">GaGallium</span>, <span class="rss-date">03 Mar 2013</span></span><span class="rss-description"><div id="post5"><p>Batteries contributors recently started a new discussion on the Enum module, whose purpose is to provide an good intermediate representation for conversion between data-structures, but whose implementation is perceived as too complicated and not well-understood enough. Going back to fundamentals (forgetting about half the features of Enum), what is the ultimate intermediate traversal interface?</p>
<p>There are two obvious choices in an effectful setting: a <em>generator</em>, that is a "next-element" function of type <code>('a -&gt; unit)</code> that generates the next element each time it is called, or an exception to signal end of input; or an <em>iterator</em>, a fold-function of type <code>('a -&gt; unit) -&gt; unit</code>, that iterates a consumer function through all elements of the list.</p>
<a onclick="switchContent('post5','post6')" class="btn" href="#38faea8ab2754bc8157a129078b7bb44">Read more...</a></div><div id="post6" style="display: none"><p>Batteries contributors recently started a new discussion on the Enum module, whose purpose is to provide an good intermediate representation for conversion between data-structures, but whose implementation is perceived as too complicated and not well-understood enough. Going back to fundamentals (forgetting about half the features of Enum), what is the ultimate intermediate traversal interface?</p>
<p>There are two obvious choices in an effectful setting: a <em>generator</em>, that is a "next-element" function of type <code>('a -&gt; unit)</code> that generates the next element each time it is called, or an exception to signal end of input; or an <em>iterator</em>, a fold-function of type <code>('a -&gt; unit) -&gt; unit</code>, that iterates a consumer function through all elements of the list.</p>
<p>Both are suitable as an abstract representation of any sequence (the second is precisely the basis for Simon Cruanes' <a href="https://github.com/c-cube/sequence">Sequence</a> library), and their are at opposite ends of the <em>control</em> spectrum: generators give control to the <em>consumer</em> of the sequence (she decides when to call the generator function), while iterators give control to the <em>producer</em> of the sequence (she decides when to call the iterated function). It's easy to transform a structure into a iter (<code>to_iter</code>), or to build a structure from a next (<code>of_next</code>), because you have the control. But as a library writer, you should also write the without-control conversions (<code>of_iter</code> and <code>to_next</code>), despite them being slower and harder to implement, so that your users can live the easy in-control life!</p>
<p>Finally, continuation capture is a well-known technique to <em>invert</em> control, letting you write code in "direct style", as if you were in control, when you're not. In this post, I will demonstrate how you can start from a conversion function that has control and, by systematic source-to-source transformations of conversion to continuation-passing-style (CPS) and defunctionalization, obtain a conversion function that works without the control.</p>




<p>We are interested in datatypes that support the following interface:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> 'a iter = ('a -&gt; <span class="dt">unit</span>) -&gt; <span class="dt">unit</span>
<span class="kw">type</span> 'a gen = <span class="dt">unit</span> -&gt; 'a

<span class="ot">module</span> <span class="kw">type</span> <span class="dt">Data</span> = <span class="kw">sig</span>
  <span class="kw">type</span> 'a t
  <span class="kw">val</span> of_iter : 'a iter -&gt; 'a t
  <span class="kw">val</span> to_iter : 'a t -&gt; 'a iter
  <span class="kw">val</span> of_gen : 'a gen -&gt; 'a t
  <span class="kw">val</span> to_gen : 'a t -&gt; 'a gen
<span class="kw">end</span></code></pre>
<p>Note that there is no support for predicting the size of the data structure: those will not be good interfaces for fixed-size structures such as <code>array</code>. We will use lists as a warm-ups, and then concentrate on binary trees as a structure with more complicated traversal and construction patterns.</p>
<h4 id="lists-as-a-warm-up">Lists as a warm-up</h4>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="ot">module</span> List : <span class="dt">Data</span> <span class="kw">with</span> <span class="kw">type</span> 'a t = 'a <span class="dt">list</span>
= <span class="kw">struct</span>
  <span class="kw">type</span> 'a t = 'a <span class="dt">list</span>

  <span class="co">(* producer, with control *)</span>
  <span class="kw">let</span> to_iter li = <span class="kw">fun</span> f -&gt;
    <span class="kw">let</span> <span class="kw">rec</span> loop = <span class="kw">function</span>
      | [] -&gt; ()
      | x :: xs -&gt; f x; loop xs
    <span class="kw">in</span> loop li

  <span class="co">(* producer, without control *)</span>
  <span class="kw">let</span> to_gen li =
    <span class="kw">let</span> st = <span class="dt">ref</span> li <span class="kw">in</span>
    <span class="kw">fun</span> () -&gt; <span class="kw">match</span> !st <span class="kw">with</span>
      | [] -&gt; raise <span class="dt">Exit</span>
      | x::xs -&gt; st := xs; x

  <span class="co">(* consumer, with control *)</span>
  <span class="kw">let</span> of_gen gen =
    <span class="kw">let</span> st = <span class="dt">ref</span> [] <span class="kw">in</span>
    <span class="kw">try</span> <span class="kw">while</span> <span class="kw">true</span> <span class="kw">do</span> st := gen () :: !st <span class="kw">done</span>; raise <span class="dt">Exit</span>
    <span class="kw">with</span> <span class="dt">Exit</span> -&gt; List<span class="kw">.</span>rev !st

  <span class="co">(* consumer, without control *)</span>
  <span class="kw">let</span> of_iter iter =
    <span class="kw">let</span> st = <span class="dt">ref</span> [] <span class="kw">in</span>
    iter (<span class="kw">fun</span> x -&gt; st := x :: !st);
    List<span class="kw">.</span>rev !st
<span class="kw">end</span></code></pre>
<p>Lists are no surprise. Both consumers, with or without control, are extremely simple to write. For producers, we would argue that <code>to_iter</code> is more convenient to express, and more elegant, than <code>to_gen</code>, but the difference is again small.</p>
<p>I did a bit of shallow performance testing, and without surprise the version with control was always faster than the version without control. I also tested the compositions <code>of_gen (to_gen li)</code> and <code>of_seq (to_seq li)</code> and the <code>gen</code> versions, with the simpler types, seems slightly faster -- but it's hard to get anything meaningful with code so simple.</p>
<h4 id="a-generator-for-binary-trees">A generator for binary trees</h4>
<p>The real meat of this post is the work on binary trees. Iterating on binary trees is easy, and will serve a good example of continuation-passing-style (CPS) transform. Building trees from sequences is more subtle, and will make for a more sophisticated application of the same principles.</p>
<p>We use binary trees with data on the nodes, and empty leaves.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> 'a tree = <span class="dt">Leaf</span> | <span class="dt">Node</span> <span class="kw">of</span> 'a tree * 'a * 'a tree</code></pre>
<p>Do you know the trick to create a tree of <code>O(2^n)</code> nodes in <code>O(n)</code> time? It's useless for this post, but I've been using it for performance evaluation, so I'll leave it here.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> deep = <span class="kw">function</span>
  | 0 -&gt; <span class="dt">Leaf</span>
  | n -&gt; <span class="kw">let</span> t = deep (n - 1) <span class="kw">in</span> <span class="dt">Node</span> (t, n, t)

<span class="kw">let</span> long_tree = deep 18</code></pre>
<p>We will start with the simple and well-known <code>iter</code> function:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> iter f = <span class="kw">function</span>
  | <span class="dt">Leaf</span> -&gt; ()
  | <span class="dt">Node</span> (left, x, right) -&gt; iter f left; f x; iter f right

<span class="kw">let</span> to_iter t f = iter f t</code></pre>
<p>We wish to get a <em>generator</em> from a tree (<code>to_gen</code>), starting from the code of the <code>to_iter</code> function. <code>iter</code> has the control, it decides when to call the function <code>f</code>. A single (sub-)call to the iter function may call <code>f</code> one time, several times (recursively), or not at all. On the contrary, the difficulty in writing a generator is to understand how to advance precisely to the next element of the data-structure, one step at the time, when the user calls the generator.</p>
<p>Our first transformation will be to turn <code>iter</code> into continuation-passing-style. We have already covered this transformation <a href="http://gallium.inria.fr/blog/stack-overflow-continuations/">in a previous blog series</a>, as a tool to get tail-recursive implementations of any recursive functions, trading stack space for heap-allocated closures. The idea is to capture the "context" (what will be done to its return value) of each recursive call as an additional parameter of the recursive function.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> iter_cps f t k = <span class="kw">match</span> t <span class="kw">with</span>
  | <span class="dt">Leaf</span> -&gt; k ()
  | <span class="dt">Node</span> (left, x, right) -&gt;
    iter_cps f left (<span class="kw">fun</span> () -&gt;
      f x; iter_cps f right k)

<span class="kw">let</span> to_iter t f = iter_cps f t (<span class="kw">fun</span> result -&gt; result)</code></pre>
<p>Another way to see this transformation is to consider that we abstract on the "return address" of the function; we may call the continuation parameter <code>return</code>, and the function then reads <code>| Leaf -&gt; return ()</code>, etc.</p>
<p>The next transformation step is to remove the higher-order aspect associated to our representation of continuation as functions. We could in fact stop here, and derive a generator from this iterator in CPS, but using a first-order data-centric representation will give us an algorithm that is closer to the algorithm that people tend to write naturally -- and will also be a bit more efficient, but I won't insist on performance considerations.</p>
<p>The idea of <em>defunctionalization</em> is to collect all the different lambda-terms that are used in the function, and give each of them a name (a symbol, a piece of data). Instead of the lambda-term, we will only pass the name as the <code>k</code> parameter, and have an additional <code>run</code> function that, from the name, execute the relevant code (that was in the lambda-term).</p>
<p>In our code examples there are two lambda-terms: <code>(fun () -&gt; f x; iter_cps f right k)</code> and <code>(fun result -&gt; result)</code>. We will call the first <code>Left</code>, as it marks the fact that we have already iterated on the left of the current tree, and the second one <code>Stop</code> as it marks the end of the computation, the last continuation ever passed, to get the final result. But the <code>Left</code> lambda-term does not only takes a parameter, it also captures the variable <code>x</code>, <code>right</code> and <code>k</code> that are in its scope, and need to be saved for when the continuation will be executed. So <code>Left</code> will be a constructor with three parameters, one for each of those variables:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> 'a kiter =
  | <span class="dt">Stop</span>
  | <span class="dt">Left</span> <span class="kw">of</span> 'a kiter * 'a * 'a tree

<span class="kw">let</span> <span class="kw">rec</span> iter_cps_defun f t k = <span class="kw">match</span> t <span class="kw">with</span>
  | <span class="dt">Leaf</span> -&gt; run f k
  | <span class="dt">Node</span> (left, x, right) -&gt;
    iter_cps_defun f left (<span class="dt">Left</span> (k, x, right))
<span class="kw">and</span> run f = <span class="kw">function</span>
  | <span class="dt">Stop</span> -&gt; ()
  | <span class="dt">Left</span> (k, x, right) -&gt; f x; iter_cps_defun f right k</code></pre>
<p>The new function <code>run</code> takes a data representation of continuation, and runs the corresponding code. I want to emphasize that this transformation again requires no deep thinking, it is only a systematic source-to-source transformation.</p>
<p>You may have noticed that the type of our reified continuations, <code>'a kiter</code>, looks very much like our <code>'a tree</code> datatype. In fact, it is isomorphic to it (if we assume <code>'a kiter ≃ 'a tree</code>, then <code>Left</code> looks very much like <code>Node</code>), so we can rewrite <code>iter_cps_defun</code> with no specific continuation type, using <code>tree</code> to store both data and continuations:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> iter_cps_defun f t k = <span class="kw">match</span> t <span class="kw">with</span>
  | <span class="dt">Leaf</span> -&gt; run f k
  | <span class="dt">Node</span> (left, x, right) -&gt; iter_cps_defun f left (<span class="dt">Node</span> (k, x, right))
<span class="kw">and</span> run f = <span class="kw">function</span>
  | <span class="dt">Leaf</span> -&gt; ()
  | <span class="dt">Node</span> (k, x, right) -&gt; f x; iter_cps_defun f right k

<span class="kw">let</span> to_iter t f = iter_cps_defun f t <span class="dt">Leaf</span></code></pre>
<p>If you squint your eyes a bit, what you have in front of you is a purely functional realization of a well-known traversal technique called <em>pointer reversal</em>. We call <code>iter</code> with a pointer <code>k</code> to "the rest of the work to be done", and when we descend in the <code>left</code> subtree, we replace <code>k</code> with a version of the parent tree <code>t</code> where the left child points not to <code>left</code> anymore, but to <code>k</code> (the parent of <code>t</code>). Of course, pointer reversal are useful for in-place traversals, so this realization is of little practical interest for an persistent immutable tree type where the nodes are copied anyway. But it's still nice to see how, by systematic application of general applications, we reach a place that is already well-known.</p>
<p>Finally, this implementation of the traversal function is low-level enough to be turned into a generator function. The idea is that instead of passing the <code>k</code> argument recursively in an iterator, we can store it in a reference cell between calls to a generator.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> to_gen t =
  <span class="kw">let</span> next = <span class="dt">ref</span> t <span class="kw">in</span>
  <span class="kw">let</span> cont = <span class="dt">ref</span> <span class="dt">Leaf</span> <span class="kw">in</span>
  <span class="kw">let</span> <span class="kw">rec</span> iter t k = <span class="kw">match</span> t <span class="kw">with</span>
    | <span class="dt">Leaf</span> -&gt; run k
    | <span class="dt">Node</span> (left, x, right) -&gt; iter left (<span class="dt">Node</span> (k, x, right))
  <span class="kw">and</span> run = <span class="kw">function</span>
    | <span class="dt">Leaf</span> -&gt; raise <span class="dt">Exit</span>
    | <span class="dt">Node</span> (k, x, right) -&gt;
      next := right;
      cont := k;
      x
  <span class="kw">in</span> <span class="kw">fun</span> () -&gt; iter !next !cont</code></pre>
<p>This is the same code as before, except that instead of calling <code>f x</code> (that's what you do when you have the control), we store the current state of the traversal, and return <code>x</code>. The CPS transform is precisely what exposed this notion of "state of the traversal" in a way that is convenient to capture through calls.</p>
<p>Let me bore you with some performance details:</p>
<pre><code>Tree.iter (1.59 ms) is 13.6% faster than
Tree.iter_cps_defun (1.84 ms) which is 14.7% faster than
Tree.iter_cps (2.16 ms)</code></pre>
<p>So there is a cost to pay when inverting control, but in this case it is quite low. Remember than in general your running time will be dominated by what you want to do on each element of a structure, not its traversal itself, so measuring traversals only distort performance results. A 15% difference in a micro-benchmark means that users would most probably not notice the change.</p>
<p>Finally, I will remark that it is possible to revert control by using an off-the-shelf delimited continuation library. This is more general and modular, but may also be noticeably slower. I have tried doing that with Oleg's delightful <a href="http://okmij.org/ftp/continuations/implementations.html#caml-shift">Delimcc</a> library, that is really not invasive (not requiring any change to the OCaml compiler or runtime); the code is funny (and possibly wrong, I'm not a Delimcc expert), but not competitive performance-wise because the continuation-capture operations are heavier, and not meant to be used at this granularity level.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* this must be compiled with -rectypes *)</span>
<span class="kw">let</span> to_gen_delim t =
  <span class="kw">let</span> p = Delimcc<span class="kw">.</span>new_prompt () <span class="kw">in</span>
  <span class="kw">let</span> next = <span class="dt">ref</span> <span class="kw">begin</span>
    Delimcc<span class="kw">.</span>push_prompt p (<span class="kw">fun</span> () -&gt;
      to_seq t (<span class="kw">fun</span> x -&gt;
        Delimcc<span class="kw">.</span>take_subcont p (<span class="kw">fun</span> k () -&gt; <span class="dt">Some</span> (x, k)));
      <span class="dt">None</span>)
  <span class="kw">end</span> <span class="kw">in</span>
  <span class="kw">fun</span> () -&gt;
    <span class="kw">match</span> !next <span class="kw">with</span>
      | <span class="dt">None</span> -&gt; raise <span class="dt">Exit</span>
      | <span class="dt">Some</span> (x, k) -&gt;
        next := Delimcc<span class="kw">.</span>push_delim_subcont k (<span class="kw">fun</span> () -&gt; ());
        x</code></pre>
<p>This implements <code>to_gen</code> (that doesn't have control) in terms of <code>to_seq</code> (that requires control). The idea is that the iteration function that we feed to <code>to_seq</code>, when called, captures the current continuation, that is the "rest of the traversal", and returns it along with the element that was passed. Each time our generator is called, it reinstates the continuation to keep computing until the next element, where it gets suspended again.</p>
<p>Note that this definition is not at all specific to trees, it could be defined generically. Furthermore, we can use the exact same technique to implement <code>of_seq</code> in terms of <code>of_gen</code>.</p>
<p>This code snippet must be compiled with <code>-rectypes</code> because the type of the captured continuation <code>next</code> is equi-recursive: it represents the rest of a computation that, when called, returns a reified value representing the rest of a computation that... It would be possible to look at this recursive type in the eye and define an explicit recursive algebraic datatype for it, to get rid of <code>-rectypes</code>, but I was too lazy to do that.</p>
<h4 id="filling-a-tree">Filling a tree</h4>
<p>That was the two conversion functions <em>from</em> a tree, <code>to_iter</code> and <code>to_gen</code>. What about building a tree from iterator or generators?</p>
<p>First, there is a non-trivial question: how do you build a tree from a sequence? If you had a balanced search tree, you would have an <code>add</code> function and would most probably build the tree by folding over the sequence elements, <code>add</code>-ing one element at a time. But I want something that looks simpler (than maintaining search invariant), but that I actually found harder: fill the tree from left to right.</p>
<p>More precisely, I expect that giving a number of elements that is a power of two would return me a complete tree, with all leaves at the same heights, and that giving less elements would return me a tree with a complete left sub-tree, and a partially-filled right subtree.</p>
<p>Here is the implementation I got after a bit of tinkering. There may be other ways to implement this, and I'm open to suggestions of simpler approaches.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(** returns a tree of height [n], along with a boolean [finished]</span>
<span class="co">    indicating whether the generator was exhausted during the</span>
<span class="co">    construction. If [finished] is false, the tree is a complete tree</span>
<span class="co">    of height [n], otherwise it may be partial. *)</span>
<span class="kw">let</span> <span class="kw">rec</span> fill f n =
  <span class="kw">match</span> n <span class="kw">with</span>
  | 0 -&gt; <span class="kw">false</span>, <span class="dt">Leaf</span>
  | _ -&gt;
    <span class="kw">let</span> finished, left = fill f (n - 1) <span class="kw">in</span>
    <span class="kw">if</span> finished <span class="kw">then</span> finished, left
    <span class="kw">else</span> fill_right f n left

<span class="co">(** taking a complete left subtree as input, it builds a node by</span>
<span class="co">    creating a possibly-partial right subtree *)</span>
<span class="kw">and</span> fill_right f n left =
  <span class="kw">match</span> (<span class="kw">try</span> <span class="dt">Some</span> (f ()) <span class="kw">with</span> <span class="dt">Exit</span> -&gt; <span class="dt">None</span>) <span class="kw">with</span>
    | <span class="dt">None</span> -&gt; <span class="kw">true</span>, left
    | <span class="dt">Some</span> x -&gt;
      <span class="kw">let</span> finished, right = fill f (n - 1) <span class="kw">in</span>
      finished, <span class="dt">Node</span> (left, x, right)

<span class="co">(** iterate the filling functions above with ever-increasing values of</span>
<span class="co">    `n`, until the generator is exhausted. *)</span>
<span class="kw">let</span> <span class="kw">rec</span> loop f n left =
  <span class="kw">match</span> fill_right f n left <span class="kw">with</span>
    | <span class="kw">true</span>, t -&gt; t
    | <span class="kw">false</span>, left -&gt; loop f (n + 1) left</code></pre>
<p>It is easy to define <code>of_gen</code> from such a filling function:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> of_gen f = loop f 1 <span class="dt">Leaf</span></code></pre>
<p>To get a version without control (<code>of_iter</code>), we should again turn these function into CPS form, and then defunctionalize the result. The CPS version is unsurprising; you don't need to read all the code, only look at the continuations following recursive calls.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> fill_cps f n k = <span class="kw">match</span> n <span class="kw">with</span>
  | 0 -&gt; k <span class="kw">false</span> <span class="dt">Leaf</span>
  | _ -&gt;
    fill_cps f (n - 1) (<span class="kw">fun</span> finished left -&gt;
      <span class="kw">if</span> finished <span class="kw">then</span> k finished left
      <span class="kw">else</span> fill_right_cps f n left k)
<span class="kw">and</span> fill_right_cps f n left k =
  <span class="kw">match</span> (<span class="kw">try</span> <span class="dt">Some</span> (f ()) <span class="kw">with</span> <span class="dt">Exit</span> -&gt; <span class="dt">None</span>) <span class="kw">with</span>
    | <span class="dt">None</span> -&gt; k <span class="kw">true</span> left
    | <span class="dt">Some</span> x -&gt;
      fill_cps f (n - 1) (<span class="kw">fun</span> finished right -&gt;
        k finished (<span class="dt">Node</span> (left, x, right)))

<span class="kw">let</span> <span class="kw">rec</span> loop_cps f n left k =
  fill_right_cps f n left (<span class="kw">fun</span> finished t -&gt;
    <span class="kw">if</span> finished <span class="kw">then</span> k t
    <span class="kw">else</span> loop_cps f (n + 1) t k)

<span class="kw">let</span> of_gen gen = loop_cps gen 1 <span class="dt">Leaf</span> (<span class="kw">fun</span> x -&gt; x)</code></pre>
<p>Something interesting happens when doing defunctionalization. Currently, <code>fill</code> and <code>fill_right</code> are mutually recursive, and <code>loop</code> is defined separately afterwards. But when doing defunctionalization, I will represent all the lambda-abstractions of the module with a single type, and interpret them through a single function <code>run</code> which will be called whenever a continuation is invoked (you can think of <code>run</code> as an explicit marker for the application of a function, represented as first-order data, to its argument(s)).</p>
<p>This means that <code>loop</code>, where a continuation is applied in the <code>if finished then ...</code> branch, will need to call <code>run</code>, which will also be called from <code>still</code> and <code>still_right</code>. All four functions have to be defined as a single mutually recursive set of definitions. In other words, defunctionalization is <em>not</em> a modular transform, it must be defined at once as a "whole-program" transformation, operating on all functions sharing a common calling protocol.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> 'a kfill =
  | <span class="dt">Stop</span>
  | <span class="dt">Left</span> <span class="kw">of</span> 'a kfill * <span class="dt">int</span>
  | <span class="dt">Right</span> <span class="kw">of</span> 'a tree * 'a * 'a kfill
  | <span class="dt">Loop</span> <span class="kw">of</span> <span class="dt">int</span> * 'a kfill

<span class="kw">let</span> <span class="kw">rec</span> fill_cps_defun f n k = <span class="kw">match</span> n <span class="kw">with</span>
  | 0 -&gt; run f <span class="kw">false</span> <span class="dt">Leaf</span> k
  | _ -&gt; fill_cps_defun f (n - 1) (<span class="dt">Left</span> (k, n))
<span class="kw">and</span> fill_right_cps_defun f n left k =
  <span class="kw">match</span> (<span class="kw">try</span> <span class="dt">Some</span> (f ()) <span class="kw">with</span> <span class="dt">Exit</span> -&gt; <span class="dt">None</span>) <span class="kw">with</span>
    | <span class="dt">None</span> -&gt; run f <span class="kw">true</span> left k
    | <span class="dt">Some</span> x -&gt;
      fill_cps_defun f (n - 1) (<span class="dt">Right</span> (left, x, k))
<span class="kw">and</span> loop_cps_defun f n left k = fill_right_cps_defun f n left (<span class="dt">Loop</span> (n, k))
<span class="kw">and</span> run f finished t = <span class="kw">function</span>
  | <span class="dt">Stop</span> -&gt; t
  | <span class="dt">Left</span> (k, n) -&gt;
    <span class="kw">if</span> finished <span class="kw">then</span> run f finished t k
    <span class="kw">else</span> fill_right_cps_defun f n t k
  | <span class="dt">Right</span> (left, x, k) -&gt;
    run f finished (<span class="dt">Node</span> (left, x, t)) k
  | <span class="dt">Loop</span> (n, k) -&gt;
    <span class="kw">if</span> finished <span class="kw">then</span> run f finished t k
    <span class="kw">else</span> loop_cps_defun f (n + 1) t k

<span class="kw">let</span> of_gen gen = loop_cps_defun gen 1 <span class="dt">Leaf</span> <span class="dt">Stop</span></code></pre>
<p>From there, we will be able to derive our control-less conversion <code>of_iter</code>. There is a last sophistication: in the <code>to_gen</code> case, we only needed to call one function to get the next element, namely <code>iter</code>. Here, we must start by calling <code>loop</code> (to begin the construction of the tree), but the computation will need to be suspended after the next element is accessed (<code>try Some (f ()) ...</code>), and restart from there, where <code>fill</code> is called. So our mutable state will store not only the continuation argument to be passed to the next call, but also which function needs to be called next, <code>loop</code> or <code>fill</code>.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> 'a call1 =
  | <span class="dt">Call_loop</span> <span class="kw">of</span> <span class="dt">int</span> * 'a tree * 'a kfill
  | <span class="dt">Call_fill</span> <span class="kw">of</span> <span class="dt">int</span> * 'a kfill

<span class="kw">let</span> of_iter iter =
  <span class="kw">let</span> st = <span class="dt">ref</span> (<span class="dt">Call_loop</span> (1, <span class="dt">Leaf</span>, <span class="dt">Stop</span>)) <span class="kw">in</span>
  <span class="kw">let</span> result = <span class="dt">ref</span> <span class="dt">None</span> <span class="kw">in</span>
  <span class="kw">let</span> <span class="kw">rec</span> fill f n k = <span class="kw">match</span> n <span class="kw">with</span>
    | 0 -&gt; run f <span class="kw">false</span> <span class="dt">Leaf</span> k
    | _ -&gt; fill f (n - 1) (<span class="dt">Left</span> (k, n))
  <span class="kw">and</span> fill_right f n left k =
    <span class="kw">match</span> f <span class="kw">with</span>
      | <span class="dt">None</span> -&gt; run f <span class="kw">true</span> left k
      | <span class="dt">Some</span> x -&gt; st := <span class="dt">Call_fill</span> (n - 1, <span class="dt">Right</span> (left, x, k))
  <span class="kw">and</span> loop f n left k = fill_right f n left (<span class="dt">Loop</span> (n, k))
  <span class="kw">and</span> run f finished t = <span class="kw">function</span>
    | <span class="dt">Stop</span> -&gt; result := <span class="dt">Some</span> t
    | <span class="dt">Left</span> (k, n) -&gt;
      <span class="kw">if</span> finished <span class="kw">then</span> run f finished t k
      <span class="kw">else</span> fill_right f n t k
    | <span class="dt">Right</span> (left, x, k) -&gt;
      run f finished (<span class="dt">Node</span> (left, x, t)) k
    | <span class="dt">Loop</span> (n, k) -&gt;
      <span class="kw">if</span> finished <span class="kw">then</span> run f finished t k
      <span class="kw">else</span> loop f (n + 1) t k
  <span class="kw">in</span>
  <span class="kw">let</span> call x = <span class="kw">function</span>
    | <span class="dt">Call_loop</span> (n, t, k) -&gt; loop x n t k
    | <span class="dt">Call_fill</span> (n, k) -&gt; fill x n k
  <span class="kw">in</span>
  <span class="kw">let</span> add x = call (<span class="dt">Some</span> x) !st <span class="kw">in</span>
  iter add;
  call <span class="dt">None</span> !st;
  <span class="kw">match</span> !result <span class="kw">with</span>
    | <span class="dt">None</span> -&gt; <span class="kw">assert</span> <span class="kw">false</span>
    | <span class="dt">Some</span> res -&gt; res</code></pre>
<p>The amount of code may be a bit intimidating, but it is really only the previous version of the code, transformed to be called with a single element at a time (we still call it <code>f</code> to avoid naming conflict with already-used <code>x</code>), or <code>None</code> when the input ends. By careful transformations we have successfully turned a generator-taking function, that has control, into an iterator-taking function that doesn't have control.</p>
<p>There is a rather important amount of book-keeping involved in this turned-around definition, so it is no surprise that <code>of_iter</code> is substantially slower than <code>of_gen</code>. It seems clear to me, however, that both should be included in a library. Only providing the controlling <code>of_gen</code> means that the library user will have to code without control herself, leading to complicated code on her side (which is what your job, as a library writer, is meant to avoid), and less efficient code.</p>
<p>One way to improve performances for the without-control version would be to introduce buffering: instead of suspending computation after each element is obtained, we could run <code>fill</code> to consume the next <code>N</code> elements before the costly suspension happens.</p>
<p>This blog post is getting rather long so I'll keep this as a possible idea for the next, more advanced one. I'm not sure I will implement buffering, because I already have two more advanced remarks to make on the <code>fill</code> code and its CPS versions. One is how the intermediate CPS version suggests a different representation with multiple return points, and the other is how we can use GADTs to avoid the rather inelegant <code>None -&gt; assert false</code> at the end of <code>of_iter</code>. Stay tuned!</p>
<p>All the code I've written so far is available <a href="https://gitorious.org/gasche-snippets/iterators-and-generators/blobs/master/iter_or_gen.ml">on gitorious</a>. It uses DelimCC, <code>-rectypes</code> and OCaml 4.00 (for the GADTs I just mentioned), but all these can be commented out, and the main body of the code is rather straightforward OCaml that I expect to compile and run anywhere.</p>
<p>Finally, if you are looking for research literature relevant to the techniques mentioned here, <a href="http://www.cs.au.dk/~danvy/index-previous.html">Olivier Danvy</a> is the established master of systematic source-to-source transformations. He famously remarked, for example, how CPS-transforming then defunctionalizing a natural interpreter for a functional language gets you a corresponding <em>abstract machine</em> implementation of the language.</p>
<p>On defunctionalization in particular, I really like a 2006 article by François Pottier and Nadji Gauthier <a href="http://gallium.inria.fr/~fpottier/publis/fpottier-gauthier-hosc.pdf">Polymorphic typed defunctionalization and concretization</a>. I'll just quote the abstract below:</p>
<blockquote>
<p>Defunctionalization is a program transformation that eliminates functions as first-class values. We show that defunctionalization can be viewed as a type-preserving transformation of an extension of with guarded algebraic data types into itself. We also suggest that defunctionalization is an instance of concretization, a more general technique that allows eliminating constructs other than functions. We illustrate this point by presenting two new type-preserving transformations that can be viewed as instances of concretization. One eliminates Rémy-style polymorphic records; the other eliminates the dictionary records introduced by the standard compilation scheme for Haskell's type classes.</p>
</blockquote><a onclick="switchContent('post6','post5')" class="btn" href="#38faea8ab2754bc8157a129078b7bb44">Hide</a></div></span>
<a name="e024e9deb17e38571238cfbb700ef298"></a><span class="rss-header"><span class="rss-title"><a href="https://forge.ocamlcore.org/forum/forum.php?forum_id=870"> Release of OCaml-bitcoin 1.1</a></span>&nbsp;&mdash;&nbsp;<span class="rss-author">OCamlCore Forge News</span>, <span class="rss-date">01 Mar 2013</span></span><span class="rss-description"><pre class="rss-text">This release brings the OCaml-bitcoin API up-to-date with the recently released Bitcoin 0.8.</pre></span>
<script type="text/javascript">function switchContent(id1,id2) {
     // Get the DOM reference
     var contentId1 = document.getElementById(id1);
     var contentId2 = document.getElementById(id2);
     // Toggle
     contentId1.style.display = "none";
     contentId2.style.display = "block";
     }</script></div>

  
    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>

    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-37808023-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

    </script>

</body></html>
