<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: If Statements, Loops and Recursion</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contributors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="If Statements, Loops and Recursion" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it Online</a></li>
    <li><a href="../taste.html">100 Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who Is Using It?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a>
        <a href="http://langref.org/ocaml">langref.org</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
    <li><a href="../papers.html">Papers</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../releases/latest.html">Releases</a></li>
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development Tools</a></li>
    <li><a href="../books.html#manual">User Manual</a></li>
    <li><a href="../cheat_sheets.html">Cheat Sheets</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API Search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">GitHub</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing Lists</a></li>
    <li><a href="../planet/">Blogs</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span><a href="./">Tutorials</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>If Statements, Loops and Recursion
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

<h1><span>If Statements, Loops and Recursion</span></h1>

<h2><a name="If_statements__actually_these_are_if_expressions_"></a>
  If statements (actually these are if expressions)</h2>
<p>OCaml has an if statement with two variations, and the obvious meaning:</p>
<pre><span class="listing"><span class="kwb">if</span> boolean-condition <span class="kwb">then</span> expression</span></pre>

<pre><span class="listing"><span class="kwb">if</span> boolean-condition <span class="kwb">then</span> expression <span class="kwb">else</span> other-expression</span></pre>

<p>Unlike in the conventional languages you'll be used to, if statements are really expressions. In other words, they're much more like <code><em>boolean-condition</em> ? <em>expression</em> : <em>other-expression</em></code> than like the if statements you may be used to.</p>
<p>Here's a simple example of an <code>if</code> statement:</p>
<pre><span class="listing"><span class="kwa">let</span> <span class="ocaml-function">max</span> <span class="ocaml-variable">a b </span>=
  <span class="kwb">if</span> a &gt; b <span class="kwb">then</span> a <span class="kwb">else</span> b</span></pre>

<p>As a short aside, if you type this into the OCaml toplevel, you'll notice that OCaml decides that this function is polymorphic, with the following type:</p>
<pre>
max : 'a -&gt; 'a -&gt; 'a
</pre>

<p>And indeed OCaml lets you use <code>max</code> on any type:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">max 3 5</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int = 5
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">max 3.5 13.0</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : float = 13.
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">max &quot;a&quot; &quot;b&quot;</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : string = &quot;b&quot;
</span></pre>

<p>This is because <code>&gt;</code> is in fact polymorphic. It works on any type, even objects (it does a binary comparison).</p>
<p>[Note that the <code>Pervasives</code> module defines <code>min</code> and <code>max</code> for you.]</p>
<p>Let's look a bit more closely at the <code>if</code> expression. Here's the <code>range</code> function which I showed you earlier without much explanation. You should be able to combine your knowledge of recursive functions, lists and if expressions to see what it does:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
    <span class="kwb">if</span> a > b <span class="kwb">then</span> []
    <span class="kwb">else</span> a :: range (a+1) b</span><span class="ocamltop-prompt">;;</span></pre>

<p>Let's examine some typical calls to this function. Let's start with the easy case of <code>a &gt; b</code>. A call to <code>range 11 10</code> returns <code>[]</code> (the empty list) and that's it.</p>
<p>What about calling <code>range 10 10</code>? Since <code>10 &gt; 10</code> is false, the <code>else</code>-clause is evaluated, which is: <code>10 :: (range 11 10)</code> (I've added the brackets to make the order of evaluation more clear). We've just worked out that <code>range 11 10</code> = <code>[]</code>, so this is: <code>10 :: []</code>. Remember our formal description of lists and the <code>::</code> (cons) operator? <code>10 :: []</code> is just the same as <code>[ 10 ]</code>.</p>
<p>Let's try <code>range 9 10</code>:</p>
<pre><span class="listing">range 9 10
&rarr; 9 :: (range 10 10)
&rarr; 9 :: [ 10 ]
&rarr; [9; 10]</span></pre>

<p>It should be fairly clear that <code>range 1 10</code> evaluates to <code>[ 1; 2; 3; 4; 5; 6; 7; 8; 9; 10 ]</code>.</p>
<p>What we've got here is a simple case of recursion. Functional programming can be said to prefer recursion over loops, but I'm jumping ahead of myself. We'll discuss recursion more at the end of this chapter.</p>
<p>Back, temporarily, to if statements. What does this function do?</p>
<pre><span class="listing"><span class="kwa">let</span> <span class="ocaml-function">f</span> <span class="ocaml-variable">x y </span>=
  x + <span class="kwb">if</span> y &gt; 0 <span class="kwb">then</span> y <span class="kwb">else</span> 0</span></pre>

<p>Clue: add brackets around the whole of the if expression. It clips <code>y</code> like an <a title="http://www.noir-medical.com/graphics/diode_graph.gif" class="external" href="http://www.noir-medical.com/graphics/diode_graph.gif">electronic diode</a>.</p>
<p>The <code>abs</code> (absolute value) function is defined in <code>Pervasives</code> as:</p>
<pre><span class="listing"><span class="kwa">let</span> <span class="ocaml-function">abs</span> <span class="ocaml-variable">x </span>=
  <span class="kwb">if</span> x &gt;= 0 <span class="kwb">then</span> x <span class="kwb">else</span> -x</span></pre>

<p>Also in <code>Pervasives</code>, the <code>string_of_float</code> function contains a complex pair of nested if expressions:</p>
<pre><span class="listing"><span class="kwa">let</span> <span class="ocaml-function">string_of_float</span> <span class="ocaml-variable">f </span>=
  <span class="kwa">let </span><span class="ocaml-variable">s</span> = format_float &quot;%.12g&quot; f <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">l</span> = string_length s <span class="kwa">in</span>
  <span class="kwa">let rec</span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">i </span>=
    <span class="kwb">if</span> i &gt;= l <span class="kwb">then</span> s ^ &quot;.&quot;
    <span class="kwb">else</span> <span class="kwb">if</span> s.[i] = '.' || s.[i] = 'e' <span class="kwb">then</span> s
    <span class="kwb">else</span> loop (i+1) <span class="kwa">in</span>
  loop 0</span></pre>

<p>Let's examine this function. Suppose the function is called with <code>f</code> = 12.34. Then <code>s</code> = &quot;12.34&quot;, and <code>l</code> = 5. We call <code>loop</code> the first time with <code>i</code> = 0.</p>
<p><code>i</code> is not greater than or equal to <code>l</code>, and <code>s.[i]</code> (the <code>i</code><sup>th</sup> character in <code>s</code>) is not a period or <code>'e'</code>. So <code>loop (i+1)</code> is called, ie. <code>loop 1</code>.</p>
<p>We go through the same dance for <code>i</code> = 1, and end up calling <code>loop 2</code>.</p>
<p>For <code>i</code> = 2, however, <code>s.[i]</code> is a period (refer to the original string, <code>s</code> = &quot;12.34&quot;).  So this immediately returns <code>s</code>, and the function <code>string_of_float</code> returns &quot;12.34&quot;.</p>
<p>What is <code>loop</code> doing? In fact it's checking whether the string returned from <code>format_float</code> contains a period (or <code>'e'</code>). Suppose that we called <code>string_of_float</code> with <code>12.0</code>.  <code>format_float</code> would return the string &quot;12&quot;, but <code>string_of_float</code> must return &quot;12.&quot; or &quot;12.0&quot; (because floating point constants in OCaml must contain a period to differentiate them from integer constants). Hence the check.</p>
<p>The strange use of recursion in this function is almost certainly for efficiency. OCaml supports for loops, so why didn't the authors use for loops? We'll see in the next section that OCaml's for loops are limited in a way which prevents them from being used in <code>string_of_float</code>. Here, however, is a more straightforward, but approximately twice as slow, way of writing <code>string_of_float</code>:</p>
<pre><span class="listing"><span class="kwa">let</span> <span class="ocaml-function">string_of_float</span> <span class="ocaml-variable">f </span>=
  <span class="kwa">let </span><span class="ocaml-variable">s</span> = format_float &quot;%.12g&quot; f <span class="kwa">in</span>
  <span class="kwb">if</span> <span class="ocaml-mod">String</span>.contains s '.' || <span class="ocaml-mod">String</span>.contains s 'e'
  <span class="kwb">then</span> s
  <span class="kwb">else</span> s ^ &quot;.&quot;</span></pre>

<a name="Using_begin_____end"></a><h2><span>Using begin ... end</span></h2>
<p>Here is some code from lablgtk:</p>
<pre><span class="listing"><span class="kwb">if</span> <span class="ocaml-mod">GtkBase</span>.<span class="ocaml-mod">Object</span>.is_a obj cls <span class="kwb">then</span>
  <span class="kwb">fun</span> _ -&gt; f obj
<span class="kwb">else</span> <span class="kwa">begin</span>
  eprintf &quot;Glade-warning: %s expects a %s argument.\n&quot; name cls;
  <span class="kwb">raise</span> Not_found
<span class="kwa">end</span></span></pre>

<p><code>begin</code> and <code>end</code> are what is known as <strong>syntactic sugar</strong> for open and close parentheses. In the example above, all they do is group the two statements in the <code>else</code>-clause together. Suppose the author had written this instead:</p>
<pre><span class="listing"><span class="kwb">if</span> <span class="ocaml-mod">GtkBase</span>.<span class="ocaml-mod">Object</span>.is_a obj cls <span class="kwb">then</span>
  <span class="kwb">fun</span> _ -&gt; f obj
<span class="kwb">else</span>
  eprintf &quot;Glade-warning: %s expects a %s argument.\n&quot; name cls;
  <span class="kwb">raise</span> Not_found</span></pre>

<p>Fully bracketing and properly indenting the above expression gives:</p>
<pre><span class="listing">(<span class="kwb">if</span> <span class="ocaml-mod">GtkBase</span>.<span class="ocaml-mod">Object</span>.is_a obj cls <span class="kwb">then</span>
   <span class="kwb">fun</span> _ -&gt; f obj
 <span class="kwb">else</span>
   eprintf &quot;Glade-warning: %s expects a %s argument.\n&quot; name cls
);
<span class="kwb">raise</span> Not_found</span></pre>

<p>Not what was intended at all. So the <code>begin</code> and <code>end</code> are necessary to group together multiple statements in a <code>then</code> or <code>else</code> clause of an if expression. You can also use plain ordinary parentheses <code>( ... )</code> if you prefer (and I do prefer, because I <strong>loathe</strong> Pascal :-). Here are two simple examples:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwb">if</span> 1 = 0 <span class="kwb">then</span>
    print_endline &quot;THEN&quot;
  <span class="kwb">else</span> <span class="kwa">begin</span>
    print_endline &quot;ELSE&quot;;
    <span class="kwb">failwith</span> &quot;<span class="kwb">else</span> clause&quot;
  <span class="kwa">end</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout">ELSE
</span><span class="ocamltop-stderr"></span>Exception: Failure &quot;else clause&quot;.
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwb">if</span> 1 = 0 <span class="kwb">then</span>
    print_endline &quot;THEN&quot;
  <span class="kwb">else</span> (
    print_endline &quot;ELSE&quot;;
    <span class="kwb">failwith</span> &quot;<span class="kwb">else</span> clause&quot;
  )</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout">ELSE
</span><span class="ocamltop-stderr"></span>Exception: Failure &quot;else clause&quot;.
</span></pre>

<a name="For_loops_and_while_loops"></a><h2><span>For loops and while loops</span></h2>
<p>OCaml supports a rather limited form of the familiar <code>for</code> loop:</p>
<pre><span class="listing"><span class="kwb">for</span> variable = start_value <span class="kwb">to</span> end_value <span class="kwb">do</span>
  expression
<span class="kwb">done</span>

<span class="kwb">for</span> variable = start_value <span class="kwb">downto</span> end_value <span class="kwb">do</span>
  expression
<span class="kwb">done</span></span></pre>

<p>A simple but real example from lablgtk:</p>
<pre><span class="listing"><span class="kwb">for</span> i = 1 <span class="kwb">to</span> n_jobs () <span class="kwb">do</span>
  do_next_job ()
<span class="kwb">done</span></span></pre>

<p>In OCaml, <code>for</code> loops are just shorthand for writing:</p>
<pre><span class="listing"><span class="kwa">let </span><span class="ocaml-variable">i</span> = 1 <span class="kwa">in</span>
do_next_job ();
<span class="kwa">let </span><span class="ocaml-variable">i</span> = 2 <span class="kwa">in</span>
do_next_job ();
<span class="kwa">let </span><span class="ocaml-variable">i</span> = 3 <span class="kwa">in</span>
do_next_job ();
  ...
<span class="kwa">let </span><span class="ocaml-variable">i</span> = n_jobs () <span class="kwa">in</span>
do_next_job ();
()</span></pre>

<p>OCaml doesn't support the concept of breaking out of a <code>for</code> loop early - i.e. it has no <code>break</code>, <code>continue</code> or <code>last</code> statements. (You <em>could</em> throw an exception and catch it outside, and this would run fast but often looks clumsy.)  </p>
<p>The expression inside an OCaml for loop should evaluate to <code>unit</code> (otherwise you'll get a warning), and the for loop expression as a whole returns <code>unit</code>:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwb">for</span> i = 1 <span class="kwb">to</span> 10 <span class="kwb">do</span> i <span class="kwb">done</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr">File &quot;&quot;, line 1, characters 19-20:
Warning 10: this expression should have type unit.
</span>- : unit = ()
</span></pre>

<p>Functional programmers tend to use recursion instead of explicit loops, and regard <strong>for</strong> loops with suspicion since it can't return anything, hence OCaml's relatively powerless <strong>for</strong> loop.  We talk about recursion below.</p>
<p><strong>While loops</strong> in OCaml are written:</p>
<pre><span class="listing"><span class="kwb">while</span> boolean-condition <span class="kwb">do</span>
  expression
<span class="kwb">done</span></span></pre>

<p>As with for loops, there is no way provided by the language to break out of a while loop, except by throwing an exception, and this means that while loops have fairly limited use. Again, remember that functional programmers like recursion, and so while loops are second-class citizens in the language.</p>
<p>If you stop to consider while loops, you may see that they aren't really any use at all, except in conjunction with our old friend references. Let's imagine that OCaml didn't have references for a moment:</p>
<pre><span class="listing"><span class="kwa">let </span><span class="ocaml-variable">quit_loop</span> = false <span class="kwa">in</span>
<span class="kwb">while</span> not quit_loop <span class="kwb">do</span>
  print_string &quot;Have you had enough yet? (y/n) &quot;;
  <span class="kwa">let </span><span class="ocaml-variable">str</span> = read_line () <span class="kwa">in</span>
  <span class="kwb">if</span> str.[0] = 'y' <span class="kwb">then</span>
    <span class="ocaml-comment">(* how <span class="kwb">do</span> I set quit_loop <span class="kwb">to</span> true ?!? *)</span>
<span class="kwb">done</span></span></pre>

<p>Remember that <code>quit_loop</code> is not a real &quot;variable&quot; - the let-binding just makes <code>quit_loop</code> a shorthand for <code>false</code>. This means the while loop condition (shown in red) is always true, and the loop runs on forever!</p>
<p>Luckily OCaml <em>does have</em> references, so we can write the code above if we want. Don't get confused and think that the <code>!</code> (exclamation mark) means &quot;not&quot; as in C/Java. It's used here to mean &quot;dereference the pointer&quot;, similar in fact to Forth. You're better off reading <code>!</code> as &quot;get&quot; or &quot;deref&quot;.</p>
<pre><span class="listing"><span class="kwa">let </span><span class="ocaml-variable">quit_loop</span> = <span class="kwb">ref</span> false <span class="kwa">in</span>
<span class="kwb">while</span> not !quit_loop <span class="kwb">do</span>
  print_string &quot;Have you had enough yet? (y/n) &quot;;
  <span class="kwa">let </span><span class="ocaml-variable">str</span> = read_line () <span class="kwa">in</span>
  <span class="kwb">if</span> str.[0] = 'y' <span class="kwb">then</span>
    quit_loop := true
<span class="kwb">done</span>;;</span></pre>

<a name="Looping_over_lists"></a><h2><span>Looping over lists</span></h2>
<p>If you want to loop over a list, don't be an imperative programmer and reach for your trusty six-shooter Mr. For Loop! OCaml has some better and faster ways to loop over lists, and they are all located in the <code>List</code> module. There are in fact dozens of good functions in <code>List</code>, but I'll only talk about the most useful ones here.</p>
<p>First off, let's define a list for us to use:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">my_list</span> = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val my_list : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
</span></pre>

<p>If you want to call a function once on every element of the list, use <code>List.iter</code>, like this:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">f</span> <span class="ocaml-variable">elem </span>=
    <span class="ocaml-mod">Printf</span>.printf &quot;I'm looking at element %d now\n&quot; elem <span class="kwa">in</span>
  <span class="ocaml-mod">List</span>.iter f my_list</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout">I'm looking at element 1 now
I'm looking at element 2 now
I'm looking at element 3 now
I'm looking at element 4 now
I'm looking at element 5 now
I'm looking at element 6 now
I'm looking at element 7 now
I'm looking at element 8 now
I'm looking at element 9 now
I'm looking at element 10 now
</span><span class="ocamltop-stderr"></span>- : unit = ()
</span></pre>

<p><code>List.iter</code> is in fact what you should think about using first every time your cerebellum suggests you use a for loop.</p>
<p>If you want to <em>transform</em> each element separately in the list - for example, doubling each element in the list - then use <code>List.map</code>. This function will be familiar to people who've</p>
<p>programmed in Perl before.</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">List</span>.map (( * ) 2) my_list</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int list = [2; 4; 6; 8; 10; 12; 14; 16; 18; 20]
</span></pre>

<p>Perl has the useful function &quot;grep&quot; for filtering only elements of a list which satisfy some condition - eg. returning all even numbers in a list. In OCaml this function is called <code>List.filter</code>:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">is_even</span> <span class="ocaml-variable">i </span>=
    i mod 2 = 0 <span class="kwa">in</span>
  <span class="ocaml-mod">List</span>.filter is_even my_list</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int list = [2; 4; 6; 8; 10]
</span></pre>

<p>To find out if a list contains some element, use <code>List.mem</code> (short for member):</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">List</span>.mem 12 my_list</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : bool = false
</span></pre>

<p><code>List.for_all</code> and <code>List.exists</code> are the same as the &quot;forall&quot; and &quot;exist&quot; operators in predicate logic.</p>
<p>For operating over two lists at the same time, there are &quot;-2&quot; variants of some of these functions, namely <code>iter2</code>, <code>map2</code>, <code>for_all2</code>, <code>exists2</code>.</p>
<p>The <code>map</code> and <code>filter</code> functions operate on individual list elements in isolation. &lt;dfn&gt;Fold&lt;/dfn&gt; is a more unusual operation that is best thought about as &quot;inserting an operator between each element of the list&quot;. Suppose I wanted to add all the numbers in my list together. In hand-waving terms what I want to do is insert a plus sign between the elements in my list:</p>
<pre><span class="listing">1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10</span></pre>

<p>The fold operation does this, although the exact details are  a little bit more tricky. First of all, what happens if I try to fold an empty list? In the case of summing the list it would be nice if the answer was zero, instead of error. However if I was trying to find the product of the list, I'd like the answer to be one instead. So I obviously have to provide some sort of &quot;default&quot; argument to my fold. The second issue doesn't arise with simple operators like <code>+</code> and <code>*</code>: what happens if the operator I'm using isn't associative, ie. (a <em>op</em> b) <em>op</em> c not equal to a <em>op</em> (b <em>op</em> c)? In that case it would matter if I started from the left hand end of the list and worked right, versus if I started from the right and worked left. For this reason there are two versions of fold, called <code>List.fold_left</code> (works left to right) and <code>List.fold_right</code> (works right to left, and is also less efficient).</p>
<p>Let's use <code>List.fold_left</code> to define <code>sum</code> and <code>product</code> functions for integer lists:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">sum</span> = <span class="ocaml-mod">List</span>.fold_left ( + ) 0</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val sum : int list -&gt; int = &lt;fun&gt;
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">product</span> = <span class="ocaml-mod">List</span>.fold_left ( * ) 1</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val product : int list -&gt; int = &lt;fun&gt;
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">sum my_list</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int = 55
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">product my_list</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int = 3628800
</span></pre>

<p>That was easy! Notice that I've accidentally come up with a way to do mathematical factorials:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">fact</span> <span class="ocaml-variable">n </span>= product (range 1 n)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val fact : int -&gt; int = &lt;fun&gt;
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">fact 10</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int = 3628800
</span></pre>

<p>(Notice that this factorial function isn't very useful because it overflows the integers and gives wrong answers even for quite small values of <code>n</code>. A real factorial function would use the <code>Big_int</code> module.)</p>

<a name="Looping_over_strings"></a><h2><span>Looping over strings</span></h2>
<p>The <code>String</code> module also contains many dozens of useful string-related functions, and some of them are concerned with looping over strings.</p>
<p><code>String.fill</code> and <code>String.blit</code> are the equivalents to C <code>memset</code> and <code>strcpy</code> respectively. <code>String.copy</code> copies a string, like <code>strdup</code>.</p>
<p>There is also a <code>String.iter</code> function which works like <code>List.iter</code>, except over the characters of the string.</p>

<a name="Recursion"></a><h2><span>Recursion</span></h2>
<p>Now we come to a hard topic - recursion. Functional programmers are defined by their love of recursive functions, and in many ways recursive functions in f.p. are the equivalent of loops in imperative programming. In functional languages loops are second-class citizens, whilest recursive functions get all the best support.</p>
<p>Writing recursive functions requires a change in mindset from writing for loops and while loops. So what I'll give you in this section will be just an introduction and examples.</p>
<p>In the first example we're going to read the whole of a file into memory (into a long string). There are essentially three possible approaches to this:</p>

<h3>Approach 1</h3>
<p>Get the length of the file, and read it all in one go using the <code>really_input</code> method. This is the simplest, but it might not work on channels which are not really files (eg.  reading keyboard input) which is why we look at the other two approaches.</p>

<h3>Approach 2</h3>
<p>The imperative approach, using a while loop which is broken out of using an exception.</p>

<h3>Approach 3</h3>
<p>A recursive loop, breaking out of the recursion again using an exception.</p>
<p>-----</p>
<p>We're going to introduce a few new concepts here. Our second two approaches will use the <code>Buffer</code> module - an expandable buffer which you can think of like a string onto which you can efficiently append more text at the end. We're also going to be catching the <code>End_of_file</code> exception which the input functions throw when they reach the end of the input. Also we're going to use <code>Sys.argv.(1)</code> to get the first command line parameter.</p>
<pre><span class="listing"><span class="ocaml-comment">(* Read whole file: Approach 1 *)</span>

<span class="kwa">let</span> <span class="ocaml-function">read_whole_chan</span> <span class="ocaml-variable">chan </span>=
  <span class="kwa">let </span><span class="ocaml-variable">len</span> = in_channel_length chan <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">result</span> = <span class="ocaml-mod">String</span>.create len <span class="kwa">in</span>
  really_input chan result 0 len;
  result

<span class="kwa">let</span> <span class="ocaml-function">read_whole_file</span> <span class="ocaml-variable">filename </span>=
  <span class="kwa">let </span><span class="ocaml-variable">chan</span> = open_in filename <span class="kwa">in</span>
  read_whole_chan chan

<span class="kwa">let</span> () =
  <span class="kwa">let </span><span class="ocaml-variable">filename</span> = <span class="ocaml-mod">Sys</span>.argv.(1) <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">str</span> = read_whole_file filename <span class="kwa">in</span>
  <span class="ocaml-mod">Printf</span>.printf &quot;I read %d characters from %s\n&quot; (<span class="ocaml-mod">String</span>.length str) filename</span></pre>

<p>Approach 1 works but is not very satisfactory because <code>read_whole_chan</code> won't work on non-file channels like keyboard input or sockets. Approach 2 involves a while loop:</p>
<pre><span class="listing"><span class="ocaml-comment">(* Read whole file: Approach 2 *)</span>

<span class="kwa">let</span> <span class="ocaml-function">read_whole_chan</span> <span class="ocaml-variable">chan </span>=
  <span class="kwa">let </span><span class="ocaml-variable">buf</span> = <span class="ocaml-mod">Buffer</span>.create 4096 <span class="kwa">in</span>
  <span class="kwb">try</span>
    <span class="kwb">while</span> true <span class="kwb">do</span>
      <span class="kwa">let </span><span class="ocaml-variable">line</span> = input_line chan <span class="kwa">in</span>
      <span class="ocaml-mod">Buffer</span>.add_string buf line;
      <span class="ocaml-mod">Buffer</span>.add_char buf '\n'
    <span class="kwb">done</span>;
    <span class="kwb">assert</span> false <span class="ocaml-comment">(* This is never executed (always <span class="kwb">raise</span> Assert_failure). *)</span>
  <span class="kwb">with</span>
    End_of_file -&gt; <span class="ocaml-mod">Buffer</span>.contents buf

<span class="kwa">let</span> <span class="ocaml-function">read_whole_file</span> <span class="ocaml-variable">filename </span>=
  <span class="kwa">let </span><span class="ocaml-variable">chan</span> = open_in filename <span class="kwa">in</span>
  read_whole_chan chan

<span class="kwa">let</span> () =
  <span class="kwa">let </span><span class="ocaml-variable">filename</span> = <span class="ocaml-mod">Sys</span>.argv.(1) <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">str</span> = read_whole_file filename <span class="kwa">in</span>
  <span class="ocaml-mod">Printf</span>.printf &quot;I read %d characters from %s\n&quot; (<span class="ocaml-mod">String</span>.length str) filename</span></pre>

<p>The key to approach 2 is to look at the central while loop. Remember that I said the only way to break out of a while loop early was with an exception? This is exactly what we're doing here. Although I haven't covered exceptions yet, you probably won't have any trouble understanding the <code>End_of_file</code> exception thrown in the code above by <code>input_line</code> when it hits the end of the file. The buffer <code>buf</code> accumulates the contents of the file, and when we hit the end of the file we return it (<code>Buffer.contents buf</code>).</p>
<p>One curious point about this is the apparently superfluous extra set of quotes (<code>&quot;&quot;</code>) just after the while loop. What are they for? Remember that while loops, like for loops, are just expressions, and they return the <code>unit</code> object (<code>()</code>). However OCaml demands that the return type inside a <code>try</code> matches the return type of each caught exception. In this case because <code>End_of_file</code> results in a <code>string</code>, the main body of the <code>try</code> must also &quot;return&quot; a string - even though because of the infinite while loop the string could never actually be returned.</p>
<p>Here's our recursive version. Notice that it's <em>shorter</em> than approach 2, but not so easy to understand for imperative programmers at least:</p>
<pre><span class="listing"><span class="ocaml-comment">(* Read whole file: Approach 3 *)</span>

<span class="kwa">let</span> <span class="ocaml-function">read_whole_chan</span> <span class="ocaml-variable">chan </span>=
  <span class="kwa">let </span><span class="ocaml-variable">buf</span> = <span class="ocaml-mod">Buffer</span>.create 4096 <span class="kwa">in</span>
  <span class="kwa">let rec</span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
    <span class="kwa">let </span><span class="ocaml-variable">line</span> = input_line chan <span class="kwa">in</span>
    <span class="ocaml-mod">Buffer</span>.add_string buf line;
    <span class="ocaml-mod">Buffer</span>.add_char buf '\n';
    loop () <span class="kwa">in</span>
  <span class="kwb">try</span>
    loop ()
  <span class="kwb">with</span>
    End_of_file -&gt; <span class="ocaml-mod">Buffer</span>.contents buf

<span class="kwa">let</span> <span class="ocaml-function">read_whole_file</span> <span class="ocaml-variable">filename </span>=
  <span class="kwa">let </span><span class="ocaml-variable">chan</span> = open_in filename <span class="kwa">in</span>
  read_whole_chan chan

<span class="kwa">let</span> () =
  <span class="kwa">let </span><span class="ocaml-variable">filename</span> = <span class="ocaml-mod">Sys</span>.argv.(1) <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">str</span> = read_whole_file filename <span class="kwa">in</span>
  <span class="ocaml-mod">Printf</span>.printf &quot;I read %d characters from %s\n&quot; (<span class="ocaml-mod">String</span>.length str) filename</span></pre>

<p>Again we have an infinite loop - but in this case done using recursion. <code>loop</code> calls itself at the end of the function. The infinite recursion is broken when <code>input_line</code> throws an <code>End_of_file</code> exception.</p>
<p>It looks like approach 3 might overflow the stack if you gave it a particularly large file, but this is in fact not the case. Because of tail recursion (discussed below) the compiler will turn the recursive <code>loop</code> function into a real while loop (!) which runs in constant stack space.</p>
<p>In the next example we will show how recursion is great for constructing or examining certain types of data structures, particularly trees. Let's have a recursive type to represent files in a filesystem:</p>
<pre><span class="listing"><span class="kwa">type</span> <span class="ocaml-mod">filesystem</span> = File <span class="kwb">of</span> string | Directory <span class="kwb">of</span> filesystem list</span></pre>

<p>The <code>opendir</code> and <code>readdir</code> functions are used to open a directory and read elements from the directory. I'm going to define a handy <code>readdir_no_ex</code> function which hides the annoying <code>End_of_file</code> exception that <code>readdir</code> throws when it reaches the end of the directory:</p>
<pre><span class="listing"><span class="kwa">open</span> <span class="ocaml-mod">Unix</span>  <span class="ocaml-comment">(*  You may need <span class="kwb">to</span> #load &quot;<span class="ocaml-mod">Unix</span>.cma&quot; *)</span>

<span class="kwa">let</span> <span class="ocaml-function">readdir_no_ex</span> <span class="ocaml-variable">dirh </span>=
  <span class="kwb">try</span>
    Some (readdir dirh)
  <span class="kwb">with</span>
    End_of_file -&gt; None</span></pre>

<p>The type of <code>readdir_no_ex</code> is this. Recall our earlier discussion about null pointers.</p>
<pre><span class="listing">readdir_no_ex : dir_handle -&gt; string option</span></pre>

<p>I'm also going to define a simple recursive function which I can use to convert the <code>filesystem</code> type into a string for (eg) printing:</p>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">string_of_filesystem</span> <span class="ocaml-variable">fs </span>=
  <span class="kwb">match</span> fs <span class="kwb">with</span>
  | File filename -&gt; filename ^ &quot;\n&quot;
  | Directory fs_list -&gt;
      <span class="ocaml-mod">List</span>.fold_left (^) &quot;&quot; (<span class="ocaml-mod">List</span>.map string_of_filesystem fs_list)</span></pre>

<p>Note the use of <code>fold_left</code> and <code>map</code>. The <code>map</code> is used to (recursively) convert each <code>filesystem</code> in the list into a <code>string</code>. Then the <code>fold_left (^) &quot;&quot;</code> concatenates the list together into one big string. Notice also the use of pattern matching.  (The library defines a function called <code>String.concat</code> which is essentially equivalent to <code>fold_left (^) </code>, but implemented more efficiently).</p>
<p>Now let's define a function to read a directory structure, recursively, and return a recursive <code>filesystem</code> data structure. I'm going to show this function in steps, but I'll print out the entire function at the end of this section. First the outline of the function:</p>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">read_directory</span> <span class="ocaml-variable">path </span>=
  <span class="kwa">let </span><span class="ocaml-variable">dirh</span> = opendir path <span class="kwa">in</span>
  <span class="kwa">let rec</span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
    <span class="ocaml-comment">(* ..... *)</span> <span class="kwa">in</span>
  Directory (loop ())</span></pre>

<p>The call to <code>opendir</code> opens up the given path and returns a <code>dir_handle</code> from which we will be able to read the names using <code>readdir_no_ex</code> later. The return value of the function is going to be a <code>Directory <em>fs_list</em></code>, so all we need to do to complete the function is to write our function <code>loop</code> which returns a list of <code>filesystem</code>s. The type of <code>loop</code> will be:</p>
<pre><span class="listing">loop : unit -&gt; filesystem list</span></pre>

<p>How do we define loop? Let's take it in steps again.</p>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
  <span class="kwa">let </span><span class="ocaml-variable">filename</span> = readdir_no_ex dirh <span class="kwa">in</span>
  <span class="ocaml-comment">(* ..... *)</span></span></pre>

<p>First we read the next filename from the directory handle. <code>filename</code> has type <code>string option</code>, in other words it could be <code>None</code> or <code>Some &quot;foo&quot;</code> where <code>foo</code> is the name of the next filename in the directory. We also need to ignore the <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> files (ie. the current directory and the parent directory). We can do all this with a nice pattern match:</p>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
  <span class="kwa">let </span><span class="ocaml-variable">filename</span> = readdir_no_ex dirh <span class="kwa">in</span>
  <span class="kwb">match</span> filename <span class="kwb">with</span>
  | None -&gt; []
  | Some &quot;.&quot; -&gt; loop ()
  | Some &quot;..&quot; -&gt; loop ()
  | Some filename -&gt;
     <span class="ocaml-comment">(* ..... *)</span></span></pre>

<p>The <code>None</code> case is easy. Thinking recursively (!)  if <code>loop</code> is called and we've reached the end of the directory, <code>loop</code> needs to return a list of entries - and there's no entries - so it returns the empty list (<code>[]</code>).</p>
<p>For <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> we just ignore the file and call <code>loop</code> again.</p>
<p>What do we do when <code>loop</code> reads a real filename (the <code>Some filename</code> match below)? Let <code>pathname</code> be the full path to the file.  We 'stat' the file to see if it's really a directory.  If it <em>is</em> a directory, we set <code>this</code> by recursively calling <code>read_directory</code> which will return <code>Directory <em>something</em></code>. Notice that the overall result of <code>read_directory</code> is <code>Directory (loop ())</code>. If the file is really a file (not a directory) then we let <code>this</code> be <code>File pathname</code>. Then we do something clever: we return <code>this :: loop ()</code>. This is the recursive call to <code>loop ()</code> to calculate the remaining directory members (a list), to which we prepend <code>this</code>.</p>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">read_directory</span> <span class="ocaml-variable">path </span>=
  <span class="kwa">let </span><span class="ocaml-variable">dirh</span> = opendir path <span class="kwa">in</span>
  <span class="kwa">let rec</span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
    <span class="kwa">let </span><span class="ocaml-variable">filename</span> = readdir_no_ex dirh <span class="kwa">in</span>
    <span class="kwb">match</span> filename <span class="kwb">with</span>
    | None -&gt; []
    | Some &quot;.&quot; -&gt; loop ()
    | Some &quot;..&quot; -&gt; loop ()
    | Some filename -&gt;
        <span class="kwa">let </span><span class="ocaml-variable">pathname</span> = path ^ &quot;/&quot; ^ filename <span class="kwa">in</span>
        <span class="kwa">let </span><span class="ocaml-variable">stat</span> = lstat pathname <span class="kwa">in</span>
        <span class="kwa">let </span><span class="ocaml-variable">this</span> = <span class="kwb">if</span> stat.st_kind = S_DIR <span class="kwb">then</span>
                     read_directory pathname
                   <span class="kwb">else</span>
                     File pathname <span class="kwa">in</span>
        this :: loop () <span class="kwa">in</span>
  Directory (loop ())</span></pre>

<p>That's quite a complex bit of recursion, but although this is a made-up example, it's fairly typical of the complex patterns of recursion found in real-world functional programs. The two important lessons to take away from this are:</p>
<ul><li>The use of recursion to build a list:</li></ul>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
  a <span class="kwb">match</span> or <span class="kwb">if</span> statement
  | base case -&gt; []
  | recursive case -&gt; element :: loop ()</span></pre>

<p>Compare this to our previous <code>range</code> function. The pattern of recursion is exactly the same:</p>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
  <span class="kwb">if</span> a &gt; b <span class="kwb">then</span> []            <span class="ocaml-comment">(* Base case *)</span>
  <span class="kwb">else</span> a :: range (a+1) b     <span class="ocaml-comment">(* Recursive case *)</span>
  ;;</span></pre>

<ul><li>The use of recursion to build up trees:</li></ul>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">read_directory</span> <span class="ocaml-variable">path </span>=
  <span class="ocaml-comment">(* blah blah *)</span>
  <span class="kwb">if</span> file-is-a-directory <span class="kwb">then</span>
    read_directory path-<span class="kwb">to</span>-file
  <span class="kwb">else</span>
    Leaf file</span></pre>

<p>All that remains now to make this a working program is a little bit of code to call <code>read_directory</code> and display the result:</p>
<pre><span class="listing"><span class="kwa">let </span><span class="ocaml-variable">path</span> = <span class="ocaml-mod">Sys</span>.argv.(1) <span class="kwa">in</span>
<span class="kwa">let </span><span class="ocaml-variable">fs</span> = read_directory path <span class="kwa">in</span>
print_endline (string_of_filesystem fs)</span></pre>

<h3>Addendum</h3>
<p>After I posted this example to the caml-list mailing list I received many follow-ups. (You can <a title="http://caml.inria.fr/pub/ml-archives/caml-list/2003/06/2732fbf1bed1ae50fefb6ea410ea9955.en.html" class="external" href="http://caml.inria.fr/pub/ml-archives/caml-list/2003/06/2732fbf1bed1ae50fefb6ea410ea9955.en.html">read the full thread</a>.)</p>
<p>First of all there is a basic fault with <code>read_directory</code> directory which will cause it to fail if you try to run it on very large directory structures. I don't explicitly call <code>closedir</code> to close the directory handle. The garbage collector doesn't help, because in OCaml the garbage collector does <strong>not</strong> collect and close open file and directory handles.</p>
<p>The fix is pretty trivial: add a call to <code>closedir</code> at the end of the <code>read_directory</code> function:</p>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">read_directory</span> <span class="ocaml-variable">path </span>=
  <span class="kwa">let </span><span class="ocaml-variable">dirh</span> = opendir path <span class="kwa">in</span>
    <span class="ocaml-comment">(* ... *)</span>
  <span class="kwa">let </span><span class="ocaml-variable">result</span> = Directory (loop ()) <span class="kwa">in</span>
  closedir dirh;
  result</span></pre>

<p>Next up is the issue of <code>readdir</code> throwing an exception in a rather &quot;unexceptional&quot; situation, namely <code>End_of_file</code>. I don't agree that throwing an exception in this case is the right thing to do. In typical programs I want to never have to write a <code>try ... with</code> clause, because exceptions are supposed to mean &quot;something really bad happened which I'm not prepared to deal with&quot;, like running out of disk space or memory. Throwing an exception as part of the routine running of a function (every program which uses <code>readdir</code> <em>has</em> to be prepared to handle <code>End_of_file</code>), that's not an exceptional situation.</p>
<p>However, Eric Cooper came up with a way to write the function and check the exception, and this highlights another frequent technique used by functional programmers. Namely, passing an <strong>accumulator</strong> which contains the result of the function call, but passed as an <em>argument</em> to the function (!) Really the accumulator means &quot;this is the result so far&quot;, so in the exceptional case (<code>End_of_file</code>) we give up and return the result so far. Here is his code with all the references to the accumulator argument in red:</p>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">read_filesystem</span> <span class="ocaml-variable">path </span>=
  <span class="kwb">if</span> (lstat path).st_kind = S_DIR <span class="kwb">then</span>
    Directory (read_directory path)
  <span class="kwb">else</span>
    File path

<span class="kwa">and</span> <span class="ocaml-function">read_directory</span> <span class="ocaml-variable">path </span>=
  <span class="kwa">let </span><span class="ocaml-variable">dirh</span> = opendir path <span class="kwa">in</span>
  <span class="kwa">let rec</span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">entries </span>=
    <span class="kwb">try</span>
      <span class="kwb">match</span> readdir dirh <span class="kwb">with</span>
      | &quot;.&quot; | &quot;..&quot; -&gt; loop entries
      | filename -&gt; loop (read_filesystem (path ^ &quot;/&quot; ^ filename) :: entries)
    <span class="kwb">with</span> End_of_file -&gt; entries <span class="kwa">in</span>
  <span class="kwa">let </span><span class="ocaml-variable">list</span> = loop [] <span class="kwa">in</span>
  closedir dirh;
  list</span></pre>

<p>Notice <code>End_of_file -&gt; entries</code> which means &quot;when we get the exception, give up and return the result so far&quot;.</p>
<p>Next up - it was pointed out that the easiest way to do this is actually not to use recursion at all, but instead to do the loop imperatively (a while loop is probably best) and have a reference to a list to store the ongoing accumulated result. Because <code>readdir</code> throws an exception, we have a simple way to break out of the while loop, <em>and</em> in the <code>with</code>-clause we can just return <code>!list</code> (dereference the reference to the list of entries we've built up).</p>
<p>It all works nicely, and proves that writing code imperatively is often best, <em>particularly</em> as in this case where <code>opendir ... readdir ... closedir</code> is essentially an imperative API, designed for C programmers. It's no surprise, therefore, that the imperative solution is easier. OCaml, not being a  <a title="http://www.elsewhere.org/jargon/html/entry/bondage-and-discipline-language.html" class="external" href="http://www.elsewhere.org/jargon/html/entry/bondage-and-discipline-language.html">bondage and discipline language</a>, doesn't mind you using the imperative approach when it makes sense.</p>
<p>Here is the outline of the imperative approach by Fabrice Le Fessant:</p>
<pre><span class="listing"><span class="kwa">let </span><span class="ocaml-variable">list</span> = <span class="kwb">ref</span> [] <span class="kwa">in</span>
<span class="kwa">let </span><span class="ocaml-variable">dir</span> = opendir &quot;.......&quot; <span class="kwa">in</span>
<span class="kwb">try</span>
  <span class="kwb">while</span> true <span class="kwb">do</span>
    <span class="kwb">match</span> readdir dir <span class="kwb">with</span>
    | &quot;.&quot; | &quot;..&quot; -&gt; ()
    | filename -&gt; list := filename :: !list
  <span class="kwb">done</span>
<span class="kwb">with</span> End_of_file -&gt; !list</span></pre>

<h3>Recursion example: maximum element in a list</h3>
<p>Remember the basic recursion pattern for lists:</p>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
  a <span class="kwb">match</span> or <span class="kwb">if</span> statement
  | base case -&gt; []
  | recursive case -&gt; element :: loop ()</span></pre>

<p>The key here is actually the use of the match / base case / recursive case pattern. In this example - finding the maximum element in a list - we're going to have two base cases and one recursive case. But before I jump ahead to the code, let's just step back and think about the problem. By thinking about the problem, the solution will appear &quot;as if by magic&quot; (I promise you :-)</p>
<p>First of all, let's be clear that the maximum element of a list is just the biggest one. eg. The maximum element of the list <code>[1; 2; 3; 4; 1]</code> is <code>4</code>.</p>
<p>Are there any special cases? Yes there are. What's the maximum element of the empty list <code>[]</code>? There <em>isn't one</em>. If we are passed an empty list, we should throw an error.</p>
<p>What's the maximum element of a single element list such as <code>[4]</code>? That's easy: it's just the element itself. So <code>list_max [4]</code> should return <code>4</code>, or in the general case, <code>list_max [x]</code> should return <code>x</code>.</p>
<p>What's the maximum element of the general list <code>x :: remainder</code> (this is the &quot;cons&quot; notation for the list, so <code>remainder</code> is the tail - also a list)?</p>
<p>Think about this for a while. Suppose you know the maximum element of <code>remainder</code>, which is, say, <code>y</code>. What's the maximum element of <code>x :: remainder</code>? It depends on whether <code>x &gt; y</code> or <code>x &lt;= y</code>. If <code>x</code> is bigger than <code>y</code>, then the overall maximum is <code>x</code>, whereas conversely if <code>x</code> is less than <code>y</code>, then the overall maximum is <code>y</code>.</p>
<p>Does this really work? Consider <code>[1; 2; 3; 4; 1]</code> again. This is <code>1 :: [2; 3; 4; 1]</code>. Now the maximum element of the remainder, <code>[2; 3; 4; 1]</code>, is <code>4</code>. So now we're interested in <code>x = 1</code> and <code>y = 4</code>.  That head element <code>x = 1</code> doesn't matter because <code>y = 4</code> is bigger, so the overall maximum of the whole list is <code>y = 4</code>.</p>
<p>Let's now code those rules above up, to get a working function:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">list_max</span> <span class="ocaml-variable">xs </span>=
    <span class="kwb">match</span> xs <span class="kwb">with</span>
    | [] -&gt; <span class="kwb">failwith</span> &quot;list_max called on empty list&quot;  <span class="ocaml-comment">(* empty list: fail *)</span>
    | [x] -&gt; x                                        <span class="ocaml-comment">(* single element list: return the element *)</span>
    | x :: remainder -&gt; max x (list_max remainder)    <span class="ocaml-comment">(* multiple element list: recursive case *)</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val list_max : 'a list -&gt; 'a = &lt;fun&gt;
</span></pre>

<p>I've added comments so you can see how the rules / special cases we decided upon above really correspond to lines of code.</p>
<p>Does it work?</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">list_max [1; 2; 3; 4; 1]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int = 4
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">list_max []</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>Exception: Failure &quot;list_max called on empty list&quot;.
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">list_max [5; 4; 3; 2; 1]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int = 5
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">list_max [5; 4; 3; 2; 1; 100]</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int = 100
</span></pre>

<p>Notice how the solution proposed is both (a) very different from the imperative for-loop solution, and (b) much more closely tied to the problem specification. Functional programmers will tell you that this is because the functional style is much higher level than the imperative style, and therefore better and simpler. Whether you believe them is up to you. It's certainly true that it's much simpler to reason logically about the functional version, which is useful if you wanted to formally prove that <code>list_max</code> is correct (&quot;correct&quot; being the mathematical way to say that a program is provably bug-free, useful for space shuttles, nuclear power plants and higher quality software in general).</p>

<h3>Tail recursion</h3>
<p>Let's look at the <code>range</code> function again for about the twentieth time:</p>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
  <span class="kwb">if</span> a &gt; b <span class="kwb">then</span> []
  <span class="kwb">else</span> a :: range (a+1) b</span></pre>

<p>I'm going to rewrite it slightly to make something about the structure of the program clearer (still the same function however):</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
  <span class="kwb">if</span> a > b <span class="kwb">then</span> []
  <span class="kwb">else</span>
    <span class="kwa">let </span><span class="ocaml-variable">result</span> = range (a+1) b <span class="kwa">in</span>
    a :: result</span><span class="ocamltop-prompt">;;</span></pre>

<p>Let's call it:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">List</span>.length (range 1 10)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int = 10
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">List</span>.length (range 1 1000000)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>Stack overflow during evaluation (looping recursion?).
</span></pre>

<p>Hmmm ... at first sight this looks like a problem with recursive programming, and hence with the whole of functional programming! If you write your code recursively instead of iteratively then you necessarily run out of stack space on large inputs, right?</p>
<p>In fact, wrong. Compilers can perform a simple optimisation on certain types of recursive functions to turn them into while loops. These certain types of recursive functions therefore run in constant stack space, and with the equivalent efficiency of imperative while loops. These functions are called <strong>tail-recursive functions</strong>.</p>
<p>In tail-recursive functions, the recursive call happens last of all. Remember our <code>loop ()</code> functions above? They all had the form:</p>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
  <span class="ocaml-comment">(* <span class="kwb">do</span> something *)</span>
  loop ()</span></pre>

<p>Because the recursive call to <code>loop ()</code> happens as the very last thing, <code>loop</code> is tail-recursive and the compiler will turn the whole thing into a while loop.</p>
<p>Unfortunately <code>range</code> is not tail-recursive, and the longer version above shows why. The recursive call to <code>range</code> doesn't happen as the very last thing. In fact the last thing to happen is the <code>::</code> (cons) operation. As a result, the compiler doesn't turn the recursion into a while loop, and the function is not efficient in its use of stack space.</p>
<p>Now recall we discussed in the addendum above Eric Cooper's &quot;accumulator&quot; technique, and I said that this technique was widely used in functional programming. We will now see why this is the case. It's because it allows you to write functions such as <code>range</code> above in a tail-recursive manner, which means they will be efficient and work properly on large inputs.</p>
<p>Let's plan our rewritten <code>range</code> function which will use an accumulator argument to store the &quot;result so far&quot;:</p>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">range2</span> <span class="ocaml-variable">a b accum </span>=
  <span class="ocaml-comment">(* ... *)</span>

<span class="kwa">let</span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
  range2 a b []</span></pre>

<p>(I could and probably should have used a nested function here.)</p>
<p>The <code>accum</code> argument is going to accumulate the result. It's the &quot;result so far&quot;. We pass in the empty list (&quot;no result so far&quot;). The easy case is when <code>a &gt; b</code>:</p>
<pre><span class="listing"><span class="kwa">let rec</span> <span class="ocaml-function">range2</span> <span class="ocaml-variable">a b accum </span>=
  <span class="kwb">if</span> a &gt; b <span class="kwb">then</span> accum
  <span class="kwb">else</span>
    <span class="ocaml-comment">(* ... *)</span></span></pre>

<p>If <code>a &gt; b</code> (ie. if we've reached the end of the recursion), then stop and return the result (<code>accum</code>).</p>
<p>Now the trick is to write the <code>else</code>-clause and make sure that the call to <code>range2</code> is the very last thing that we do, so the function is tail-recursive:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">range2</span> <span class="ocaml-variable">a b accum </span>=
    <span class="kwb">if</span> a &gt; b <span class="kwb">then</span> accum
    <span class="kwb">else</span> range2 (a+1) b (a :: accum)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val range2 : int -&gt; int -&gt; int list -&gt; int list = &lt;fun&gt;
</span></pre>

<p>There's only one slight problem with this function: it constructs the list backwards!  However, this is easy to rectify by redefining range as:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>= <span class="ocaml-mod">List</span>.rev (range2 a b [])</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></pre>

<p>It works this time, although it's a bit slow to run because it really does have to construct a list with a million elements in it:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">List</span>.length (range 1 1000000)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int = 1000000
</span></pre>

<p>The following implementation is twice as fast as the previous one, because it does not need to reverse a list:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let rec</span> <span class="ocaml-function">range2</span> <span class="ocaml-variable">a b accum </span>=
    <span class="kwb">if</span> b &lt; a <span class="kwb">then</span> accum
    <span class="kwb">else</span> range2 a (b-1) (b :: accum)</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val range2 : int -&gt; int -&gt; int list -&gt; int list = &lt;fun&gt;
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
    range2 a b []</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></pre>

<p>That was a brief overview of tail recursion, but in real world situations determining if a function is tail recursive can be quite hard. What did we really learn here? One thing is that recursive functions have a dangerous trap for inexperienced programmers. Your function can appear to work for small inputs (during testing), but fail catastrophically in the field when exposed to large inputs. This is one argument <em>against</em> using recursive functions, and for using explicit while loops when possible.</p>
<a name="Mutable_records__references__again___and_arrays"></a><h2><span>Mutable records, references (again!) and arrays</span></h2>
<p>Previously we mentioned records in passing. These are like C <code>struct</code>s:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">type</span> <span class="ocaml-mod">pair_of_ints</span> = { a : int; b : int }</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>type pair_of_ints = { a : int; b : int; }
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">{a=3; b=5}</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : pair_of_ints = {a = 3; b = 5}
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">{a=3}</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-error">File &quot;&quot;, line 1, characters 0-5:
Error: Some record field labels are undefined: b
</span></pre>

<p>One feature which I didn't cover: OCaml records can have mutable fields. Normally an expression like <code>{a = 3; b = 5}</code> is an immutable, constant object. However if the record has &lt;dfn&gt;mutable fields&lt;/dfn&gt;, then there is a way to change those fields in the record. This is an imperative feature of OCaml, because functional languages don't normally allow mutable objects (or references or mutable arrays, which we'll look at in a moment).</p>
<p>Here is an object defined with a mutable field. This field is used to count how many times the object has been accessed. You could imagine this being used in a caching scheme to decide which objects you'd evict from memory.</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">type</span> <span class="ocaml-mod">name</span> = { name : string; <span class="kwb">mutable</span> access_count : int }</span><span class="ocamltop-prompt">;;</span></pre>

<p>Here is a function defined on names which prints the <code>name</code> field and increments the mutable <code>access_count</code> field:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let</span> <span class="ocaml-function">print_name</span> <span class="ocaml-variable">name </span>=
    print_endline (&quot;The name is &quot; ^ name.name);
    name.access_count &lt;- name.access_count + 1</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val print_name : name -&gt; unit = &lt;fun&gt;
</span></pre>

<p>Notice a strange, and very non-functional feature of <code>print_name</code>: it modifies its <code>access_count</code> parameter. If you read chapter 5 closely, you'll see that this function is not &quot;pure&quot;. OCaml is a functional language, but not to the extent that it forces functional programming down your throat.</p>
<p>Anyway, let's see <code>print_name</code> in action:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">n</span> = { name = &quot;Richard Jones&quot;; access_count = 0 }</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val n : name = {name = &quot;Richard Jones&quot;; access_count = 0}
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">n</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : name = {name = &quot;Richard Jones&quot;; access_count = 0}
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">print_name n</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout">The name is Richard Jones
</span><span class="ocamltop-stderr"></span>- : unit = ()
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">n</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : name = {name = &quot;Richard Jones&quot;; access_count = 1}
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">print_name n</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout">The name is Richard Jones
</span><span class="ocamltop-stderr"></span>- : unit = ()
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">n</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : name = {name = &quot;Richard Jones&quot;; access_count = 2}
</span></pre>

<p>Only fields explicitly marked as <code>mutable</code> can be assigned to using the <code>&lt;-</code> operator. If you try to assign to a non-mutable field, OCaml won't let you:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">n.name &lt;- &quot;John Smith&quot;</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-error">File &quot;&quot;, line 1, characters 0-22:
Error: The record field label name is not mutable
</span></pre>

<p>References, with which we should be familiar by now, are implemented using records with a mutable <code>contents</code> field. Check out the definition in <code>Pervasives</code>:</p>
<pre><span class="listing"><span class="kwa">type</span> 'a <span class="ocaml-mod"><span class="kwb">ref</span></span> = { <span class="kwb">mutable</span> contents : 'a }</span></pre>

<p>And look closely at what the OCaml toplevel prints out for the value of a reference:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">r</span> = <span class="kwb">ref</span> 100</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val r : int ref = {contents = 100}
</span></pre>

<p>Arrays are another sort of mutable structure provided by OCaml.  In OCaml, plain lists are implemented as linked lists, and linked lists are slow for some types of operation. For example, getting the head of a list, or iterating over a list to perform some operation on each element is reasonably fast. However, jumping to the n<sup>th</sup> element of a list, or trying to randomly access a list - both are slow operations. The OCaml <code>Array</code> type is a real array, so random access is fast, but insertion and deletion of elements is slow. <code>Array</code>s are also mutable so you can randomly change elements too.</p>
<p>The basics of arrays are simple:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">a</span> = <span class="ocaml-mod">Array</span>.create 10 0</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val a : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwb">for</span> i = 0 <span class="kwb">to</span> <span class="ocaml-mod">Array</span>.length a - 1 <span class="kwb">do</span>
    a.(i) &lt;- i
  <span class="kwb">done</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : unit = ()
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">a</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : int array = [|0; 1; 2; 3; 4; 5; 6; 7; 8; 9|]
</span></pre>

<p>Notice the syntax for writing arrays: <code>[| <em>element</em>; <em>element</em>; ... |]</code></p>
<p>The OCaml compiler was designed with heavy numerical processing in mind (the sort of thing that FORTRAN is traditionally used for), and so it contains various optimisations specifically for arrays of numbers, vectors and matrices. Here is some benchmark code for doing dense matrix multiplication. Notice that it uses for-loops and is generally very imperative in style:</p>
<pre><span class="listing"><span class="ocaml-comment">(*
 * $Id: index.shtml,v 1.3 2004/04/23 12:33:00 rich Exp $
 * http://www.bagley.org/~doug/shootout/
 * from Markus Mottl
 *)</span>

<span class="kwa">let </span><span class="ocaml-variable">size</span> = 30

<span class="kwa">let</span> <span class="ocaml-function">mkmatrix</span> <span class="ocaml-variable">rows cols </span>=
  <span class="kwa">let </span><span class="ocaml-variable">count</span> = <span class="kwb">ref</span> 1
  <span class="kwa">and </span><span class="ocaml-variable">last_col</span> = cols - 1
  <span class="kwa">and </span><span class="ocaml-variable">m</span> = <span class="ocaml-mod">Array</span>.make_matrix rows cols 0 <span class="kwa">in</span>
  <span class="kwb">for</span> i = 0 <span class="kwb">to</span> rows - 1 <span class="kwb">do</span>
    <span class="kwa">let </span><span class="ocaml-variable">mi</span> = m.(i) <span class="kwa">in</span>
    <span class="kwb">for</span> j = 0 <span class="kwb">to</span> last_col <span class="kwb">do</span>
      mi.(j) &lt;- !count;
      incr count
    <span class="kwb">done</span>;
  <span class="kwb">done</span>;
  m

<span class="kwa">let rec</span> <span class="ocaml-function">inner_loop</span> <span class="ocaml-variable">k v m1i m2 j </span>=
  <span class="kwb">if</span> k &lt; 0 <span class="kwb">then</span> v
  <span class="kwb">else</span> inner_loop (k - 1) (v + m1i.(k) * m2.(k).(j)) m1i m2 j

<span class="kwa">let</span> <span class="ocaml-function">mmult</span> <span class="ocaml-variable">rows cols m1 m2 m3 </span>=
  <span class="kwa">let </span><span class="ocaml-variable">last_col</span> = cols - 1
  <span class="kwa">and </span><span class="ocaml-variable">last_row</span> = rows - 1 <span class="kwa">in</span>
  <span class="kwb">for</span> i = 0 <span class="kwb">to</span> last_row <span class="kwb">do</span>
    <span class="kwa">let </span><span class="ocaml-variable">m1i</span> = m1.(i) <span class="kwa">and </span><span class="ocaml-variable">m3i</span> = m3.(i) <span class="kwa">in</span>
    <span class="kwb">for</span> j = 0 <span class="kwb">to</span> last_col <span class="kwb">do</span>
      m3i.(j) &lt;- inner_loop last_row 0 m1i m2 j
    <span class="kwb">done</span>;
  <span class="kwb">done</span>

<span class="kwa">let</span> () =
  <span class="kwa">let </span><span class="ocaml-variable">n</span> =
    <span class="kwb">try</span> int_of_string <span class="ocaml-mod">Sys</span>.argv.(1)
    <span class="kwb">with</span> Invalid_argument _ -&gt; 1
  <span class="kwa">and </span><span class="ocaml-variable">m1</span> = mkmatrix size size
  <span class="kwa">and </span><span class="ocaml-variable">m2</span> = mkmatrix size size
  <span class="kwa">and </span><span class="ocaml-variable">m3</span> = <span class="ocaml-mod">Array</span>.make_matrix size size 0 <span class="kwa">in</span>
  <span class="kwb">for</span> i = 1 <span class="kwb">to</span> n - 1 <span class="kwb">do</span>
    mmult size size m1 m2 m3
  <span class="kwb">done</span>;
  mmult size size m1 m2 m3;
  <span class="ocaml-mod">Printf</span>.printf &quot;%d %d %d %d\n&quot; m3.(0).(0) m3.(2).(3) m3.(3).(2) m3.(4).(4)</span></pre>





    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
</body></html>
