<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: Camlp4 3.10 Foreach Tutorial</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contributors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="http://ocaml.org/img/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href="../.././css/bootstrap.css"/>
    <link href="../.././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href="../.././css/bootstrap-responsive.css"/>

    
    

    <meta content="Camlp4 3.10 Foreach Tutorial" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href="../.././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it Online</a></li>
    <li><a href="../../taste.html">100 Lines of OCaml</a></li>
    <li><a href="../../success.html">Success Stories</a></li>
    <li><a href="../../companies.html">Who Is Using It?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a>
        <a href="http://langref.org/ocaml">langref.org</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../../install.html">Install</a></li>
    <li><a href="../../tutorials/">Tutorials</a></li>
    <li><a href="../../faq.html">FAQ</a></li>
    <li><a href="../../books.html">Books</a></li>
    <li><a href="../../videos.html">Videos</a></li>
    <li><a href="../../papers.html">Papers</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../../releases/">Releases</a></li>
    <li><a href="../../libraries.html">Libraries</a></li>
    <li><a href="../../dev_tools.html">Development Tools</a></li>
    <li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/">User Manual</a></li>
    <li><a href="../../cheat_sheets.html">Cheat Sheets</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API Search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">GitHub</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
    <li><a href="http://gitorious.org/search?page=1&q=ocaml">Gitorious</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../../mailing_lists.html">Mailing Lists</a></li>
    <li><a href="../../planet/">Blogs</a></li>
    <li><a href="../../meetings/">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../../caml-light/">Caml Light</a></li>
    <li><a href="../../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://ocaml.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../../">Home</a><span class="separation"><img src="../.././img/right_arrow.png" alt="&gt;"/></span><a href="./../">Tutorials</a><span class="separation"><img src="../.././img/right_arrow.png" alt="&gt;"/></span><a href="./">Camlp4_3.10</a><span class="separation"><img src="../.././img/right_arrow.png" alt="&gt;"/></span>Camlp4 3.10 Foreach Tutorial
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      

<div style="margin-left: 1em" class="pull-right hero-unit">
      <em>Table of contents</em>
      <div class="toc"><ul class="toc-sub"><li class="toc-entry"><a href="#Camlp4_3_10_Motivtion">Motivation</a></li><li class="toc-entry"><a href="#Towards_the_First_Try">Towards the First Try</a></li><li class="toc-entry"><a href="#Supporting_Multiple_Patterns">Supporting Multiple Patterns</a></li><li class="toc-entry"><a href="#Final_Touch_up">Final Touch-up</a></li><li class="toc-entry"><a href="#Conclusion">Conclusion</a></li></ul></div>
</div>

<h1><a name="Camlp4_3_10_Foreach_Tutorial">Camlp4 3.10 Foreach Tutorial</a></h1>

<p>This is a tutorial that guides you, step by step, how to write syntax extension using Camlp4 in Objective CAML. The example we present in this tutorial should give you a practical idea how syntax extension works, but this is not meant to be comprehensive. There are many resources on the web for Camlp4 prior to version 3.10, but Camlp4 3.10 introduces incompatible changes. This tutorial targets Camlp4 3.10 only.</p>

<p>Throughout the tutorial, we intentionally introduce subtle bugs in the interest of simplicity, but these bugs will be later explained.</p>

<p>The reader is expected to be familiar with context-free parsing. Some experience with yacc or ocamlyacc will be helpful. Knowing the difference between LL, LR and LALR parsers is a plus.</p>

<h2><a name="Camlp4_3_10_Motivtion">Motivation</a></h2>

<p>One of the greatest strengths of OCaml is Camlp4, a modular pre-processor pretty-printer that lets you add syntactic sugar to the language without rewriting the entire grammar from scratch. A syntactic sugar is a language construct that can be decomposed to an existing construct. For example, OCaml doesn't have a "for-each" syntax, which can be illustrated by the following Python code:</p>

<pre>
a_list = ["hello", "world"]
for s in a_list:
  print s
</pre>

<p>This code outputs:</p>

<pre>
hello
world
</pre>

<p>However, that doesn't mean OCaml can't support iterators! As it turns out, many modules in OCaml that define a data structure also provide an "iter" higher-order function that works similarly:</p>

<pre><span class="listing"><span class="kwa">let </span><span class="ocaml-variable">a_list</span> = [<span class="ocaml-string">&quot;hello&quot;</span>; <span class="ocaml-string">&quot;world&quot;</span>] <span class="kwa">in</span>
<span class="ocaml-mod">List</span>.iter (<span class="kwb">fun</span> s -&gt; print_endline s) a_list</span></pre>


<p>Besides <code>List</code>, other modules that provide "iter" are <code>Array</code>, <code>Hashtbl</code>, <code>Map.Make(_)</code>, <code>Queue</code>, <code>Set.Make(_)</code>, <code>Stack</code>, and even <code>String</code>. Wouldn't it be nice if one can write:</p>

<pre><span class="listing"><span class="kwa">let </span><span class="ocaml-variable">a_list</span> = [<span class="ocaml-string">&quot;hello&quot;</span>; <span class="ocaml-string">&quot;world&quot;</span>] <span class="kwa">in</span>
<span class="kwb">for</span> s <span class="kwa">in</span> a_list <span class="kwb">do</span>
  print_endline s
<span class="kwb">done</span></span></pre>

<p>instead? Imagine a long for-each body; this style of writing puts the "each" variable and the list next to each other, which results in cleaner code.</p>
<p>The idea is to transform the latter code into former, leveraging the "iter" function provided by these modules.</p>
<p>Notice that we can't generally look up a module specific "iter" function by the type of the expression we want to iterate over, so we have to specify a module like this:</p>

<pre><span class="listing"><span class="kwa">let </span><span class="ocaml-variable">a_list</span> = [<span class="ocaml-string">&quot;hello&quot;</span>; <span class="ocaml-string">&quot;world&quot;</span>] <span class="kwa">in</span>
<span class="kwb">for</span> s <span class="kwa">in</span> List a_list <span class="kwb">do</span>
  print_endline s
<span class="kwb">done</span></span></pre>

<p>More generally, the syntactic sugar takes the following form:</p>
<pre><span class="listing"><span class="kwb">for</span> v <span class="kwa">in</span> M e <span class="kwb">do</span>
  seq
<span class="kwb">done</span></span></pre>

<p>where module <code>M</code> implements an iterator over the elements in collection <em>e</em>; most of the time, <em>e</em> also has the type <code>M.t</code>, though this is not strictly required.</p>
<h2><a name="Towards_the_First_Try">Towards the First Try</a></h2>
<p>Without going into too much detail, we can write a simple extension
  as the following: </p>
<pre><span class="listing"><span class="kwa">open</span> <span class="ocaml-mod">Camlp4</span>.<span class="ocaml-mod">PreCast</span>
<span class="kwa">open</span> <span class="ocaml-mod">Syntax</span>

<span class="kwa">let</span> () =
  EXTEND Gram
    expr: LEVEL <span class="ocaml-string">&quot;top&quot;</span>
    [ [ <span class="ocaml-string">&quot;<span class="kwb">for</span>&quot;</span>; v = a_LIDENT; <span class="ocaml-string">&quot;<span class="kwa">in</span>&quot;</span>; m = a_UIDENT; e = expr; <span class="ocaml-string">&quot;<span class="kwb">do</span>&quot;</span>;
        seq = sequence; <span class="ocaml-string">&quot;<span class="kwb">done</span>&quot;</span> -&gt;
          &lt;:expr&lt; $uid:m$.iter (<span class="kwb">fun</span> $lid:v$ -&gt; $seq$) $e$ &gt;&gt;
      ] ];
  END</span></pre>
<p>For what follows, it is assumed that this code is written to a
  file <code>pa_foreach.ml</code>.</p>

<p>All the prerequisites are provided by the module <code>Camlp4.PreCast</code>, including the <code>Syntax</code> module that provides the terminals <code>a_LIDENT</code> and <code>a_UIDENT</code> (for lowercase and uppercase identifiers respectively), and the non-terminals <code>expr</code> (expressions) and <code>sequence</code> (semicolon separated expressions). The <code>Gram</code> module provides functions to manipulate non-terminal rules.</p>
<p>Suppose we save this syntax extension in the file called <code>pa_foreach.ml</code>. Notice that a syntax extension is just a regular OCaml file with some fancy <code>EXTEND</code> syntax. It can be compiled using the command:</p>
<pre>
ocamlc -I +camlp4 camlp4lib.cma -pp camlp4orf -c pa_foreach.ml
</pre>

<ul><li>FYI: Camlp4 is complicated to learn because a syntax extension consists of two domain-specific languages that are foreign to OCaml: parsing and code embedding. To add insult to injury, Camlp4 has a "<a title="http://caml.inria.fr/pub/docs/manual-camlp4/manual007.html" class="external" href="http://caml.inria.fr/pub/docs/manual-camlp4/manual007.html">revised syntax</a>" dialect of OCaml that can be used, in addition to the original OCaml dialect, both as the host (top-level) language and as the embedded language. This tutorial uses original OCaml as the host language and revised dialect as the embedded language. This choice is reflected in the camlp4 executable that we use here, <code>camlp4orf</code>. See <a title="http://brion.inria.fr/gallium/index.php/Using_Camlp4" class="external" href="http://brion.inria.fr/gallium/index.php/Using_Camlp4">Using Camlp4</a> for the explanation and additional options.</li></ul>
<p>We can verify that it works:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">#load <span class="ocaml-string">&quot;camlp4o.cma&quot;</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-comment">(* Add directory where the syntax extension is compiled <span class="kwb">to</span> the module
     path (not required <span class="kwb">if</span> pa_foreach.cmo is <span class="kwa">in</span> the current directory). *)</span>
  #directory <span class="ocaml-string">&quot;_build/src/html/tutorials/camlp4_3.10/&quot;</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout">	Camlp4 Parsing version 4.00.1

</span><span class="ocamltop-stderr"></span></span><span class="ocamltop-prompt"># </span><span class="ocamltop-input">#load <span class="ocaml-string">&quot;pa_foreach.cmo&quot;</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwb">for</span> s <span class="kwa">in</span> List [<span class="ocaml-string">&quot;hello&quot;</span>; <span class="ocaml-string">&quot;world&quot;</span>] <span class="kwb">do</span> print_endline s <span class="kwb">done</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout">hello
world
</span><span class="ocamltop-stderr"></span>- : unit = ()
</span></pre>

<p>Now we have a rudimentary syntax extension. However, it is quite restrictive. For example, it would be nice to do pattern matching like this:</p>
<pre><span class="listing"><span class="kwb">for</span> (k, v) <span class="kwa">in</span> List [(0, <span class="ocaml-string">&quot;hello&quot;</span>); (1, <span class="ocaml-string">&quot;world&quot;</span>)] <span class="kwb">do</span>
  <span class="ocaml-mod">Printf</span>.printf <span class="ocaml-string">&quot;%d: %s\n&quot;</span> k v
<span class="kwb">done</span></span></pre>

<p>And it doesn't support <code>Hashtbl.iter</code> yet because, so far, we can only generate functions with one argument. <code>Hashtbl.iter</code> passes two arguments to the function, the key and the value. We will address these issues in the next section.</p>
<h2><a name="Supporting_Multiple_Patterns">Supporting Multiple Patterns</a></h2>
<p>We're now beginning to use Camlp4 features that are less documented. It is useful to keep in mind that syntax extension <em>is</em> modifying existing parsing rules, and we can't do without an understanding of how existing rules work. It is recommended that you take a quick look at two files in the OCaml source distribution under <code>ocaml-3.10.0/camlp4/Camlp4Parsers</code>:</p>
<ul><li><code>Camlp4OCamlRevisedParser.ml</code>; this provides the bulk of the syntax rules.</li>
<li><code>Camlp4OCamlParser.ml</code> implicitly borrows most of its rules from <code>Camlp4OCamlRevisedParser</code>, but clears some of the rules that are particular to the revised syntax and replaces them with the original OCaml syntax.</li></ul>
<p>From these files, we can see that <code>ipatt</code> rule supplies what we want for matching patterns, and <code>LIST1</code> modifier allows us to take one or more patterns. There is also a <code>LIST0</code> modifier for "zero or more" matching.</p>
<pre><span class="listing"><span class="kwa">open</span> <span class="ocaml-mod">Camlp4</span>.<span class="ocaml-mod">PreCast</span>
<span class="kwa">open</span> <span class="ocaml-mod">Syntax</span>

<span class="kwa">let rec</span> <span class="ocaml-function">mkfun</span> <span class="ocaml-variable">_loc patts e </span>=
  <span class="kwb">match</span> patts <span class="kwb">with</span>
  | p :: patts -&gt;
      &lt;:expr&lt; <span class="kwb">fun</span> $p$ -&gt; $mkfun _loc patts e$ &gt;&gt;
  | [] -&gt;
      e

<span class="kwa">let</span> () =
  EXTEND Gram
    expr: LEVEL <span class="ocaml-string">&quot;top&quot;</span>
    [ [ <span class="ocaml-string">&quot;<span class="kwb">for</span>&quot;</span>; patts = LIST1 ipatt; <span class="ocaml-string">&quot;<span class="kwa">in</span>&quot;</span>; m = a_UIDENT; e = expr; <span class="ocaml-string">&quot;<span class="kwb">do</span>&quot;</span>;
        seq = sequence; <span class="ocaml-string">&quot;<span class="kwb">done</span>&quot;</span> -&gt;
          <span class="kwa">let </span><span class="ocaml-variable">f</span> = mkfun _loc patts seq <span class="kwa">in</span>
          &lt;:expr&lt; $uid:m$.iter $f$ $e$ &gt;&gt;
      ] ];
  END</span></pre>

<p>In order to generate a higher-order function according to a list of patterns, we use the helper <code>mkfun</code> that essentially generates, for patterns <code>patt1</code> ... <code>pattN</code>,</p>
<pre><span class="listing"><span class="kwb">fun</span> patt1 -&gt;
  ...
    <span class="kwb">fun</span> pattN -&gt;
      seq</span></pre>

<p>which is the desugared form for <code><span class="listing"><span class="kwb">fun</span> patt1 ... pattN -&gt; seq</span></code>.</p>
<p>We can verify that pattern works:</p>
<pre>
ocamlc -I +camlp4 camlp4lib.cma -pp camlp4orf -c pa_foreach2.ml
</pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">#load <span class="ocaml-string">&quot;pa_foreach2.cmo&quot;</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwb">for</span> (k, v) <span class="kwa">in</span> List [(0, <span class="ocaml-string">&quot;hello&quot;</span>); (1, <span class="ocaml-string">&quot;world&quot;</span>)] <span class="kwb">do</span>
    <span class="ocaml-mod">Printf</span>.printf <span class="ocaml-string">&quot;%d: %s\n&quot;</span> k v
  <span class="kwb">done</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout">0: hello
1: world
</span><span class="ocamltop-stderr"></span>- : unit = ()
</span></pre>

<p>and that multiple arguments work:</p>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">tbl</span> = <span class="ocaml-mod">Hashtbl</span>.create 3</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val tbl : ('_a, '_b) Hashtbl.t = &lt;abstr&gt;
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">Hashtbl</span>.add tbl 0 <span class="ocaml-string">&quot;hello&quot;</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : unit = ()
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">Hashtbl</span>.add tbl 1 <span class="ocaml-string">&quot;world&quot;</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : unit = ()
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">Hashtbl</span>.add tbl 2 <span class="ocaml-string">&quot;foobar&quot;</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : unit = ()
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwb">for</span> k v <span class="kwa">in</span> Hashtbl tbl <span class="kwb">do</span>
    <span class="ocaml-mod">Printf</span>.printf <span class="ocaml-string">&quot;%d: %s\n&quot;</span> k v
  <span class="kwb">done</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout">2: foobar
0: hello
1: world
</span><span class="ocamltop-stderr"></span>- : unit = ()
</span></pre>

<p>There are still some subtle problems with this approach. In the next section, we'll discuss solutions to these problems.</p>
<h2><a name="Final_Touch_up">Final Touch-up</a></h2>
<p>The first problem we find out is that foreach body is supposed to be a sequence, but that doesn't work:</p>
<pre><span class="listing"># <span class="kwb">for</span> s <span class="kwa">in</span> List [<span class="ocaml-string">&quot;hello&quot;</span>; <span class="ocaml-string">&quot;world&quot;</span>] <span class="kwb">do</span> print_endline s; () <span class="kwb">done</span><span class="ocamltop-prompt">;;</span>
Failure: <span class="ocaml-string">&quot;expr; expr: not allowed here, use <span class="kwb">do</span> {...} or [|...|] <span class="kwb">to</span> surround them&quot;</span></span></pre>

<p>The problem is due to the desugared form, which becomes:</p>
<pre><span class="listing"><span class="ocaml-mod">List</span>.iter (<span class="kwb">fun</span> s -&gt; print_endline s; ()) [<span class="ocaml-string">&quot;hello&quot;</span>; <span class="ocaml-string">&quot;world&quot;</span>]</span></pre>

<p>and this is ambiguous. Do we interpret the expression <code>fun s -> print_endline s; ()</code> as <code>(fun s -> print_endline s); ()</code> or <code>fun s -> (print_endline (); ())</code>? In order to avoid ambiguity, we wrap the sequence using <code>do {$seq$}</code> when it is a sequence. The function <code>mksequence'</code> in <code>Camlp4OCamlRevisedParser.ml</code> provides some inspiration how to handle this.</p>
<ul><li>FYI: see <a title="http://caml.inria.fr/pub/ml-archives/caml-list/2007/07/40966461d8ade5dcee6790fa32cc9983.en.html" class="external" href="http://caml.inria.fr/pub/ml-archives/caml-list/2007/07/40966461d8ade5dcee6790fa32cc9983.en.html">this post</a> by Nicolas Pouillard for a discussion of a similar issue.</li></ul>
<p>We also notice that the original for-loop syntax ceases working:</p>
<pre><span class="listing"># <span class="kwb">for</span> i = 0 <span class="kwb">to</span> 5 <span class="kwb">do</span> print_int i <span class="kwb">done</span><span class="ocamltop-prompt">;;</span>
Parse error: [ipatt] or [a_LIDENT] expected after <span class="ocaml-string">&quot;<span class="kwb">for</span>&quot;</span> (<span class="kwa">in</span> [expr])</span></pre>


<p>It turns out that the new rule we add for "for" doesn't play nice with the original rule. The solution is to rewrite the original rule so it becomes compatible with the new rule.</p>
<p>The code listing that addresses these issues can be found below:</p>
<pre><span class="listing"><span class="kwa">open</span> <span class="ocaml-mod">Camlp4</span>.<span class="ocaml-mod">PreCast</span>
<span class="kwa">open</span> <span class="ocaml-mod">Syntax</span>

<span class="kwa">let</span> <span class="ocaml-function">mksequence</span> <span class="ocaml-variable">_loc </span>= <span class="kwb">function</span>
  | &lt;:expr&lt; $_$; $_$ &gt;&gt; <span class="kwb">as</span> e -&gt; &lt;:expr&lt; $e$ &gt;&gt;
  | e -&gt; e

<span class="kwa">let rec</span> <span class="ocaml-function">mkfun</span> <span class="ocaml-variable">_loc patts e </span>=
  <span class="kwb">match</span> patts <span class="kwb">with</span>
  | p :: patts -&gt; &lt;:expr&lt; <span class="kwb">fun</span> $p$ -&gt; $mkfun _loc patts e$ &gt;&gt;
  | [] -&gt; mksequence _loc e

<span class="kwa">let</span> <span class="ocaml-function">lident_of_patt</span> <span class="ocaml-variable">p </span>=
  <span class="kwb">match</span> p <span class="kwb">with</span>
  | &lt;:patt&lt; $lid:i$ &gt;&gt; -&gt; i
  | _ -&gt; invalid_arg <span class="ocaml-string">&quot;lident_of_patt&quot;</span>

<span class="kwa">let</span> () =
  DELETE_RULE Gram
  expr:
    <span class="ocaml-string">&quot;<span class="kwb">for</span>&quot;</span>; a_LIDENT; <span class="ocaml-string">&quot;=&quot;</span>; sequence; direction_flag; sequence; <span class="ocaml-string">&quot;<span class="kwb">do</span>&quot;</span>; do_sequence
  END;

  EXTEND Gram
  expr: LEVEL <span class="ocaml-string">&quot;top&quot;</span>
    [ [ <span class="ocaml-string">&quot;<span class="kwb">for</span>&quot;</span>; i = ipatt; <span class="ocaml-string">&quot;=&quot;</span>; e1 = sequence; df = direction_flag;
        e2 = sequence; <span class="ocaml-string">&quot;<span class="kwb">do</span>&quot;</span>; seq = do_sequence -&gt;
         &lt;:expr&lt;
           <span class="kwb">for</span> $lident_of_patt i$ =
             $mksequence _loc e1$ $<span class="kwb">to</span>:df$ $mksequence _loc e2$
             <span class="kwb">do</span> $seq$ <span class="kwb">done</span>
         &gt;&gt;
      | <span class="ocaml-string">&quot;<span class="kwb">for</span>&quot;</span>; p = ipatt; patts = LIST0 ipatt; <span class="ocaml-string">&quot;<span class="kwa">in</span>&quot;</span>; m = a_UIDENT; e = expr;
        <span class="ocaml-string">&quot;<span class="kwb">do</span>&quot;</span>; seq = do_sequence -&gt;
         <span class="kwa">let </span><span class="ocaml-variable">patts</span> = p :: patts <span class="kwa">in</span>
         <span class="kwa">let </span><span class="ocaml-variable">f</span> = mkfun _loc patts seq <span class="kwa">in</span>
         &lt;:expr&lt; $uid:m$.iter $f$ $e$ &gt;&gt;
      ] ];
  END</span></pre>

<p>In order for alternative rules to "fall through" correctly, rules must share a common prefix, and the rest of the non-terminals must be distinct enough. The way we structured the "for" syntax before, we essentially have the following two rules:</p>
<pre><span class="listing">EXTEND Gram
  expr: LEVEL <span class="ocaml-string">&quot;top&quot;</span>
    [ [ <span class="ocaml-string">&quot;<span class="kwb">for</span>&quot;</span>; patts = LIST1 ipatt; <span class="ocaml-string">&quot;<span class="kwa">in</span>&quot;</span>; m = a_UIDENT; e = expr;
       <span class="ocaml-string">&quot;<span class="kwb">do</span>&quot;</span>; seq = do_sequence -&gt;
         <span class="ocaml-comment">(* ... *)</span>
      | <span class="ocaml-string">&quot;<span class="kwb">for</span>&quot;</span>; i = a_LIDENT; <span class="ocaml-string">&quot;=&quot;</span>; e1 = sequence; df = direction_flag;
       e2 = sequence; <span class="ocaml-string">&quot;<span class="kwb">do</span>&quot;</span>; seq = do_sequence -&gt;
         <span class="ocaml-comment">(* ... *)</span>
      ] ]
  ;
END</span></pre>

<p>Once the "for" keyword is matched, the parser proceeds to match the next token, but <code>ipatt</code> also matches <code>a_LIDENT</code> (a lowercase identifier is also a legal pattern). At this point, the parser fixes on a rule (whichever comes first) and no longer backtracks to the alternative option.</p>
<p>The solution is to make the original for loop always match <code>ipatt</code>, but refuse anything except a lowercase identifier.</p>
<p>We can now verify that everything works as expected.</p>
<pre>
$ ocamlc -I +camlp4 camlp4lib.cma -pp camlp4orf -c pa_foreach3.ml
</pre>
<pre><span class="ocamltop-prompt"># </span><span class="ocamltop-input">#load <span class="ocaml-string">&quot;pa_foreach3.cmo&quot;</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span></span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwa">let </span><span class="ocaml-variable">tbl</span> = <span class="ocaml-mod">Hashtbl</span>.create 3</span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>val tbl : ('_a, '_b) Hashtbl.t = &lt;abstr&gt;
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">Hashtbl</span>.add tbl 0 <span class="ocaml-string">&quot;hello&quot;</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : unit = ()
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">Hashtbl</span>.add tbl 1 <span class="ocaml-string">&quot;world&quot;</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : unit = ()
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="ocaml-mod">Hashtbl</span>.add tbl 2 <span class="ocaml-string">&quot;foo&quot;</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout"></span><span class="ocamltop-stderr"></span>- : unit = ()
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwb">for</span> k v <span class="kwa">in</span> Hashtbl tbl <span class="kwb">do</span> <span class="ocaml-mod">Printf</span>.printf <span class="ocaml-string">&quot;%d: %s\n&quot;</span> k v <span class="kwb">done</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout">2: foo
0: hello
1: world
</span><span class="ocamltop-stderr"></span>- : unit = ()
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwb">for</span> i = 0 <span class="kwb">to</span> 5 <span class="kwb">do</span> print_int i <span class="kwb">done</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout">012345</span><span class="ocamltop-stderr"></span>- : unit = ()
</span><span class="ocamltop-prompt"># </span><span class="ocamltop-input"><span class="kwb">for</span> k, v <span class="kwa">in</span> List [0, <span class="ocaml-string">&quot;hello&quot;</span>; 1, <span class="ocaml-string">&quot;world&quot;</span>; 2, <span class="ocaml-string">&quot;foo&quot;</span>] <span class="kwb">do</span>
    <span class="ocaml-mod">Printf</span>.printf <span class="ocaml-string">&quot;%d: %s\n&quot;</span> k v
  <span class="kwb">done</span></span><span class="ocamltop-prompt">;;</span><br/><span class="ocamltop-output"><span class="ocamltop-stdout">0: hello
1: world
2: foo
</span><span class="ocamltop-stderr"></span>- : unit = ()
</span></pre>

<h2><a name="Conclusion">Conclusion</a></h2>
<p>We begin with a simple Camlp4 syntax extension for the for-each iterator syntax, then explored further refinements to that idea that works around parsing issues both in embedded code and in the rules.</p>
<p>This tutorial is written by <a title="http://cs-people.bu.edu/liulk" class="external" href="http://cs-people.bu.edu/liulk">Likai Liu</a>. The text has not been peer reviewed, so use this at your own risk. Questions and comments are welcome.</p>

    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title="../.././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src="../.././js/jquery-1.8.0.min.js"></script>
    
    <script src="../.././js/bootstrap.js"></script>

    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-37808023-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

    </script>

</body></html>
