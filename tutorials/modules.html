<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    
    <meta content="IE=8" http-equiv="X-UA-Compatible"/>
    <title>OCaml :: Modules</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Ashish Agarwal, Esther Baruk, Christophe Troestler and many contrinutors" name="author"/>
    <meta content="" name="description"/>
    <meta content="" name="keywords"/>
    <meta content="OCaml (Weberizer)" name="generator"/>

    <link href="https://static.ocamlcore.org/official/images/favicon.ico" rel="shortcut icon"/>
    <link rel="stylesheet" href=".././css/bootstrap.css"/>
    <link href=".././css/ocaml.css" media="all" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" href=".././css/bootstrap-responsive.css"/>

    
    

    <meta content="Modules" property="og:title"/>
    <meta content="non_profit" property="og:type"/>

    <meta content="all" name="robots"/>
  </head>
  <body>
    <div id="header">
      <div class="top">
      </div>
      <div class="bottom">
      </div>
    </div>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
	  
          <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a href=".././" class="brand">OCaml</a>

          <div class="nav-collapse">
            <ul class="nav">
	      <li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Discover
    <b class="caret"></b>
  </a>
  <ul class="dropdown-menu">
    <li><a href="../description.html">What is OCaml?</a></li>
    <li><a href="http://try.ocamlpro.com/">Try it in your browser</a></li>
    <li><a href="../taste.html">A Hundred Lines of OCaml</a></li>
    <li><a href="../success.html">Success Stories</a></li>
    <li><a href="../companies.html">Who is using it?</a></li>
    <li><a href="http://pleac.sourceforge.net/pleac_ocaml/">Pleac</a></li>
    <li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">
    Learn
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../install.html">Install</a></li>
    <li><a href="../tutorials/">Tutorials</a></li>
    <li><a href="../faq.html">FAQ</a></li>
    <li><a href="../books.html">Books</a></li>
    <li><a href="../videos.html">Videos</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Use
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../libraries.html">Libraries</a></li>
    <li><a href="../dev_tools.html">Development tools</a></li>
    <li><a href="../documentation.html">Manuals and Cheat Sheets</a></li>
    <li><a href="../tutorials/#advanced">Advanced tutorials &amp; Papers</a></li>
    <li><a href="http://search.ocaml.jp/">OCaml API search</a></li>
    <li><a href="http://forge.ocamlcore.org/">Forge</a></li>
    <li><a href="https://github.com/languages/OCaml">Github</a></li>
    <li><a href="https://bitbucket.org/repo/all?name=ocaml">Bitbucket</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">Community
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="../mailing_lists.html">Mailing lists</a></li>
    <li><a href="../planet/">OCaml Planet (blogs)</a></li>
    <li><a href="../meetings.html">Meetings</a></li>
    <li><a href="irc://irc.freenode.net/ocaml">IRC</a></li>
    <li><a href="http://stackoverflow.com/questions/tagged?tagnames=ocaml">Stack Overflow</a></li>
    <li><a href="http://www.reddit.com/r/ocaml/">Reddit</a></li>
    <li><a href="../support.html">Commercial Support</a></li>
  </ul>
</li>
<li class="dropdown">
  <a href="../#" class="dropdown-toggle" data-toggle="dropdown">More
    <b class="caret"></b></a>
  <ul class="dropdown-menu">
    <li><a href="http://caml.inria.fr/mantis/">Mantis Bug Tracker</a></li>
    <li><a href="../caml-light/">Caml Light</a></li>
    <li><a href="../logos.html">Logos</a></li>
  </ul>
</li>

            </ul>
	    <form action="http://www.google.com/search" method="get" class="navbar-search pull-right">
	      <input placeholder="Search" class="search-query" name="q" type="text"/>
	      <input value="site:http://www.ocaml-lang.org/" name="q" type="hidden"/>
	    </form>
            
	    
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <span class="navigation-bar">
	<a href="./../">Home</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span><a href="./">Tutorials</a><span class="separation"><img src=".././img/right_arrow.png" alt="&gt;"/></span>Modules
	<span id="language">
	  <span class="horizontal-toolbar"><span class="open-bracket">[</span><span class="current-url">En</span><span class="close-bracket">]</span></span>
	</span>
      </span>

      
<h1><span>Modules</span></h1>
<a name="Basic_usage"></a><h2><span>Basic usage</span></h2>
<p class="first_para">In OCaml, every piece of code is wrapped into a module. Optionally, a module itself can be a submodule of another module, pretty much like directories in a file system-but we don't do this very often.</p>
<p>When you write a program let's say using two files <code>amodule.ml</code> and <code>bmodule.ml</code>, each of these files automatically defines a module named <code>Amodule</code> and a module named <code>Bmodule</code> that provide whatever you put into the files.</p>
<p>Here is the code that we have in our file <code>amodule.ml</code>:</p>
<pre>
let hello () = print_endline &quot;Hello&quot;
</pre>

<p class="first_para">And here is what we have in <code>bmodule.ml</code>:</p>
<pre>
Amodule.hello ()
</pre>

<p class="first_para">Usually files are compiled one by one, let's do it:</p>
<pre>
ocamlopt -c amodule.ml
ocamlopt -c bmodule.ml
ocamlopt -o hello amodule.cmx bmodule.cmx
</pre>

<p class="first_para">Now we have a wonderful executable that prints &quot;Hello&quot;. As you can see, if you want to access anything from a given module, use the name of the module (always starting with a capital) followed by a dot and the thing that you want to use. It may be a value, a type constructor, or anything else that a given module can provide.</p>
<p>Libraries, starting with the standard library, provide collections of modules. for example, <code>List.iter</code> designates the <code>iter</code> function from the <code>List</code> module.</p>
<p>OK, if you are using a given module heavily, you may want to make its contents directly accessible. For this, we use the <code>open</code> directive. In our example, <code>bmodule.ml</code> could have been written:</p>
<pre>
open Amodule;;
hello ();;
</pre>

<p class="first_para">As a side note, people tend to avoid the ugly &quot;;;&quot;, so it more common to write it like:</p>
<pre>
open Amodule
let _ = hello ()
</pre>

<p class="first_para">Anyway, using <code>open</code> or not is a matter of personal taste. Some modules provide names that are used in many other modules. This is the case of the <code>List</code> module for instance. Usually we don't do <code>open List</code>. Other modules like <code>Printf</code> provide names that are normally not subject to conflicts, such as <code>printf</code>. In order to avoid writing <code>Printf.printf</code> all over the place, it often makes sense to place one <code>open Printf</code> at the beginning of the file.</p>
<p>There is a short example illustrating what we just mentioned:</p>
<pre>
open Printf
let my_data = [ &quot;a&quot;; &quot;beautiful&quot;; &quot;day&quot; ]
let _ = List.iter (fun s -&gt; printf &quot;%s\n&quot; s) my_data
</pre>

<a name="Interfaces_and_signatures"></a><h2><span>Interfaces and signatures</span></h2>
<p class="first_para">A module can provide a certain number of things (functions, types, submodules, ...) to the rest of the program that is using it. If nothing special is done, everything which is defined in a module will be accessible from outside. That's often fine in small personal programs, but there are many situations where it is better that a module only provides what it is meant to provide, not any of the auxilliary functions and types that are used internally.</p>
<p>For this we have to define a module interface, which will act as a mask over the module's implementation. Just like a module derives from a .ml file, the corresponding module interface or signature derives from a .mli file. It contains a list of values with their type, and more. Let's rewrite our <code>amodule.ml</code> file:</p>
<pre>
let message = &quot;Hello&quot;
let hello () = print_endline message
</pre>

<p class="first_para">As it is, <code>Amodule</code> has the following interface:</p>
<pre>
val message : string
val hello : unit -&gt; unit
</pre>

<p class="first_para">Let's assume that accessing the <code>message</code> value directly is none of the others modules' business. We want to hide it by defining a restricted interface. This is our <code>amodule.mli</code> file:</p>
<pre>
val hello : unit -&gt; unit
(** displays a greeting message *)
</pre>

<p class="first_para">(note that it is a good habit to document .mli files, using the format supported by <a title="http://caml.inria.fr/pub/docs/manual-ocaml/manual029.html" class="external" href="../caml.inria.fr/pub/docs/manual-ocaml/manual029.html">ocamldoc</a>)</p>
<p>.mli files must be compiled just before the matching .ml files. They are compiled using <code>ocamlc</code>, even if .ml files are compiled to native code using <code>ocamlopt</code>:</p>
<pre>
ocamlc -c amodule.mli
ocamlopt -c amodule.ml
...
</pre>

<a name="Abstract_types"></a><h2><span>Abstract types</span></h2>
<p class="first_para">What about type definitions? We saw that values such as functions can be exported by placing their name and their type in a .mli file, e.g.</p>
<pre>
val hello : unit -&gt; unit
</pre>

<p class="first_para">But modules often define new types. Let's define a simple record type that would represent a date:</p>
<pre>
type date = { day : int;
              month : int;
              year : int }
</pre>

<p class="first_para">There are not two, but four options when it comes to writing the .mli file:</p>
<ol><li>The type is completely omitted from the signature.</li>
<li>The type definition is copy-pasted into the signature.</li>
<li>The type is made abstract: only its name is given.</li>
<li>The record fields are made read-only: <code>type date = private { ... }</code></li></ol>
<p class="first_para">In case 3, it would be the following code:</p>
<pre>
type date
</pre>

<p class="first_para">Now, users of the module can manipulate objects of type <code>date</code>, but they can't access the record fields directly. They must use the functions that the module provides. Let's assume the module provides three functions, one for creating a date, one for computing the difference between two dates, and one that returns the date in years:</p>
<pre>
type date
val create : ?days:int -&gt; ?months:int -&gt; ?years:int -&gt; unit -&gt; date
val sub : date -&gt; date -&gt; date
val years : date -&gt; float
</pre>

<p class="first_para">The point is that only <code>create</code> and <code>sub</code> can be used to create <code>date</code> records. Therefore it is not possible for the user of the module to create ill-formed records. Actually, our implementation uses a record, but we could change it and be sure that it will not break any code that relies on this module! This takes all its sense in a library since subsequent versions of the same library can continue to expose the same interface, while internally changing the implementation, including data structures.</p>
<a name="Submodules"></a><h2><span>Submodules</span></h2>
<h3>Submodule implementation</h3>
<p class="first_para">We saw that one <code>example.ml</code> file results automatically in one module implementation named <code>Example</code>. Its module signature is  automatically derived and is the broadest possible, or can be restricted by writing an <code>example.mli</code> file.</p>
<p>That said, a given module can also be defined explicitely from within a file. That makes it a submodule of the current module. Let's consider this <code>example.ml</code> file:</p>
<pre>
module Hello = 
struct
  let message = &quot;Hello&quot;
  let hello () = print_endline message
end
let goodbye () = print_endline &quot;Goodbye&quot;
let hello_goodbye () =
  Hello.hello ();
  goodbye ()
</pre>

<p class="first_para">From another file, it is clear that we now have two levels of modules. We can write:</p>
<pre>
let _ =
  Example.Hello.hello ();
  Example.goodbye ()
</pre>

<h3>Submodule interface</h3>
<p class="first_para">We can also restrict the interface of a given submodule. It is called a module type. Let's do it in our <code>example.ml</code> file:</p>
<pre>
module Hello : 
sig
 val hello : unit -&gt; unit
end = 
struct
  let message = &quot;Hello&quot;
  let hello () = print_endline message
end
</pre>

<pre>
(* At this point, Hello.message is not accessible anymore. *)
let goodbye () = print_endline &quot;Goodbye&quot;
let hello_goodbye () =
  Hello.hello ();
  goodbye ()
</pre>

<p class="first_para">The definition of the <code>Hello</code> module above is the equivalent of a <code>hello.mli</code>/<code>hello.ml</code> pair of files. Writing all of that in one block of code is not elegant, so in general we prefer to define the module signature separately:</p>
<pre>
module type Hello_type =
sig
 val hello : unit -&gt; unit
end
</pre>

<pre>
module Hello : Hello_type =
struct
  ...
end
</pre>

<p class="first_para"><code>Hello_type</code> is a named module type, and can be reused to define other module interfaces.</p>
<p>Although having submodules may be useful in some cases, their real utility becomes apparent with functors. This is the next section.</p>
<a name="Functors"></a><h2><span>Functors</span></h2>
<p class="first_para">Functors are probably one of the most complex features of OCaml, but you don't have to use them extensively to be a successful OCaml programmer. Actually, you may never have to define a functor yourself, but you will surely encounter them in the standard library. They are the only way of using the Set and Map modules, but using them is not so difficult.</p>
<h3>What is a functor and why do we need them?</h3>
<p class="first_para">A functor is a module that is parametrized by another module, just like a function is a value which is parametrized by other values, the arguments.</p>
<p>Basically, it allows to parametrize a type by a value, which is not possible directly in OCaml. For example, we can define a functor that takes an int n and returns a collection of array operations that work exclusively on arrays of length n. If by mistake the programmer passes a regular array to one of those functions, it will result in a compilation error. If we were not using this functor but the standard array type, the compiler would not be able to detect the error, and we would get a runtime error at some undetermined date in the future, which is much worse.</p>
<h3>How to use an existing functor?</h3>
<p class="first_para">The standard library defines a <code>Set</code> module, which provides a <code>Make</code> functor. This functor takes one argument, which is a module that provides (at least) two things: the type of elements, given as <code>t</code> and the comparison function given as <code>compare</code>. The point of the functor is to ensure that the same comparison function will always be used, even if the programmer makes a mistake.</p>
<p>For example, if we want to use sets of ints, we would use do this:</p>
<pre>
module Int_set = Set.Make (struct
                             type t = int
                             let compare = compare
                           end)
</pre>

<p class="first_para">For sets of strings, it is even easier because the standard library provides a <code>String</code> module with a type <code>t</code> and a function <code>compare</code>. If you were following carefully, by now you must have guessed how to create a module for the manipulation of sets of strings:</p>
<pre>
module String_set = Set.Make (String)
</pre>

<p class="first_para">(the parentheses are necessary)</p>
<h3>How to define a functor?</h3>
<p class="first_para">A functor with one argument can be defined like this:</p>
<pre>
module F (X : X_type) =
struct
 ...
end
</pre>

<p class="first_para">where <code>X</code> is the module that will passed as argument, and <code>X_type</code> is its signature, which is mandatory.</p>
<p>The signature of the returned module itself can be constrained, using this syntax:</p>
<pre>
module F (X : X_type) : Y_type =
struct
  ...
end
</pre>

<p class="first_para">or by specifying this in the .mli file:</p>
<pre>
module F (X : X_type) : Y_type
</pre>

<p class="first_para">Overall, the syntax of functors is hard to grasp. The best may be to look at the source files <code>set.ml</code> or <code>map.ml</code> of the standard library.</p>
<p>Final remark: functors are made to help programmers write correct programs, not to improve performance. There is even a runtime penalty, unless you use a defunctorizer such as ocamldefun, which requires access to the source code of the functor.</p>
<a name="Practical_manipulation_of_modules"></a><h2><span>Practical manipulation of modules</span></h2>
<h3>Displaying the interface of a module</h3>
<p class="first_para">In the <code>ocaml</code> toplevel, the following trick allows to visualize the contents of an existing module, such as <code>List</code>:</p>
<pre>
# module M = List;;
module M :
  sig
    val length : 'a list -&gt; int
    val hd : 'a list -&gt; 'a
    val tl : 'a list -&gt; 'a list
    val nth : 'a list -&gt; int -&gt; 'a
    val rev : 'a list -&gt; 'a list
    ...
  end
</pre>

<p class="first_para">Otherwise, there is online documentation for most libraries or you can use <code>ocamlbrowser</code> which comes with labltk (Tk graphical user interface for OCaml).</p>
<h3>Module inclusion</h3>
<p class="first_para">Let's say we feel that a function is missing from the standard <code>List</code> module, but we really want as if it were part of it. In an <code>extensions.ml</code> file, we can achieve this effect by using the <code>include</code> directive:</p>
<pre>
module List =
struct
 include List
 let rec optmap f = function
     [] -&gt; []
   | hd :: tl -&gt;
       match f hd with
           None -&gt; optmap f tl
         | Some x -&gt; x :: optmap f tl
end
</pre>

<p class="first_para">It creates a module <code>Extensions.List</code>, that has everything that the standard <code>List</code> module has, plus a new <code>optmap</code> function. From another file, all we have to do to override the default <code>List</code> module is <code>open Extensions</code> at the beginning of the .ml file:</p>
<pre>
open Extensions
...
List.optmap ...
</pre>




    </div>

    
    <br/>
    <hr/>
    <div id="footer">
      Contribute to this project!
      Find us on <a href="https://github.com/ocaml/ocaml.org">Github</a>.
    </div>
    <span title=".././img/ = image directory from the base of the site"></span>


    
    
    

    <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    <script src=".././js/jquery-1.8.0.min.js"></script>
    
    <script src=".././js/bootstrap.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22552764-2']); _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
</body></html>
